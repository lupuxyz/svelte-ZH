import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, q as create_slot, e as element, c as claim_element, a as children, b as detach_dev, f as attr_dev, h as add_location, j as insert_dev, l as space, m as empty, p as claim_space, W as add_render_callback, k as append_dev, X as add_resize_listener, C as get_slot_changes, D as get_slot_context, x as transition_in, y as transition_out, V as binding_callbacks, Y as createEventDispatcher, G as globals, L as getContext, Z as subscribe, v as validate_store, r as component_subscribe, M as svg_element, T as listen_dev, R as destroy_each, U as run_all, Q as toggle_class, n as noop, u as set_store_value, E as text, F as claim_text, H as set_data_dev, _ as set_input_value, A as group_outros, B as check_outros, $ as create_in_transition, a0 as create_out_transition, o as onMount, g as set_style, w as mount_component, z as destroy_component, a1 as prop_dev, a2 as now, a3 as loop, a4 as bind, a5 as add_flush_callback, t as setContext, a6 as null_to_empty, a7 as stop_propagation } from './index.b2dd6920.js';
import { w as writable } from './index.ea650d67.js';

function clamp(num, min, max) {
    return num < min ? min : num > max ? max : num;
}

/* node_modules\@sveltejs\svelte-repl\src\SplitPane.svelte generated by Svelte v3.12.0 */

const file = "node_modules\\@sveltejs\\svelte-repl\\src\\SplitPane.svelte";

const get_b_slot_changes = () => ({});
const get_b_slot_context = () => ({});

const get_a_slot_changes = () => ({});
const get_a_slot_context = () => ({});

// (161:1) {#if !fixed}
function create_if_block_1(ctx) {
	var div, div_class_value, div_style_value, drag_action;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true }, false);
			var div_nodes = children(div);

			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + ctx.type + " divider" + " svelte-1k0d9r4");
			attr_dev(div, "style", div_style_value = "" + ctx.side + ": calc(" + ctx.pos + "% - 8px)");
			add_location(div, file, 161, 2, 2754);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			drag_action = ctx.drag.call(null, div, ctx.setPos) || {};
		},

		p: function update(changed, ctx) {
			if ((changed.type) && div_class_value !== (div_class_value = "" + ctx.type + " divider" + " svelte-1k0d9r4")) {
				attr_dev(div, "class", div_class_value);
			}

			if ((changed.side || changed.pos) && div_style_value !== (div_style_value = "" + ctx.side + ": calc(" + ctx.pos + "% - 8px)")) {
				attr_dev(div, "style", div_style_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (drag_action && typeof drag_action.destroy === 'function') drag_action.destroy();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(161:1) {#if !fixed}", ctx });
	return block;
}

// (166:0) {#if dragging}
function create_if_block(ctx) {
	var div;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "mousecatcher svelte-1k0d9r4");
			add_location(div, file, 166, 1, 2873);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(166:0) {#if dragging}", ctx });
	return block;
}

function create_fragment(ctx) {
	var div2, div0, div0_style_value, t0, div1, div1_style_value, t1, div2_resize_listener, t2, if_block1_anchor, current;

	const a_slot_template = ctx.$$slots.a;
	const a_slot = create_slot(a_slot_template, ctx, get_a_slot_context);

	const b_slot_template = ctx.$$slots.b;
	const b_slot = create_slot(b_slot_template, ctx, get_b_slot_context);

	var if_block0 = (!ctx.fixed) && create_if_block_1(ctx);

	var if_block1 = (ctx.dragging) && create_if_block(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");

			if (a_slot) a_slot.c();
			t0 = space();
			div1 = element("div");

			if (b_slot) b_slot.c();
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div0 = claim_element(div2_nodes, "DIV", { class: true, style: true }, false);
			var div0_nodes = children(div0);

			if (a_slot) a_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div2_nodes);

			div1 = claim_element(div2_nodes, "DIV", { class: true, style: true }, false);
			var div1_nodes = children(div1);

			if (b_slot) b_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			if (if_block0) if_block0.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "pane svelte-1k0d9r4");
			attr_dev(div0, "style", div0_style_value = "" + ctx.dimension + ": " + ctx.pos + "%;");
			add_location(div0, file, 152, 1, 2565);

			attr_dev(div1, "class", "pane svelte-1k0d9r4");
			attr_dev(div1, "style", div1_style_value = "" + ctx.dimension + ": " + (100 - (ctx.pos)) + "%;");
			add_location(div1, file, 156, 1, 2648);
			add_render_callback(() => ctx.div2_resize_handler.call(div2));
			attr_dev(div2, "class", "container svelte-1k0d9r4");
			add_location(div2, file, 151, 0, 2470);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);

			if (a_slot) {
				a_slot.m(div0, null);
			}

			append_dev(div2, t0);
			append_dev(div2, div1);

			if (b_slot) {
				b_slot.m(div1, null);
			}

			append_dev(div2, t1);
			if (if_block0) if_block0.m(div2, null);
			div2_resize_listener = add_resize_listener(div2, ctx.div2_resize_handler.bind(div2));
			ctx.div2_binding(div2);
			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (a_slot && a_slot.p && changed.$$scope) {
				a_slot.p(
					get_slot_changes(a_slot_template, ctx, changed, get_a_slot_changes),
					get_slot_context(a_slot_template, ctx, get_a_slot_context)
				);
			}

			if ((!current || changed.dimension || changed.pos) && div0_style_value !== (div0_style_value = "" + ctx.dimension + ": " + ctx.pos + "%;")) {
				attr_dev(div0, "style", div0_style_value);
			}

			if (b_slot && b_slot.p && changed.$$scope) {
				b_slot.p(
					get_slot_changes(b_slot_template, ctx, changed, get_b_slot_changes),
					get_slot_context(b_slot_template, ctx, get_b_slot_context)
				);
			}

			if ((!current || changed.dimension || changed.pos) && div1_style_value !== (div1_style_value = "" + ctx.dimension + ": " + (100 - (ctx.pos)) + "%;")) {
				attr_dev(div1, "style", div1_style_value);
			}

			if (!ctx.fixed) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div2, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.dragging) {
				if (!if_block1) {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(a_slot, local);
			transition_in(b_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(a_slot, local);
			transition_out(b_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div2);
			}

			if (a_slot) a_slot.d(detaching);

			if (b_slot) b_slot.d(detaching);
			if (if_block0) if_block0.d();
			div2_resize_listener.cancel();
			ctx.div2_binding(null);

			if (detaching) {
				detach_dev(t2);
			}

			if (if_block1) if_block1.d(detaching);

			if (detaching) {
				detach_dev(if_block1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function instance($$self, $$props, $$invalidate) {
	

	const dispatch = createEventDispatcher();

	let { type, pos = 50, fixed = false, buffer = 40, min, max } = $$props;

	let w;
	let h;

	const refs = {};

	let dragging = false;

	function setPos(event) {
		const { top, left } = refs.container.getBoundingClientRect();

		const px = type === 'vertical'
			? (event.clientY - top)
			: (event.clientX - left);

		$$invalidate('pos', pos = 100 * px / size);
		dispatch('change');
	}

	function drag(node, callback) {
		const mousedown = event => {
			if (event.which !== 1) return;

			event.preventDefault();

			$$invalidate('dragging', dragging = true);

			const onmouseup = () => {
				$$invalidate('dragging', dragging = false);

				window.removeEventListener('mousemove', callback, false);
				window.removeEventListener('mouseup', onmouseup, false);
			};

			window.addEventListener('mousemove', callback, false);
			window.addEventListener('mouseup', onmouseup, false);
		};

		node.addEventListener('mousedown', mousedown, false);

		return {
			destroy() {
				node.removeEventListener('mousedown', onmousedown, false);
			}
		};
	}

	const writable_props = ['type', 'pos', 'fixed', 'buffer', 'min', 'max'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<SplitPane> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function div2_resize_handler() {
		w = this.clientWidth;
		h = this.clientHeight;
		$$invalidate('w', w);
		$$invalidate('h', h);
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refs.container = $$value;
			$$invalidate('refs', refs);
		});
	}

	$$self.$set = $$props => {
		if ('type' in $$props) $$invalidate('type', type = $$props.type);
		if ('pos' in $$props) $$invalidate('pos', pos = $$props.pos);
		if ('fixed' in $$props) $$invalidate('fixed', fixed = $$props.fixed);
		if ('buffer' in $$props) $$invalidate('buffer', buffer = $$props.buffer);
		if ('min' in $$props) $$invalidate('min', min = $$props.min);
		if ('max' in $$props) $$invalidate('max', max = $$props.max);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { type, pos, fixed, buffer, min, max, w, h, dragging, size, side, dimension };
	};

	$$self.$inject_state = $$props => {
		if ('type' in $$props) $$invalidate('type', type = $$props.type);
		if ('pos' in $$props) $$invalidate('pos', pos = $$props.pos);
		if ('fixed' in $$props) $$invalidate('fixed', fixed = $$props.fixed);
		if ('buffer' in $$props) $$invalidate('buffer', buffer = $$props.buffer);
		if ('min' in $$props) $$invalidate('min', min = $$props.min);
		if ('max' in $$props) $$invalidate('max', max = $$props.max);
		if ('w' in $$props) $$invalidate('w', w = $$props.w);
		if ('h' in $$props) $$invalidate('h', h = $$props.h);
		if ('dragging' in $$props) $$invalidate('dragging', dragging = $$props.dragging);
		if ('size' in $$props) $$invalidate('size', size = $$props.size);
		if ('side' in $$props) $$invalidate('side', side = $$props.side);
		if ('dimension' in $$props) $$invalidate('dimension', dimension = $$props.dimension);
	};

	let size, side, dimension;

	$$self.$$.update = ($$dirty = { type: 1, h: 1, w: 1, buffer: 1, size: 1, min: 1, pos: 1, max: 1 }) => {
		if ($$dirty.type || $$dirty.h || $$dirty.w) { $$invalidate('size', size = type === 'vertical' ? h : w); }
		if ($$dirty.buffer || $$dirty.size) { $$invalidate('min', min = 100 * (buffer / size)); }
		if ($$dirty.min) { $$invalidate('max', max = 100 - min); }
		if ($$dirty.pos || $$dirty.min || $$dirty.max) { $$invalidate('pos', pos = clamp(pos, min, max)); }
		if ($$dirty.type) { $$invalidate('side', side = type === 'horizontal' ? 'left' : 'top'); }
		if ($$dirty.type) { $$invalidate('dimension', dimension = type === 'horizontal' ? 'width' : 'height'); }
	};

	return {
		type,
		pos,
		fixed,
		buffer,
		min,
		max,
		w,
		h,
		refs,
		dragging,
		setPos,
		drag,
		side,
		dimension,
		div2_resize_handler,
		div2_binding,
		$$slots,
		$$scope
	};
}

class SplitPane extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["type", "pos", "fixed", "buffer", "min", "max"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "SplitPane", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.type === undefined && !('type' in props)) {
			console.warn("<SplitPane> was created without expected prop 'type'");
		}
		if (ctx.min === undefined && !('min' in props)) {
			console.warn("<SplitPane> was created without expected prop 'min'");
		}
		if (ctx.max === undefined && !('max' in props)) {
			console.warn("<SplitPane> was created without expected prop 'max'");
		}
	}

	get type() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pos() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pos(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fixed() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fixed(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buffer() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buffer(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<SplitPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<SplitPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Input\ComponentSelector.svelte generated by Svelte v3.12.0 */
const { console: console_1 } = globals;

const file$1 = "node_modules\\@sveltejs\\svelte-repl\\src\\Input\\ComponentSelector.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.component = list[i];
	child_ctx.index = i;
	return child_ctx;
}

// (213:1) {#if $components.length}
function create_if_block$1(ctx) {
	var div, t, button, svg, line0, line1, dispose;

	let each_value = ctx.$components;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			button = element("button");
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t = claim_space(div_nodes);

			button = claim_element(div_nodes, "BUTTON", { class: true, title: true }, false);
			var button_nodes = children(button);

			svg = claim_element(button_nodes, "svg", { width: true, height: true, viewBox: true, class: true }, true);
			var svg_nodes = children(svg);

			line0 = claim_element(svg_nodes, "line", { stroke: true, x1: true, y1: true, x2: true, y2: true }, true);
			var line0_nodes = children(line0);

			line0_nodes.forEach(detach_dev);

			line1 = claim_element(svg_nodes, "line", { stroke: true, x1: true, y1: true, x2: true, y2: true }, true);
			var line1_nodes = children(line1);

			line1_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(line0, "stroke", "#999");
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "5");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "19");
			add_location(line0, file$1, 263, 5, 5664);
			attr_dev(line1, "stroke", "#999");
			attr_dev(line1, "x1", "5");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "19");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$1, 264, 5, 5723);
			attr_dev(svg, "width", "12");
			attr_dev(svg, "height", "12");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "class", "svelte-zab12q");
			add_location(svg, file$1, 262, 4, 5610);
			attr_dev(button, "class", "add-new svelte-zab12q");
			attr_dev(button, "title", "add new component");
			add_location(button, file$1, 261, 3, 5537);
			attr_dev(div, "class", "file-tabs svelte-zab12q");
			add_location(div, file$1, 213, 2, 4077);

			dispose = [
				listen_dev(button, "click", ctx.addNew),
				listen_dev(div, "dblclick", ctx.addNew)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_dev(div, t);
			append_dev(div, button);
			append_dev(button, svg);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},

		p: function update(changed, ctx) {
			if (changed.$components || changed.$selected || changed.editing || changed.isComponentNameUsed) {
				each_value = ctx.$components;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, t);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$1.name, type: "if", source: "(213:1) {#if $components.length}", ctx });
	return block;
}

// (242:6) {:else}
function create_else_block(ctx) {
	var div, t0_value = ctx.component.name + "", t0, t1, t2_value = ctx.component.type + "", t2, t3, span, svg, line0, line1, dispose;

	function click_handler() {
		return ctx.click_handler(ctx);
	}

	function click_handler_1() {
		return ctx.click_handler_1(ctx);
	}

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = text(".");
			t2 = text(t2_value);
			t3 = space();
			span = element("span");
			svg = svg_element("svg");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, title: true }, false);
			var div_nodes = children(div);

			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_text(div_nodes, ".");
			t2 = claim_text(div_nodes, t2_value);
			div_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);

			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			svg = claim_element(span_nodes, "svg", { width: true, height: true, viewBox: true, class: true }, true);
			var svg_nodes = children(svg);

			line0 = claim_element(svg_nodes, "line", { stroke: true, x1: true, y1: true, x2: true, y2: true }, true);
			var line0_nodes = children(line0);

			line0_nodes.forEach(detach_dev);

			line1 = claim_element(svg_nodes, "line", { stroke: true, x1: true, y1: true, x2: true, y2: true }, true);
			var line1_nodes = children(line1);

			line1_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "editable svelte-zab12q");
			attr_dev(div, "title", "edit component name");
			add_location(div, file$1, 242, 7, 5033);
			attr_dev(line0, "stroke", "#999");
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "6");
			attr_dev(line0, "x2", "6");
			attr_dev(line0, "y2", "18");
			add_location(line0, file$1, 252, 9, 5343);
			attr_dev(line1, "stroke", "#999");
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "18");
			attr_dev(line1, "y2", "18");
			add_location(line1, file$1, 253, 9, 5405);
			attr_dev(svg, "width", "12");
			attr_dev(svg, "height", "12");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "class", "svelte-zab12q");
			add_location(svg, file$1, 251, 8, 5285);
			attr_dev(span, "class", "remove svelte-zab12q");
			add_location(span, file$1, 250, 7, 5218);

			dispose = [
				listen_dev(div, "click", click_handler),
				listen_dev(span, "click", click_handler_1)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, span, anchor);
			append_dev(span, svg);
			append_dev(svg, line0);
			append_dev(svg, line1);
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			if ((changed.$components) && t0_value !== (t0_value = ctx.component.name + "")) {
				set_data_dev(t0, t0_value);
			}

			if ((changed.$components) && t2_value !== (t2_value = ctx.component.type + "")) {
				set_data_dev(t2, t2_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
				detach_dev(t3);
				detach_dev(span);
			}

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(242:6) {:else}", ctx });
	return block;
}

// (229:6) {#if component === editing}
function create_if_block_2(ctx) {
	var span, t0_value = ctx.editing.name + (/\./.test(ctx.editing.name) ? '' : `.${ctx.editing.type}`) + "", t0, t1, input, dispose;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			input = element("input");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t0 = claim_text(span_nodes, t0_value);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);

			input = claim_element(nodes, "INPUT", { autofocus: true, spellcheck: true, class: true }, false);
			var input_nodes = children(input);

			input_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "input-sizer svelte-zab12q");
			add_location(span, file$1, 229, 7, 4555);
			input.autofocus = true;
			attr_dev(input, "spellcheck", false);
			attr_dev(input, "class", "svelte-zab12q");
			toggle_class(input, "duplicate", ctx.isComponentNameUsed(ctx.editing));
			add_location(input, file$1, 232, 7, 4710);

			dispose = [
				listen_dev(input, "input", ctx.input_input_handler),
				listen_dev(input, "focus", selectInput),
				listen_dev(input, "blur", ctx.closeEdit),
				listen_dev(input, "keydown", ctx.keydown_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, input, anchor);

			set_input_value(input, ctx.editing.name);

			input.focus();
		},

		p: function update(changed, ctx) {
			if ((changed.editing) && t0_value !== (t0_value = ctx.editing.name + (/\./.test(ctx.editing.name) ? '' : `.${ctx.editing.type}`) + "")) {
				set_data_dev(t0, t0_value);
			}

			if (changed.editing && (input.value !== ctx.editing.name)) set_input_value(input, ctx.editing.name);

			if ((changed.isComponentNameUsed || changed.editing)) {
				toggle_class(input, "duplicate", ctx.isComponentNameUsed(ctx.editing));
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
				detach_dev(t1);
				detach_dev(input);
			}

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2.name, type: "if", source: "(229:6) {#if component === editing}", ctx });
	return block;
}

// (224:5) {#if component.name == 'App' && index === 0}
function create_if_block_1$1(ctx) {
	var div, t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("App.svelte");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			t = claim_text(div_nodes, "App.svelte");
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "uneditable svelte-zab12q");
			add_location(div, file$1, 224, 6, 4445);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$1.name, type: "if", source: "(224:5) {#if component.name == 'App' && index === 0}", ctx });
	return block;
}

// (215:3) {#each $components as component, index}
function create_each_block(ctx) {
	var div, div_id_value, dispose;

	function select_block_type(changed, ctx) {
		if (ctx.component.name == 'App' && ctx.index === 0) return create_if_block_1$1;
		if (ctx.component === ctx.editing) return create_if_block_2;
		return create_else_block;
	}

	var current_block_type = select_block_type(null, ctx);
	var if_block = current_block_type(ctx);

	function click_handler_2() {
		return ctx.click_handler_2(ctx);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, role: true }, false);
			var div_nodes = children(div);

			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "id", div_id_value = ctx.component.name);
			attr_dev(div, "class", "button svelte-zab12q");
			attr_dev(div, "role", "button");
			toggle_class(div, "active", ctx.component === ctx.$selected);
			add_location(div, file$1, 215, 4, 4171);

			dispose = [
				listen_dev(div, "click", click_handler_2),
				listen_dev(div, "dblclick", dblclick_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_block.m(div, null);
		},

		p: function update(changed, new_ctx) {
			ctx = new_ctx;
			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
				if_block.p(changed, ctx);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);
				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if ((changed.$components) && div_id_value !== (div_id_value = ctx.component.name)) {
				attr_dev(div, "id", div_id_value);
			}

			if ((changed.$components || changed.$selected)) {
				toggle_class(div, "active", ctx.component === ctx.$selected);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if_block.d();
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(215:3) {#each $components as component, index}", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var div;

	var if_block = (ctx.$components.length) && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "component-selector svelte-zab12q");
			add_location(div, file$1, 211, 0, 4016);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
		},

		p: function update(changed, ctx) {
			if (ctx.$components.length) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block) if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

function selectInput(event) {
	setTimeout(() => {
		event.target.select();
	});
}

const dblclick_handler = (e) => e.stopPropagation();

function instance$1($$self, $$props, $$invalidate) {
	let $selected, $components, $$unsubscribe_components = noop, $$subscribe_components = () => ($$unsubscribe_components(), $$unsubscribe_components = subscribe(components, $$value => { $components = $$value; $$invalidate('$components', $components); }), components);

	$$self.$$.on_destroy.push(() => $$unsubscribe_components());

	let { handle_select } = $$props;

	const { components, selected, request_focus, rebundle } = getContext('REPL'); $$subscribe_components(); validate_store(selected, 'selected'); component_subscribe($$self, selected, $$value => { $selected = $$value; $$invalidate('$selected', $selected); });

	let editing = null;

	function selectComponent(component) {
		if ($selected !== component) {
			$$invalidate('editing', editing = null);
			handle_select(component);
		}
	}

	function editTab(component) {
		if ($selected === component) {
			$$invalidate('editing', editing = $selected);
		}
	}

	function closeEdit() {
		const match = /(.+)\.(svelte|js)$/.exec($selected.name);
		set_store_value(selected, $selected.name = match ? match[1] : $selected.name, $selected);
		if (isComponentNameUsed($selected)) {
			set_store_value(selected, $selected.name = $selected.name + '_1', $selected);
		}
		if (match && match[2]) set_store_value(selected, $selected.type = match[2], $selected);


		$$invalidate('editing', editing = null);

		// re-select, in case the type changed
		handle_select($selected);

		$$subscribe_components($$invalidate('components', components)); // TODO necessary?

		// focus the editor, but wait a beat (so key events aren't misdirected)
		setTimeout(request_focus);

		rebundle();
	}

	function remove(component) {
		let result = confirm(`Are you sure you want to delete ${component.name}.${component.type}?`);

		if (result) {
			const index = $components.indexOf(component);

			if (~index) {
				components.set($components.slice(0, index).concat($components.slice(index + 1)));
			} else {
				console.error(`Could not find component! That's... odd`);
			}

			handle_select($components[index] || $components[$components.length - 1]);
		}
	}

	let uid = 1;

	function addNew() {
		const component = {
			name: uid++ ? `Component${uid}` : 'Component1',
			type: 'svelte',
			source: ''
		};

		$$invalidate('editing', editing = component);

		setTimeout(() => {
			// TODO we can do this without IDs
			document.getElementById(component.name).scrollIntoView(false);
		});

		components.update(components => components.concat(component));
		handle_select(component);
	}

	function isComponentNameUsed(editing) {
		return $components.find(component => component !== editing && component.name === editing.name);
	}

	const writable_props = ['handle_select'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1.warn(`<ComponentSelector> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		editing.name = this.value;
		$$invalidate('editing', editing);
	}

	const keydown_handler = (e) => e.which === 13 && !isComponentNameUsed(editing) && e.target.blur();

	const click_handler = ({ component }) => editTab(component);

	const click_handler_1 = ({ component }) => remove(component);

	const click_handler_2 = ({ component }) => selectComponent(component);

	$$self.$set = $$props => {
		if ('handle_select' in $$props) $$invalidate('handle_select', handle_select = $$props.handle_select);
	};

	$$self.$capture_state = () => {
		return { handle_select, editing, uid, $selected, $components };
	};

	$$self.$inject_state = $$props => {
		if ('handle_select' in $$props) $$invalidate('handle_select', handle_select = $$props.handle_select);
		if ('editing' in $$props) $$invalidate('editing', editing = $$props.editing);
		if ('uid' in $$props) uid = $$props.uid;
		if ('$selected' in $$props) selected.set($selected);
		if ('$components' in $$props) components.set($components);
	};

	return {
		handle_select,
		components,
		selected,
		editing,
		selectComponent,
		editTab,
		closeEdit,
		remove,
		addNew,
		isComponentNameUsed,
		$selected,
		$components,
		input_input_handler,
		keydown_handler,
		click_handler,
		click_handler_1,
		click_handler_2
	};
}

class ComponentSelector extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["handle_select"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "ComponentSelector", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.handle_select === undefined && !('handle_select' in props)) {
			console_1.warn("<ComponentSelector> was created without expected prop 'handle_select'");
		}
	}

	get handle_select() {
		throw new Error("<ComponentSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set handle_select(value) {
		throw new Error("<ComponentSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const is_browser = typeof window !== 'undefined';

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => `overflow: hidden;` +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}

/* node_modules\@sveltejs\svelte-repl\src\Message.svelte generated by Svelte v3.12.0 */

const file$2 = "node_modules\\@sveltejs\\svelte-repl\\src\\Message.svelte";

// (88:1) {:else}
function create_else_block$1(ctx) {
	var current;

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},

		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},

		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$1.name, type: "else", source: "(88:1) {:else}", ctx });
	return block;
}

// (83:1) {#if details}
function create_if_block$2(ctx) {
	var p, t_value = ctx.message(ctx.details) + "", t, dispose;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t = claim_text(p_nodes, t_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(p, "class", "svelte-9488n4");
			toggle_class(p, "navigable", ctx.details.filename);
			add_location(p, file$2, 83, 2, 1471);
			dispose = listen_dev(p, "click", ctx.click_handler);
		},

		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},

		p: function update(changed, ctx) {
			if ((changed.details) && t_value !== (t_value = ctx.message(ctx.details) + "")) {
				set_data_dev(t, t_value);
			}

			if (changed.details) {
				toggle_class(p, "navigable", ctx.details.filename);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(p);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$2.name, type: "if", source: "(83:1) {#if details}", ctx });
	return block;
}

function create_fragment$2(ctx) {
	var div, current_block_type_index, if_block, div_class_value, div_intro, div_outro, current;

	var if_block_creators = [
		create_if_block$2,
		create_else_block$1
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.details) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "message " + ctx.kind + " svelte-9488n4");
			toggle_class(div, "truncate", ctx.truncate);
			add_location(div, file$2, 81, 0, 1343);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			if ((!current || changed.kind) && div_class_value !== (div_class_value = "message " + ctx.kind + " svelte-9488n4")) {
				attr_dev(div, "class", div_class_value);
			}

			if ((changed.kind || changed.truncate)) {
				toggle_class(div, "truncate", ctx.truncate);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, slide, {delay: 150, duration: 100});
				div_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			if (div_intro) div_intro.invalidate();

			div_outro = create_out_transition(div, slide, {duration: 100});

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if_blocks[current_block_type_index].d();

			if (detaching) {
				if (div_outro) div_outro.end();
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$2.name, type: "component", source: "", ctx });
	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	

	const { navigate } = getContext('REPL');

	let { kind, details = null, filename = null, truncate } = $$props;

	function message(details) {
		let str = details.message || '[missing message]';

		let loc = [];

		if (details.filename && details.filename !== filename) {
			loc.push(details.filename);
		}

		if (details.start) loc.push(details.start.line, details.start.column);

		return str + (loc.length ? ` (${loc.join(':')})` : ``);
	}
	const writable_props = ['kind', 'details', 'filename', 'truncate'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Message> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	const click_handler = () => navigate(details);

	$$self.$set = $$props => {
		if ('kind' in $$props) $$invalidate('kind', kind = $$props.kind);
		if ('details' in $$props) $$invalidate('details', details = $$props.details);
		if ('filename' in $$props) $$invalidate('filename', filename = $$props.filename);
		if ('truncate' in $$props) $$invalidate('truncate', truncate = $$props.truncate);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { kind, details, filename, truncate };
	};

	$$self.$inject_state = $$props => {
		if ('kind' in $$props) $$invalidate('kind', kind = $$props.kind);
		if ('details' in $$props) $$invalidate('details', details = $$props.details);
		if ('filename' in $$props) $$invalidate('filename', filename = $$props.filename);
		if ('truncate' in $$props) $$invalidate('truncate', truncate = $$props.truncate);
	};

	return {
		navigate,
		kind,
		details,
		filename,
		truncate,
		message,
		click_handler,
		$$slots,
		$$scope
	};
}

class Message extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["kind", "details", "filename", "truncate"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Message", options, id: create_fragment$2.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.kind === undefined && !('kind' in props)) {
			console.warn("<Message> was created without expected prop 'kind'");
		}
		if (ctx.truncate === undefined && !('truncate' in props)) {
			console.warn("<Message> was created without expected prop 'truncate'");
		}
	}

	get kind() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set kind(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get details() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set details(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get filename() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set filename(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get truncate() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set truncate(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\svelte-repl\src\CodeMirror.svelte generated by Svelte v3.12.0 */

const file$3 = "node_modules\\@sveltejs\\svelte-repl\\src\\CodeMirror.svelte";

// (272:1) {#if !CodeMirror}
function create_if_block$3(ctx) {
	var pre, t0, t1, div, current;

	var message = new Message({
		props: {
		kind: "info",
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			pre = element("pre");
			t0 = text(ctx.code);
			t1 = space();
			div = element("div");
			message.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			pre = claim_element(nodes, "PRE", { style: true, class: true }, false);
			var pre_nodes = children(pre);

			t0 = claim_text(pre_nodes, ctx.code);
			pre_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);

			div = claim_element(nodes, "DIV", { style: true }, false);
			var div_nodes = children(div);

			message.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			set_style(pre, "position", "absolute");
			set_style(pre, "left", "0");
			set_style(pre, "top", "0");
			attr_dev(pre, "class", "svelte-s9cc8a");
			add_location(pre, file$3, 272, 2, 5157);
			set_style(div, "position", "absolute");
			set_style(div, "width", "100%");
			set_style(div, "bottom", "0");
			add_location(div, file$3, 275, 2, 5225);
		},

		m: function mount(target, anchor) {
			insert_dev(target, pre, anchor);
			append_dev(pre, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			mount_component(message, div, null);
			current = true;
		},

		p: function update_1(changed, ctx) {
			if (!current || changed.code) {
				set_data_dev(t0, ctx.code);
			}

			var message_changes = {};
			if (changed.$$scope) message_changes.$$scope = { changed, ctx };
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(pre);
				detach_dev(t1);
				detach_dev(div);
			}

			destroy_component(message);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$3.name, type: "if", source: "(272:1) {#if !CodeMirror}", ctx });
	return block;
}

// (277:3) <Message kind='info'>
function create_default_slot(ctx) {
	var t;

	const block = {
		c: function create() {
			t = text("loading editor...");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "loading editor...");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot.name, type: "slot", source: "(277:3) <Message kind='info'>", ctx });
	return block;
}

function create_fragment$3(ctx) {
	var div, textarea, t, div_resize_listener, current;

	var if_block = (!ctx.CodeMirror) && create_if_block$3(ctx);

	const block = {
		c: function create() {
			div = element("div");
			textarea = element("textarea");
			t = space();
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			textarea = claim_element(div_nodes, "TEXTAREA", { tabindex: true, readonly: true, value: true, class: true }, false);
			var textarea_nodes = children(textarea);

			textarea_nodes.forEach(detach_dev);
			t = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(textarea, "tabindex", "2");
			textarea.readOnly = true;
			textarea.value = ctx.code;
			attr_dev(textarea, "class", "svelte-s9cc8a");
			add_location(textarea, file$3, 264, 1, 5044);
			add_render_callback(() => ctx.div_resize_handler.call(div));
			attr_dev(div, "class", "codemirror-container svelte-s9cc8a");
			toggle_class(div, "flex", ctx.flex);
			add_location(div, file$3, 262, 0, 4907);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, textarea);
			ctx.textarea_binding(textarea);
			append_dev(div, t);
			if (if_block) if_block.m(div, null);
			div_resize_listener = add_resize_listener(div, ctx.div_resize_handler.bind(div));
			current = true;
		},

		p: function update_1(changed, ctx) {
			if (!current || changed.code) {
				prop_dev(textarea, "value", ctx.code);
			}

			if (!ctx.CodeMirror) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}

			if (changed.flex) {
				toggle_class(div, "flex", ctx.flex);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			ctx.textarea_binding(null);
			if (if_block) if_block.d();
			div_resize_listener.cancel();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$3.name, type: "component", source: "", ctx });
	return block;
}

let codemirror_promise;
let _CodeMirror;

if (is_browser) {
	codemirror_promise = import('./codemirror.bc7e52bb.js');

	codemirror_promise.then(mod => {
		_CodeMirror = mod.default;
	});
}

function sleep(ms) {
	return new Promise(fulfil => setTimeout(fulfil, ms));
}

function instance$3($$self, $$props, $$invalidate) {
	

	const dispatch = createEventDispatcher();

	let { readonly = false, errorLoc = null, flex = false, lineNumbers = true, tab = true } = $$props;

	let w;
	let h;
	let code = '';
	let mode;

	// We have to expose set and update methods, rather
	// than making this state-driven through props,
	// because it's difficult to update an editor
	// without resetting scroll otherwise
	async function set(new_code, new_mode) {
		if (new_mode !== mode) {
			await createEditor(mode = new_mode);
		}

		$$invalidate('code', code = new_code);
		updating_externally = true;
		if (editor) editor.setValue(code);
		updating_externally = false;
	}

	function update(new_code) {
		$$invalidate('code', code = new_code);

		if (editor) {
			const { left, top } = editor.getScrollInfo();
			editor.setValue($$invalidate('code', code = new_code));
			editor.scrollTo(left, top);
		}
	}

	function resize() {
		editor.refresh();
	}

	function focus() {
		editor.focus();
	}

	const modes = {
		js: {
			name: 'javascript',
			json: false
		},
		json: {
			name: 'javascript',
			json: true
		},
		svelte: {
			name: 'handlebars',
			base: 'text/html'
		}
	};

	const refs = {};
	let editor;
	let updating_externally = false;
	let marker;
	let error_line;
	let destroyed = false;
	let CodeMirror;

	let previous_error_line;

	onMount(() => {
		if (_CodeMirror) {
			$$invalidate('CodeMirror', CodeMirror = _CodeMirror);
			createEditor(mode || 'svelte').then(() => {
				if (editor) editor.setValue(code || '');
			});
		} else {
			codemirror_promise.then(async mod => {
				$$invalidate('CodeMirror', CodeMirror = mod.default);
				await createEditor(mode || 'svelte');
				if (editor) editor.setValue(code || '');
			});
		}

		return () => {
			destroyed = true;
			if (editor) editor.toTextArea();
		}
	});

	let first = true;

	async function createEditor(mode) {
		if (destroyed || !CodeMirror) return;

		if (editor) editor.toTextArea();

		const opts = {
			lineNumbers,
			lineWrapping: true,
			indentWithTabs: true,
			indentUnit: 2,
			tabSize: 2,
			value: '',
			mode: modes[mode] || {
				name: mode
			},
			readOnly: readonly,
			autoCloseBrackets: true,
			autoCloseTags: true
		};

		if (!tab) opts.extraKeys = {
			Tab: tab,
			'Shift-Tab': tab
		};

		// Creating a text editor is a lot of work, so we yield
		// the main thread for a moment. This helps reduce jank
		if (first) await sleep(50);

		if (destroyed) return;

		$$invalidate('editor', editor = CodeMirror.fromTextArea(refs.editor, opts));

		editor.on('change', instance => {
			if (!updating_externally) {
				const value = instance.getValue();
				dispatch('change', { value });
			}
		});

		if (first) await sleep(50);
		editor.refresh();

		first = false;
	}

	const writable_props = ['readonly', 'errorLoc', 'flex', 'lineNumbers', 'tab'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<CodeMirror> was created with unknown prop '${key}'`);
	});

	function textarea_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refs.editor = $$value;
			$$invalidate('refs', refs);
		});
	}

	function div_resize_handler() {
		w = this.offsetWidth;
		h = this.offsetHeight;
		$$invalidate('w', w);
		$$invalidate('h', h);
	}

	$$self.$set = $$props => {
		if ('readonly' in $$props) $$invalidate('readonly', readonly = $$props.readonly);
		if ('errorLoc' in $$props) $$invalidate('errorLoc', errorLoc = $$props.errorLoc);
		if ('flex' in $$props) $$invalidate('flex', flex = $$props.flex);
		if ('lineNumbers' in $$props) $$invalidate('lineNumbers', lineNumbers = $$props.lineNumbers);
		if ('tab' in $$props) $$invalidate('tab', tab = $$props.tab);
	};

	$$self.$capture_state = () => {
		return { codemirror_promise, _CodeMirror, readonly, errorLoc, flex, lineNumbers, tab, w, h, code, mode, editor, updating_externally, marker, error_line, destroyed, CodeMirror, previous_error_line, first };
	};

	$$self.$inject_state = $$props => {
		if ('readonly' in $$props) $$invalidate('readonly', readonly = $$props.readonly);
		if ('errorLoc' in $$props) $$invalidate('errorLoc', errorLoc = $$props.errorLoc);
		if ('flex' in $$props) $$invalidate('flex', flex = $$props.flex);
		if ('lineNumbers' in $$props) $$invalidate('lineNumbers', lineNumbers = $$props.lineNumbers);
		if ('tab' in $$props) $$invalidate('tab', tab = $$props.tab);
		if ('w' in $$props) $$invalidate('w', w = $$props.w);
		if ('h' in $$props) $$invalidate('h', h = $$props.h);
		if ('code' in $$props) $$invalidate('code', code = $$props.code);
		if ('mode' in $$props) mode = $$props.mode;
		if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
		if ('updating_externally' in $$props) updating_externally = $$props.updating_externally;
		if ('marker' in $$props) $$invalidate('marker', marker = $$props.marker);
		if ('error_line' in $$props) $$invalidate('error_line', error_line = $$props.error_line);
		if ('destroyed' in $$props) destroyed = $$props.destroyed;
		if ('CodeMirror' in $$props) $$invalidate('CodeMirror', CodeMirror = $$props.CodeMirror);
		if ('previous_error_line' in $$props) $$invalidate('previous_error_line', previous_error_line = $$props.previous_error_line);
		if ('first' in $$props) first = $$props.first;
	};

	$$self.$$.update = ($$dirty = { editor: 1, w: 1, h: 1, marker: 1, errorLoc: 1, previous_error_line: 1, error_line: 1 }) => {
		if ($$dirty.editor || $$dirty.w || $$dirty.h) { if (editor && w && h) {
				editor.refresh();
			} }
		if ($$dirty.marker || $$dirty.errorLoc || $$dirty.editor) { {
				if (marker) marker.clear();
		
				if (errorLoc) {
					const line = errorLoc.line - 1;
					const ch = errorLoc.column;
		
					$$invalidate('marker', marker = editor.markText({ line, ch }, { line, ch: ch + 1 }, {
						className: 'error-loc'
					}));
		
					$$invalidate('error_line', error_line = line);
				} else {
					$$invalidate('error_line', error_line = null);
				}
			} }
		if ($$dirty.editor || $$dirty.previous_error_line || $$dirty.error_line) { if (editor) {
				if (previous_error_line != null) {
					editor.removeLineClass(previous_error_line, 'wrap', 'error-line');
				}
		
				if (error_line && (error_line !== previous_error_line)) {
					editor.addLineClass(error_line, 'wrap', 'error-line');
					$$invalidate('previous_error_line', previous_error_line = error_line);
				}
			} }
	};

	return {
		readonly,
		errorLoc,
		flex,
		lineNumbers,
		tab,
		w,
		h,
		code,
		set,
		update,
		resize,
		focus,
		refs,
		CodeMirror,
		textarea_binding,
		div_resize_handler
	};
}

class CodeMirror_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, ["readonly", "errorLoc", "flex", "lineNumbers", "tab", "set", "update", "resize", "focus"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "CodeMirror_1", options, id: create_fragment$3.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.set === undefined && !('set' in props)) {
			console.warn("<CodeMirror> was created without expected prop 'set'");
		}
		if (ctx.update === undefined && !('update' in props)) {
			console.warn("<CodeMirror> was created without expected prop 'update'");
		}
		if (ctx.resize === undefined && !('resize' in props)) {
			console.warn("<CodeMirror> was created without expected prop 'resize'");
		}
		if (ctx.focus === undefined && !('focus' in props)) {
			console.warn("<CodeMirror> was created without expected prop 'focus'");
		}
	}

	get readonly() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorLoc() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorLoc(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flex() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flex(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lineNumbers() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lineNumbers(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tab() {
		throw new Error("<CodeMirror>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get set() {
		return this.$$.ctx.set;
	}

	set set(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get update() {
		return this.$$.ctx.update;
	}

	set update(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resize() {
		return this.$$.ctx.resize;
	}

	set resize(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		return this.$$.ctx.focus;
	}

	set focus(value) {
		throw new Error("<CodeMirror>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Input\ModuleEditor.svelte generated by Svelte v3.12.0 */

const file$4 = "node_modules\\@sveltejs\\svelte-repl\\src\\Input\\ModuleEditor.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.warning = list[i];
	return child_ctx;
}

// (57:2) {#if $bundle}
function create_if_block$4(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block_1$2,
		create_if_block_2$1
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.$bundle.error) return 0;
		if (ctx.$bundle.warnings.length > 0) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(null, ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				if (if_block) {
					group_outros();
					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});
					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$4.name, type: "if", source: "(57:2) {#if $bundle}", ctx });
	return block;
}

// (60:41) 
function create_if_block_2$1(ctx) {
	var each_1_anchor, current;

	let each_value = ctx.$bundle.warnings;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},

		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},

		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.$bundle || changed.$selected) {
				each_value = ctx.$bundle.warnings;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();
				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach_dev(each_1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2$1.name, type: "if", source: "(60:41) ", ctx });
	return block;
}

// (58:3) {#if $bundle.error}
function create_if_block_1$2(ctx) {
	var current;

	var message = new Message({
		props: {
		kind: "error",
		details: ctx.$bundle.error,
		filename: "" + ctx.$selected.name + "." + ctx.$selected.type
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			message.$$.fragment.c();
		},

		l: function claim(nodes) {
			message.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(message, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var message_changes = {};
			if (changed.$bundle) message_changes.details = ctx.$bundle.error;
			if (changed.$selected) message_changes.filename = "" + ctx.$selected.name + "." + ctx.$selected.type;
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(message, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$2.name, type: "if", source: "(58:3) {#if $bundle.error}", ctx });
	return block;
}

// (61:4) {#each $bundle.warnings as warning}
function create_each_block$1(ctx) {
	var current;

	var message = new Message({
		props: {
		kind: "warning",
		details: ctx.warning,
		filename: "" + ctx.$selected.name + "." + ctx.$selected.type
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			message.$$.fragment.c();
		},

		l: function claim(nodes) {
			message.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(message, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var message_changes = {};
			if (changed.$bundle) message_changes.details = ctx.warning;
			if (changed.$selected) message_changes.filename = "" + ctx.$selected.name + "." + ctx.$selected.type;
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(message, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$1.name, type: "each", source: "(61:4) {#each $bundle.warnings as warning}", ctx });
	return block;
}

function create_fragment$4(ctx) {
	var div2, div0, t, div1, current;

	let codemirror_props = { errorLoc: ctx.errorLoc };
	var codemirror = new CodeMirror_1({ props: codemirror_props, $$inline: true });

	ctx.codemirror_binding(codemirror);
	codemirror.$on("change", ctx.handle_change);

	var if_block = (ctx.$bundle) && create_if_block$4(ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			codemirror.$$.fragment.c();
			t = space();
			div1 = element("div");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div0 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			codemirror.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div2_nodes);

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "editor svelte-m7nlxn");
			add_location(div0, file$4, 47, 1, 831);
			attr_dev(div1, "class", "info svelte-m7nlxn");
			add_location(div1, file$4, 55, 1, 946);
			attr_dev(div2, "class", "editor-wrapper svelte-m7nlxn");
			add_location(div2, file$4, 46, 0, 801);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			mount_component(codemirror, div0, null);
			append_dev(div2, t);
			append_dev(div2, div1);
			if (if_block) if_block.m(div1, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var codemirror_changes = {};
			if (changed.errorLoc) codemirror_changes.errorLoc = ctx.errorLoc;
			codemirror.$set(codemirror_changes);

			if (ctx.$bundle) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(codemirror.$$.fragment, local);

			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(codemirror.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div2);
			}

			ctx.codemirror_binding(null);

			destroy_component(codemirror);

			if (if_block) if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$4.name, type: "component", source: "", ctx });
	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let $bundle, $selected;

	

	const { bundle, selected, handle_change, register_module_editor } = getContext('REPL'); validate_store(bundle, 'bundle'); component_subscribe($$self, bundle, $$value => { $bundle = $$value; $$invalidate('$bundle', $bundle); }); validate_store(selected, 'selected'); component_subscribe($$self, selected, $$value => { $selected = $$value; $$invalidate('$selected', $selected); });

	let { errorLoc } = $$props;

	let editor;
	onMount(() => {
		register_module_editor(editor);
	});

	function focus() {
		editor.focus();
	}

	const writable_props = ['errorLoc'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ModuleEditor> was created with unknown prop '${key}'`);
	});

	function codemirror_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('editor', editor = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('errorLoc' in $$props) $$invalidate('errorLoc', errorLoc = $$props.errorLoc);
	};

	$$self.$capture_state = () => {
		return { errorLoc, editor, $bundle, $selected };
	};

	$$self.$inject_state = $$props => {
		if ('errorLoc' in $$props) $$invalidate('errorLoc', errorLoc = $$props.errorLoc);
		if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
		if ('$bundle' in $$props) bundle.set($bundle);
		if ('$selected' in $$props) selected.set($selected);
	};

	return {
		bundle,
		selected,
		handle_change,
		errorLoc,
		editor,
		focus,
		$bundle,
		$selected,
		codemirror_binding
	};
}

class ModuleEditor extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, ["errorLoc", "focus"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "ModuleEditor", options, id: create_fragment$4.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.errorLoc === undefined && !('errorLoc' in props)) {
			console.warn("<ModuleEditor> was created without expected prop 'errorLoc'");
		}
		if (ctx.focus === undefined && !('focus' in props)) {
			console.warn("<ModuleEditor> was created without expected prop 'focus'");
		}
	}

	get errorLoc() {
		throw new Error("<ModuleEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorLoc(value) {
		throw new Error("<ModuleEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		return this.$$.ctx.focus;
	}

	set focus(value) {
		throw new Error("<ModuleEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var charToInteger = {};
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
for (var i = 0; i < chars.length; i++) {
    charToInteger[chars.charCodeAt(i)] = i;
}
function decode(mappings) {
    var generatedCodeColumn = 0; // first field
    var sourceFileIndex = 0; // second field
    var sourceCodeLine = 0; // third field
    var sourceCodeColumn = 0; // fourth field
    var nameIndex = 0; // fifth field
    var decoded = [];
    var line = [];
    var segment = [];
    for (var i = 0, j = 0, shift = 0, value = 0, len = mappings.length; i < len; i++) {
        var c = mappings.charCodeAt(i);
        if (c === 44) { // ","
            if (segment.length)
                line.push(segment);
            segment = [];
            j = 0;
        }
        else if (c === 59) { // ";"
            if (segment.length)
                line.push(segment);
            segment = [];
            j = 0;
            decoded.push(line);
            line = [];
            generatedCodeColumn = 0;
        }
        else {
            var integer = charToInteger[c];
            if (integer === undefined) {
                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');
            }
            var hasContinuationBit = integer & 32;
            integer &= 31;
            value += integer << shift;
            if (hasContinuationBit) {
                shift += 5;
            }
            else {
                var shouldNegate = value & 1;
                value >>>= 1;
                if (shouldNegate) {
                    value = -value;
                    if (value === 0)
                        value = -0x80000000;
                }
                if (j == 0) {
                    generatedCodeColumn += value;
                    segment.push(generatedCodeColumn);
                }
                else if (j === 1) {
                    sourceFileIndex += value;
                    segment.push(sourceFileIndex);
                }
                else if (j === 2) {
                    sourceCodeLine += value;
                    segment.push(sourceCodeLine);
                }
                else if (j === 3) {
                    sourceCodeColumn += value;
                    segment.push(sourceCodeColumn);
                }
                else if (j === 4) {
                    nameIndex += value;
                    segment.push(nameIndex);
                }
                j++;
                value = shift = 0; // reset
            }
        }
    }
    if (segment.length)
        line.push(segment);
    decoded.push(line);
    return decoded;
}

function getLocationFromStack(stack, map) {
	if (!stack) return;
	const last = stack.split('\n')[1];
	const match = /<anonymous>:(\d+):(\d+)\)$/.exec(last);

	if (!match) return null;

	const line = +match[1];
	const column = +match[2];

	return trace({ line, column }, map);
}

function trace(loc, map) {
	const mappings = decode(map.mappings);
	const segments = mappings[loc.line - 1];

	for (let i = 0; i < segments.length; i += 1) {
		const segment = segments[i];
		if (segment[0] === loc.column) {
			const [, sourceIndex, line, column] = segment;
			const source = map.sources[sourceIndex].slice(2);

			return { source, line: line + 1, column };
		}
	}

	return null;
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function tick_spring(ctx, last_value, current_value, target_value) {
    if (typeof current_value === 'number' || is_date(current_value)) {
        // @ts-ignore
        const delta = target_value - current_value;
        // @ts-ignore
        const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0
        const spring = ctx.opts.stiffness * delta;
        const damper = ctx.opts.damping * velocity;
        const acceleration = (spring - damper) * ctx.inv_mass;
        const d = (velocity + acceleration) * ctx.dt;
        if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {
            return target_value; // settled
        }
        else {
            ctx.settled = false; // signal loop to keep ticking
            // @ts-ignore
            return is_date(current_value) ?
                new Date(current_value.getTime() + d) : current_value + d;
        }
    }
    else if (Array.isArray(current_value)) {
        // @ts-ignore
        return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));
    }
    else if (typeof current_value === 'object') {
        const next_value = {};
        for (const k in current_value)
            // @ts-ignore
            next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);
        // @ts-ignore
        return next_value;
    }
    else {
        throw new Error(`Cannot spring ${typeof current_value} values`);
    }
}
function spring(value, opts = {}) {
    const store = writable(value);
    const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;
    let last_time;
    let task;
    let current_token;
    let last_value = value;
    let target_value = value;
    let inv_mass = 1;
    let inv_mass_recovery_rate = 0;
    let cancel_task = false;
    /* eslint-disable @typescript-eslint/no-use-before-define */
    function set(new_value, opts = {}) {
        target_value = new_value;
        const token = current_token = {};
        if (opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {
            cancel_task = true; // cancel any running animation
            last_time = now();
            last_value = value;
            store.set(value = target_value);
            return new Promise(f => f()); // fulfil immediately
        }
        else if (opts.soft) {
            const rate = opts.soft === true ? .5 : +opts.soft;
            inv_mass_recovery_rate = 1 / (rate * 60);
            inv_mass = 0; // infinite mass, unaffected by spring forces
        }
        if (!task) {
            last_time = now();
            cancel_task = false;
            task = loop(now => {
                if (cancel_task) {
                    cancel_task = false;
                    task = null;
                    return false;
                }
                inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);
                const ctx = {
                    inv_mass,
                    opts: spring,
                    settled: true,
                    dt: (now - last_time) * 60 / 1000
                };
                const next_value = tick_spring(ctx, last_value, value, target_value);
                last_time = now;
                last_value = value;
                store.set(value = next_value);
                if (ctx.settled)
                    task = null;
                return !ctx.settled;
            });
        }
        return new Promise(fulfil => {
            task.promise.then(() => {
                if (token === current_token)
                    fulfil();
            });
        });
    }
    /* eslint-enable @typescript-eslint/no-use-before-define */
    const spring = {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe,
        stiffness,
        damping,
        precision
    };
    return spring;
}

/* node_modules\@sveltejs\svelte-repl\src\Output\PaneWithPanel.svelte generated by Svelte v3.12.0 */

const file$5 = "node_modules\\@sveltejs\\svelte-repl\\src\\Output\\PaneWithPanel.svelte";

const get_panel_body_slot_changes = () => ({});
const get_panel_body_slot_context = () => ({});

const get_panel_header_slot_changes = () => ({});
const get_panel_header_slot_context = () => ({});

const get_main_slot_changes = () => ({});
const get_main_slot_context = () => ({});

// (29:1) <section slot="a">
function create_a_slot(ctx) {
	var section, current;

	const main_slot_template = ctx.$$slots.main;
	const main_slot = create_slot(main_slot_template, ctx, get_main_slot_context);

	const block = {
		c: function create() {
			section = element("section");

			if (main_slot) main_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true }, false);
			var section_nodes = children(section);

			if (main_slot) main_slot.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(section, "slot", "a");
			add_location(section, file$5, 28, 1, 562);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);

			if (main_slot) {
				main_slot.m(section, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (main_slot && main_slot.p && changed.$$scope) {
				main_slot.p(
					get_slot_changes(main_slot_template, ctx, changed, get_main_slot_changes),
					get_slot_context(main_slot_template, ctx, get_main_slot_context)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(main_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(main_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			if (main_slot) main_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_a_slot.name, type: "slot", source: "(29:1) <section slot=\"a\">", ctx });
	return block;
}

// (33:1) <section slot="b">
function create_b_slot(ctx) {
	var section, div0, h3, t0, t1, t2, div1, current, dispose;

	const panel_header_slot_template = ctx.$$slots["panel-header"];
	const panel_header_slot = create_slot(panel_header_slot_template, ctx, get_panel_header_slot_context);

	const panel_body_slot_template = ctx.$$slots["panel-body"];
	const panel_body_slot = create_slot(panel_body_slot_template, ctx, get_panel_body_slot_context);

	const block = {
		c: function create() {
			section = element("section");
			div0 = element("div");
			h3 = element("h3");
			t0 = text(ctx.panel);
			t1 = space();

			if (panel_header_slot) panel_header_slot.c();
			t2 = space();
			div1 = element("div");

			if (panel_body_slot) panel_body_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true }, false);
			var section_nodes = children(section);

			div0 = claim_element(section_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			h3 = claim_element(div0_nodes, "H3", { class: true }, false);
			var h3_nodes = children(h3);

			t0 = claim_text(h3_nodes, ctx.panel);
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);

			if (panel_header_slot) panel_header_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);

			div1 = claim_element(section_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (panel_body_slot) panel_body_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(h3, "class", "svelte-5jyt6a");
			add_location(h3, file$5, 34, 3, 692);

			attr_dev(div0, "class", "panel-header svelte-5jyt6a");
			add_location(div0, file$5, 33, 2, 644);

			attr_dev(div1, "class", "panel-body svelte-5jyt6a");
			add_location(div1, file$5, 38, 2, 758);
			attr_dev(section, "slot", "b");
			add_location(section, file$5, 32, 1, 623);
			dispose = listen_dev(div0, "click", ctx.toggle);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			append_dev(div0, h3);
			append_dev(h3, t0);
			append_dev(div0, t1);

			if (panel_header_slot) {
				panel_header_slot.m(div0, null);
			}

			append_dev(section, t2);
			append_dev(section, div1);

			if (panel_body_slot) {
				panel_body_slot.m(div1, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (!current || changed.panel) {
				set_data_dev(t0, ctx.panel);
			}

			if (panel_header_slot && panel_header_slot.p && changed.$$scope) {
				panel_header_slot.p(
					get_slot_changes(panel_header_slot_template, ctx, changed, get_panel_header_slot_changes),
					get_slot_context(panel_header_slot_template, ctx, get_panel_header_slot_context)
				);
			}

			if (panel_body_slot && panel_body_slot.p && changed.$$scope) {
				panel_body_slot.p(
					get_slot_changes(panel_body_slot_template, ctx, changed, get_panel_body_slot_changes),
					get_slot_context(panel_body_slot_template, ctx, get_panel_body_slot_context)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(panel_header_slot, local);
			transition_in(panel_body_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(panel_header_slot, local);
			transition_out(panel_body_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			if (panel_header_slot) panel_header_slot.d(detaching);

			if (panel_body_slot) panel_body_slot.d(detaching);
			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_b_slot.name, type: "slot", source: "(33:1) <section slot=\"b\">", ctx });
	return block;
}

// (28:0) <SplitPane bind:max type="vertical" bind:pos={pos}>
function create_default_slot$1(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$1.name, type: "slot", source: "(28:0) <SplitPane bind:max type=\"vertical\" bind:pos={pos}>", ctx });
	return block;
}

function create_fragment$5(ctx) {
	var updating_max, updating_pos, current;

	function splitpane_max_binding(value) {
		ctx.splitpane_max_binding.call(null, value);
		updating_max = true;
		add_flush_callback(() => updating_max = false);
	}

	function splitpane_pos_binding(value_1) {
		ctx.splitpane_pos_binding.call(null, value_1);
		updating_pos = true;
		add_flush_callback(() => updating_pos = false);
	}

	let splitpane_props = {
		type: "vertical",
		$$slots: {
		default: [create_default_slot$1],
		b: [create_b_slot],
		a: [create_a_slot]
	},
		$$scope: { ctx }
	};
	if (ctx.max !== void 0) {
		splitpane_props.max = ctx.max;
	}
	if (ctx.pos !== void 0) {
		splitpane_props.pos = ctx.pos;
	}
	var splitpane = new SplitPane({ props: splitpane_props, $$inline: true });

	binding_callbacks.push(() => bind(splitpane, 'max', splitpane_max_binding));
	binding_callbacks.push(() => bind(splitpane, 'pos', splitpane_pos_binding));

	const block = {
		c: function create() {
			splitpane.$$.fragment.c();
		},

		l: function claim(nodes) {
			splitpane.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(splitpane, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var splitpane_changes = {};
			if (changed.$$scope || changed.panel) splitpane_changes.$$scope = { changed, ctx };
			if (!updating_max && changed.max) {
				splitpane_changes.max = ctx.max;
			}
			if (!updating_pos && changed.pos) {
				splitpane_changes.pos = ctx.pos;
			}
			splitpane.$set(splitpane_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(splitpane.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(splitpane.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(splitpane, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$5.name, type: "component", source: "", ctx });
	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let $driver;

	

	let { panel, pos = 50 } = $$props;
	let previous_pos = Math.min(pos, 70);

	let max;

	// we can't bind to the spring itself, but we
	// can still use the spring to drive `pos`
	const driver = spring(pos); validate_store(driver, 'driver'); component_subscribe($$self, driver, $$value => { $driver = $$value; $$invalidate('$driver', $driver); });

	const toggle = () => {
		driver.set(pos, { hard: true });

		if (pos > 80) {
			driver.set(previous_pos);
		} else {
			previous_pos = pos;
			driver.set(max);
		}
	};

	const writable_props = ['panel', 'pos'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<PaneWithPanel> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function splitpane_max_binding(value) {
		max = value;
		$$invalidate('max', max);
	}

	function splitpane_pos_binding(value_1) {
		pos = value_1;
		$$invalidate('pos', pos), $$invalidate('$driver', $driver);
	}

	$$self.$set = $$props => {
		if ('panel' in $$props) $$invalidate('panel', panel = $$props.panel);
		if ('pos' in $$props) $$invalidate('pos', pos = $$props.pos);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { panel, pos, previous_pos, max, $driver };
	};

	$$self.$inject_state = $$props => {
		if ('panel' in $$props) $$invalidate('panel', panel = $$props.panel);
		if ('pos' in $$props) $$invalidate('pos', pos = $$props.pos);
		if ('previous_pos' in $$props) previous_pos = $$props.previous_pos;
		if ('max' in $$props) $$invalidate('max', max = $$props.max);
		if ('$driver' in $$props) driver.set($driver);
	};

	$$self.$$.update = ($$dirty = { $driver: 1 }) => {
		if ($$dirty.$driver) { $$invalidate('pos', pos = $driver); }
	};

	return {
		panel,
		pos,
		max,
		driver,
		toggle,
		splitpane_max_binding,
		splitpane_pos_binding,
		$$slots,
		$$scope
	};
}

class PaneWithPanel extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, ["panel", "pos"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "PaneWithPanel", options, id: create_fragment$5.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.panel === undefined && !('panel' in props)) {
			console.warn("<PaneWithPanel> was created without expected prop 'panel'");
		}
	}

	get panel() {
		throw new Error("<PaneWithPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set panel(value) {
		throw new Error("<PaneWithPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pos() {
		throw new Error("<PaneWithPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pos(value) {
		throw new Error("<PaneWithPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

let uid = 1;

class ReplProxy {
	constructor(iframe, handlers) {
		this.iframe = iframe;
		this.handlers = handlers;

		this.pending_cmds = new Map();

		this.handle_event = e => this.handle_repl_message(e);
		window.addEventListener('message', this.handle_event, false);
	}

	destroy() {
		window.removeEventListener('message', this.handle_event);
	}

	iframe_command(action, args) {
		return new Promise((resolve, reject) => {
			const cmd_id = uid++;

			this.pending_cmds.set(cmd_id, { resolve, reject });

			this.iframe.contentWindow.postMessage({ action, cmd_id, args }, '*');
		});
	}

	handle_command_message(cmd_data) {
		let action = cmd_data.action;
		let id = cmd_data.cmd_id;
		let handler = this.pending_cmds.get(id);

		if (handler) {
			this.pending_cmds.delete(id);
			if (action === 'cmd_error') {
				let { message, stack } = cmd_data;
				let e = new Error(message);
				e.stack = stack;
				handler.reject(e);
			}

			if (action === 'cmd_ok') {
				handler.resolve(cmd_data.args);
			}
		} else {
			console.error('command not found', id, cmd_data, [...this.pending_cmds.keys()]);
		}
	}

	handle_repl_message(event) {
		if (event.source !== this.iframe.contentWindow) return;

		const { action, args } = event.data;

		switch (action) {
			case 'cmd_error':
			case 'cmd_ok':
				return this.handle_command_message(event.data);
			case 'fetch_progress':
				return this.handlers.on_fetch_progress(args.remaining)
			case 'error':
				return this.handlers.on_error(event.data);
			case 'unhandledrejection':
				return this.handlers.on_unhandled_rejection(event.data);
			case 'console':
				return this.handlers.on_console(event.data);
		}
	}

	eval(script) {
		return this.iframe_command('eval', { script });
	}

	handle_links() {
		return this.iframe_command('catch_clicks', {});
	}
}

/* node_modules\svelte-json-tree\src\JSONArrow.svelte generated by Svelte v3.12.0 */

const file$6 = "node_modules\\svelte-json-tree\\src\\JSONArrow.svelte";

function create_fragment$6(ctx) {
	var div1, div0, t_value = '\u25B6' + "", t, dispose;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			t = claim_text(div0_nodes, t_value);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "arrow svelte-kniv4z");
			toggle_class(div0, "expanded", ctx.expanded);
			add_location(div0, file$6, 33, 2, 692);
			attr_dev(div1, "class", "container svelte-kniv4z");
			add_location(div1, file$6, 32, 0, 647);
			dispose = listen_dev(div1, "click", ctx.onClick);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t);
		},

		p: function update(changed, ctx) {
			if (changed.expanded) {
				toggle_class(div0, "expanded", ctx.expanded);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$6.name, type: "component", source: "", ctx });
	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();

  function onClick(event) {
    dispatch('click', event);
  }

  let { expanded } = $$props;

	const writable_props = ['expanded'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONArrow> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
	};

	$$self.$capture_state = () => {
		return { expanded };
	};

	$$self.$inject_state = $$props => {
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
	};

	return { onClick, expanded };
}

class JSONArrow extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, ["expanded"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONArrow", options, id: create_fragment$6.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.expanded === undefined && !('expanded' in props)) {
			console.warn("<JSONArrow> was created without expected prop 'expanded'");
		}
	}

	get expanded() {
		throw new Error("<JSONArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<JSONArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function objType(obj) {
  const type = Object.prototype.toString.call(obj).slice(8, -1);
  if (type === 'Object') {
    if (typeof obj[Symbol.iterator] === 'function') {
      return 'Iterable';
    }
    return obj.constructor.name;
  }

  return type;
}

/* node_modules\svelte-json-tree\src\JSONKey.svelte generated by Svelte v3.12.0 */

const file$7 = "node_modules\\svelte-json-tree\\src\\JSONKey.svelte";

// (19:0) {#if showKey && key}
function create_if_block$5(ctx) {
	var label, span, t0, t1;

	const block = {
		c: function create() {
			label = element("label");
			span = element("span");
			t0 = text(ctx.key);
			t1 = text(ctx.colon);
			this.h();
		},

		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { class: true }, false);
			var label_nodes = children(label);

			span = claim_element(label_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t0 = claim_text(span_nodes, ctx.key);
			t1 = claim_text(span_nodes, ctx.colon);
			span_nodes.forEach(detach_dev);
			label_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			add_location(span, file$7, 20, 4, 476);
			attr_dev(label, "class", "svelte-15h461i");
			toggle_class(label, "spaced", ctx.isParentExpanded);
			add_location(label, file$7, 19, 2, 432);
		},

		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, span);
			append_dev(span, t0);
			append_dev(span, t1);
		},

		p: function update(changed, ctx) {
			if (changed.key) {
				set_data_dev(t0, ctx.key);
			}

			if (changed.colon) {
				set_data_dev(t1, ctx.colon);
			}

			if (changed.isParentExpanded) {
				toggle_class(label, "spaced", ctx.isParentExpanded);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(label);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$5.name, type: "if", source: "(19:0) {#if showKey && key}", ctx });
	return block;
}

function create_fragment$7(ctx) {
	var if_block_anchor;

	var if_block = (ctx.showKey && ctx.key) && create_if_block$5(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (ctx.showKey && ctx.key) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$7.name, type: "component", source: "", ctx });
	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	

  let { key, isParentExpanded, isParentArray = false, colon = ':' } = $$props;

	const writable_props = ['key', 'isParentExpanded', 'isParentArray', 'colon'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONKey> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('colon' in $$props) $$invalidate('colon', colon = $$props.colon);
	};

	$$self.$capture_state = () => {
		return { key, isParentExpanded, isParentArray, colon, showKey };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('colon' in $$props) $$invalidate('colon', colon = $$props.colon);
		if ('showKey' in $$props) $$invalidate('showKey', showKey = $$props.showKey);
	};

	let showKey;

	$$self.$$.update = ($$dirty = { isParentExpanded: 1, isParentArray: 1, key: 1 }) => {
		if ($$dirty.isParentExpanded || $$dirty.isParentArray || $$dirty.key) { $$invalidate('showKey', showKey = (isParentExpanded || !isParentArray || key != +key)); }
	};

	return {
		key,
		isParentExpanded,
		isParentArray,
		colon,
		showKey
	};
}

class JSONKey extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, ["key", "isParentExpanded", "isParentArray", "colon"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONKey", options, id: create_fragment$7.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<JSONKey> was created without expected prop 'key'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<JSONKey> was created without expected prop 'isParentExpanded'");
		}
	}

	get key() {
		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get colon() {
		throw new Error("<JSONKey>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set colon(value) {
		throw new Error("<JSONKey>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var contextKey = {};

/* node_modules\svelte-json-tree\src\JSONNested.svelte generated by Svelte v3.12.0 */

const file$8 = "node_modules\\svelte-json-tree\\src\\JSONNested.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.key = list[i];
	child_ctx.index = i;
	return child_ctx;
}

// (48:2) {#if expandable && isParentExpanded}
function create_if_block_3(ctx) {
	var current;

	var jsonarrow = new JSONArrow({
		props: { expanded: ctx.expanded },
		$$inline: true
	});
	jsonarrow.$on("click", ctx.toggleExpand);

	const block = {
		c: function create() {
			jsonarrow.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonarrow.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonarrow, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonarrow_changes = {};
			if (changed.expanded) jsonarrow_changes.expanded = ctx.expanded;
			jsonarrow.$set(jsonarrow_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonarrow.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonarrow.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonarrow, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_3.name, type: "if", source: "(48:2) {#if expandable && isParentExpanded}", ctx });
	return block;
}

// (65:4) {:else}
function create_else_block$2(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			add_location(span, file$8, 65, 6, 1920);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$2.name, type: "else", source: "(65:4) {:else}", ctx });
	return block;
}

// (53:4) {#if isParentExpanded}
function create_if_block$6(ctx) {
	var ul, t, current, dispose;

	let each_value = ctx.slicedKeys;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	var if_block = (ctx.slicedKeys.length < ctx.previewKeys.length) && create_if_block_1$3(ctx);

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			t = claim_space(ul_nodes);
			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(ul, "class", "svelte-2jkrkt");
			toggle_class(ul, "collapse", !ctx.expanded);
			add_location(ul, file$8, 53, 6, 1424);
			dispose = listen_dev(ul, "click", ctx.expand);
		},

		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append_dev(ul, t);
			if (if_block) if_block.m(ul, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.expanded || changed.previewKeys || changed.getKey || changed.slicedKeys || changed.isArray || changed.getValue || changed.getPreviewValue) {
				each_value = ctx.slicedKeys;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, t);
					}
				}

				group_outros();
				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}

			if (ctx.slicedKeys.length < ctx.previewKeys.length) {
				if (!if_block) {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (changed.expanded) {
				toggle_class(ul, "collapse", !ctx.expanded);
			}
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(ul);
			}

			destroy_each(each_blocks, detaching);

			if (if_block) if_block.d();
			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$6.name, type: "if", source: "(53:4) {#if isParentExpanded}", ctx });
	return block;
}

// (57:10) {#if !expanded && index < previewKeys.length - 1}
function create_if_block_2$2(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(",");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, ",");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "comma svelte-2jkrkt");
			add_location(span, file$8, 57, 12, 1736);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2$2.name, type: "if", source: "(57:10) {#if !expanded && index < previewKeys.length - 1}", ctx });
	return block;
}

// (55:8) {#each slicedKeys as key, index}
function create_each_block$2(ctx) {
	var t, if_block_anchor, current;

	var jsonnode = new JSONNode({
		props: {
		key: ctx.getKey(ctx.key),
		isParentExpanded: ctx.expanded,
		isParentArray: ctx.isArray,
		value: ctx.expanded ? ctx.getValue(ctx.key) : ctx.getPreviewValue(ctx.key)
	},
		$$inline: true
	});

	var if_block = (!ctx.expanded && ctx.index < ctx.previewKeys.length - 1) && create_if_block_2$2(ctx);

	const block = {
		c: function create() {
			jsonnode.$$.fragment.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			jsonnode.$$.fragment.l(nodes);
			t = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonnode_changes = {};
			if (changed.getKey || changed.slicedKeys) jsonnode_changes.key = ctx.getKey(ctx.key);
			if (changed.expanded) jsonnode_changes.isParentExpanded = ctx.expanded;
			if (changed.isArray) jsonnode_changes.isParentArray = ctx.isArray;
			if (changed.expanded || changed.getValue || changed.slicedKeys || changed.getPreviewValue) jsonnode_changes.value = ctx.expanded ? ctx.getValue(ctx.key) : ctx.getPreviewValue(ctx.key);
			jsonnode.$set(jsonnode_changes);

			if (!ctx.expanded && ctx.index < ctx.previewKeys.length - 1) {
				if (!if_block) {
					if_block = create_if_block_2$2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);

			if (detaching) {
				detach_dev(t);
			}

			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$2.name, type: "each", source: "(55:8) {#each slicedKeys as key, index}", ctx });
	return block;
}

// (61:8) {#if slicedKeys.length < previewKeys.length }
function create_if_block_1$3(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			add_location(span, file$8, 61, 10, 1861);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$3.name, type: "if", source: "(61:8) {#if slicedKeys.length < previewKeys.length }", ctx });
	return block;
}

function create_fragment$8(ctx) {
	var li, t0, t1, span1, span0, t2, t3, t4, current_block_type_index, if_block1, t5, span2, t6, current, dispose;

	var if_block0 = (ctx.expandable && ctx.isParentExpanded) && create_if_block_3(ctx);

	var jsonkey = new JSONKey({
		props: {
		key: ctx.key,
		colon: ctx.context.colon,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray
	},
		$$inline: true
	});

	var if_block_creators = [
		create_if_block$6,
		create_else_block$2
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.isParentExpanded) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			li = element("li");
			if (if_block0) if_block0.c();
			t0 = space();
			jsonkey.$$.fragment.c();
			t1 = space();
			span1 = element("span");
			span0 = element("span");
			t2 = text(ctx.label);
			t3 = text(ctx.bracketOpen);
			t4 = space();
			if_block1.c();
			t5 = space();
			span2 = element("span");
			t6 = text(ctx.bracketClose);
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			if (if_block0) if_block0.l(li_nodes);
			t0 = claim_space(li_nodes);
			jsonkey.$$.fragment.l(li_nodes);
			t1 = claim_space(li_nodes);

			span1 = claim_element(li_nodes, "SPAN", {}, false);
			var span1_nodes = children(span1);

			span0 = claim_element(span1_nodes, "SPAN", {}, false);
			var span0_nodes = children(span0);

			t2 = claim_text(span0_nodes, ctx.label);
			span0_nodes.forEach(detach_dev);
			t3 = claim_text(span1_nodes, ctx.bracketOpen);
			span1_nodes.forEach(detach_dev);
			t4 = claim_space(li_nodes);
			if_block1.l(li_nodes);
			t5 = claim_space(li_nodes);

			span2 = claim_element(li_nodes, "SPAN", {}, false);
			var span2_nodes = children(span2);

			t6 = claim_text(span2_nodes, ctx.bracketClose);
			span2_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			add_location(span0, file$8, 51, 8, 1326);
			add_location(span1, file$8, 51, 2, 1320);
			add_location(span2, file$8, 67, 2, 1947);
			attr_dev(li, "class", "svelte-2jkrkt");
			toggle_class(li, "indent", ctx.isParentExpanded);
			add_location(li, file$8, 46, 0, 1104);
			dispose = listen_dev(span0, "click", ctx.toggleExpand);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			if (if_block0) if_block0.m(li, null);
			append_dev(li, t0);
			mount_component(jsonkey, li, null);
			append_dev(li, t1);
			append_dev(li, span1);
			append_dev(span1, span0);
			append_dev(span0, t2);
			append_dev(span1, t3);
			append_dev(li, t4);
			if_blocks[current_block_type_index].m(li, null);
			append_dev(li, t5);
			append_dev(li, span2);
			append_dev(span2, t6);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.expandable && ctx.isParentExpanded) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(li, t0);
				}
			} else if (if_block0) {
				group_outros();
				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});
				check_outros();
			}

			var jsonkey_changes = {};
			if (changed.key) jsonkey_changes.key = ctx.key;
			if (changed.isParentExpanded) jsonkey_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonkey_changes.isParentArray = ctx.isParentArray;
			jsonkey.$set(jsonkey_changes);

			if (!current || changed.label) {
				set_data_dev(t2, ctx.label);
			}

			if (!current || changed.bracketOpen) {
				set_data_dev(t3, ctx.bracketOpen);
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block1 = if_blocks[current_block_type_index];
				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}
				transition_in(if_block1, 1);
				if_block1.m(li, t5);
			}

			if (!current || changed.bracketClose) {
				set_data_dev(t6, ctx.bracketClose);
			}

			if (changed.isParentExpanded) {
				toggle_class(li, "indent", ctx.isParentExpanded);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);

			transition_in(jsonkey.$$.fragment, local);

			transition_in(if_block1);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block0);
			transition_out(jsonkey.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			if (if_block0) if_block0.d();

			destroy_component(jsonkey);

			if_blocks[current_block_type_index].d();
			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$8.name, type: "component", source: "", ctx });
	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	

  let { key, keys, colon = ':', label = '', isParentExpanded, isParentArray, isArray = false, bracketOpen, bracketClose, previewKeys = keys, getKey = key => key } = $$props;
  let { getValue = key => key } = $$props;
  let { getPreviewValue = getValue, expanded = false, expandable = true } = $$props;

  const context = getContext(contextKey);
  setContext(contextKey, { ...context, colon });

  function toggleExpand() {
    $$invalidate('expanded', expanded = !expanded);
  }

  function expand() {
    $$invalidate('expanded', expanded = true);
  }

	const writable_props = ['key', 'keys', 'colon', 'label', 'isParentExpanded', 'isParentArray', 'isArray', 'bracketOpen', 'bracketClose', 'previewKeys', 'getKey', 'getValue', 'getPreviewValue', 'expanded', 'expandable'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONNested> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('keys' in $$props) $$invalidate('keys', keys = $$props.keys);
		if ('colon' in $$props) $$invalidate('colon', colon = $$props.colon);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('isArray' in $$props) $$invalidate('isArray', isArray = $$props.isArray);
		if ('bracketOpen' in $$props) $$invalidate('bracketOpen', bracketOpen = $$props.bracketOpen);
		if ('bracketClose' in $$props) $$invalidate('bracketClose', bracketClose = $$props.bracketClose);
		if ('previewKeys' in $$props) $$invalidate('previewKeys', previewKeys = $$props.previewKeys);
		if ('getKey' in $$props) $$invalidate('getKey', getKey = $$props.getKey);
		if ('getValue' in $$props) $$invalidate('getValue', getValue = $$props.getValue);
		if ('getPreviewValue' in $$props) $$invalidate('getPreviewValue', getPreviewValue = $$props.getPreviewValue);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
		if ('expandable' in $$props) $$invalidate('expandable', expandable = $$props.expandable);
	};

	$$self.$capture_state = () => {
		return { key, keys, colon, label, isParentExpanded, isParentArray, isArray, bracketOpen, bracketClose, previewKeys, getKey, getValue, getPreviewValue, expanded, expandable, slicedKeys };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('keys' in $$props) $$invalidate('keys', keys = $$props.keys);
		if ('colon' in $$props) $$invalidate('colon', colon = $$props.colon);
		if ('label' in $$props) $$invalidate('label', label = $$props.label);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('isArray' in $$props) $$invalidate('isArray', isArray = $$props.isArray);
		if ('bracketOpen' in $$props) $$invalidate('bracketOpen', bracketOpen = $$props.bracketOpen);
		if ('bracketClose' in $$props) $$invalidate('bracketClose', bracketClose = $$props.bracketClose);
		if ('previewKeys' in $$props) $$invalidate('previewKeys', previewKeys = $$props.previewKeys);
		if ('getKey' in $$props) $$invalidate('getKey', getKey = $$props.getKey);
		if ('getValue' in $$props) $$invalidate('getValue', getValue = $$props.getValue);
		if ('getPreviewValue' in $$props) $$invalidate('getPreviewValue', getPreviewValue = $$props.getPreviewValue);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
		if ('expandable' in $$props) $$invalidate('expandable', expandable = $$props.expandable);
		if ('slicedKeys' in $$props) $$invalidate('slicedKeys', slicedKeys = $$props.slicedKeys);
	};

	let slicedKeys;

	$$self.$$.update = ($$dirty = { isParentExpanded: 1, expanded: 1, keys: 1, previewKeys: 1 }) => {
		if ($$dirty.isParentExpanded) { if (!isParentExpanded) {
        $$invalidate('expanded', expanded = false);
      } }
		if ($$dirty.expanded || $$dirty.keys || $$dirty.previewKeys) { $$invalidate('slicedKeys', slicedKeys = expanded ? keys: previewKeys.slice(0, 5)); }
	};

	return {
		key,
		keys,
		colon,
		label,
		isParentExpanded,
		isParentArray,
		isArray,
		bracketOpen,
		bracketClose,
		previewKeys,
		getKey,
		getValue,
		getPreviewValue,
		expanded,
		expandable,
		context,
		toggleExpand,
		expand,
		slicedKeys
	};
}

class JSONNested extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, ["key", "keys", "colon", "label", "isParentExpanded", "isParentArray", "isArray", "bracketOpen", "bracketClose", "previewKeys", "getKey", "getValue", "getPreviewValue", "expanded", "expandable"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONNested", options, id: create_fragment$8.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<JSONNested> was created without expected prop 'key'");
		}
		if (ctx.keys === undefined && !('keys' in props)) {
			console.warn("<JSONNested> was created without expected prop 'keys'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<JSONNested> was created without expected prop 'isParentExpanded'");
		}
		if (ctx.isParentArray === undefined && !('isParentArray' in props)) {
			console.warn("<JSONNested> was created without expected prop 'isParentArray'");
		}
		if (ctx.bracketOpen === undefined && !('bracketOpen' in props)) {
			console.warn("<JSONNested> was created without expected prop 'bracketOpen'");
		}
		if (ctx.bracketClose === undefined && !('bracketClose' in props)) {
			console.warn("<JSONNested> was created without expected prop 'bracketClose'");
		}
	}

	get key() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keys() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keys(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get colon() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set colon(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isArray() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isArray(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bracketOpen() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bracketOpen(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bracketClose() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bracketClose(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get previewKeys() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set previewKeys(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getKey() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getKey(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getValue() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getValue(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getPreviewValue() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set getPreviewValue(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expanded() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expandable() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expandable(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-json-tree\src\JSONObjectNode.svelte generated by Svelte v3.12.0 */
const { Object: Object_1 } = globals;

function create_fragment$9(ctx) {
	var current;

	var jsonnested = new JSONNested({
		props: {
		key: ctx.key,
		expanded: ctx.expanded,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		keys: ctx.keys,
		getValue: ctx.getValue,
		label: "" + ctx.nodeType + " ",
		bracketOpen: '{',
		bracketClose: '}'
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonnested.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonnested.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonnested_changes = {};
			if (changed.key) jsonnested_changes.key = ctx.key;
			if (changed.expanded) jsonnested_changes.expanded = ctx.expanded;
			if (changed.isParentExpanded) jsonnested_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonnested_changes.isParentArray = ctx.isParentArray;
			if (changed.keys) jsonnested_changes.keys = ctx.keys;
			if (changed.nodeType) jsonnested_changes.label = "" + ctx.nodeType + " ";
			jsonnested.$set(jsonnested_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$9.name, type: "component", source: "", ctx });
	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	

  let { key, value, isParentExpanded, isParentArray, nodeType, expanded = false } = $$props;

  function getValue(key) {
    return value[key];
  }

	const writable_props = ['key', 'value', 'isParentExpanded', 'isParentArray', 'nodeType', 'expanded'];
	Object_1.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONObjectNode> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('nodeType' in $$props) $$invalidate('nodeType', nodeType = $$props.nodeType);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
	};

	$$self.$capture_state = () => {
		return { key, value, isParentExpanded, isParentArray, nodeType, expanded, keys };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('nodeType' in $$props) $$invalidate('nodeType', nodeType = $$props.nodeType);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
		if ('keys' in $$props) $$invalidate('keys', keys = $$props.keys);
	};

	let keys;

	$$self.$$.update = ($$dirty = { value: 1 }) => {
		if ($$dirty.value) { $$invalidate('keys', keys = Object.getOwnPropertyNames(value)); }
	};

	return {
		key,
		value,
		isParentExpanded,
		isParentArray,
		nodeType,
		expanded,
		getValue,
		keys
	};
}

class JSONObjectNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, ["key", "value", "isParentExpanded", "isParentArray", "nodeType", "expanded"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONObjectNode", options, id: create_fragment$9.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<JSONObjectNode> was created without expected prop 'key'");
		}
		if (ctx.value === undefined && !('value' in props)) {
			console.warn("<JSONObjectNode> was created without expected prop 'value'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<JSONObjectNode> was created without expected prop 'isParentExpanded'");
		}
		if (ctx.isParentArray === undefined && !('isParentArray' in props)) {
			console.warn("<JSONObjectNode> was created without expected prop 'isParentArray'");
		}
		if (ctx.nodeType === undefined && !('nodeType' in props)) {
			console.warn("<JSONObjectNode> was created without expected prop 'nodeType'");
		}
	}

	get key() {
		throw new Error("<JSONObjectNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<JSONObjectNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<JSONObjectNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONObjectNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<JSONObjectNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<JSONObjectNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<JSONObjectNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<JSONObjectNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodeType() {
		throw new Error("<JSONObjectNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeType(value) {
		throw new Error("<JSONObjectNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expanded() {
		throw new Error("<JSONObjectNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<JSONObjectNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-json-tree\src\JSONArrayNode.svelte generated by Svelte v3.12.0 */
const { Object: Object_1$1 } = globals;

function create_fragment$a(ctx) {
	var current;

	var jsonnested = new JSONNested({
		props: {
		key: ctx.key,
		expanded: ctx.expanded,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		isArray: true,
		keys: ctx.keys,
		previewKeys: ctx.previewKeys,
		getValue: ctx.getValue,
		label: "Array(" + ctx.value.length + ")",
		bracketOpen: "[",
		bracketClose: "]"
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonnested.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonnested.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonnested_changes = {};
			if (changed.key) jsonnested_changes.key = ctx.key;
			if (changed.expanded) jsonnested_changes.expanded = ctx.expanded;
			if (changed.isParentExpanded) jsonnested_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonnested_changes.isParentArray = ctx.isParentArray;
			if (changed.keys) jsonnested_changes.keys = ctx.keys;
			if (changed.previewKeys) jsonnested_changes.previewKeys = ctx.previewKeys;
			if (changed.value) jsonnested_changes.label = "Array(" + ctx.value.length + ")";
			jsonnested.$set(jsonnested_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$a.name, type: "component", source: "", ctx });
	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	

  let { key, value, isParentExpanded, isParentArray, expanded = false } = $$props;
  const filteredKey = new Set(['length']);

  function getValue(key) {
    return value[key];
  }

	const writable_props = ['key', 'value', 'isParentExpanded', 'isParentArray', 'expanded'];
	Object_1$1.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONArrayNode> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
	};

	$$self.$capture_state = () => {
		return { key, value, isParentExpanded, isParentArray, expanded, keys, previewKeys };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
		if ('keys' in $$props) $$invalidate('keys', keys = $$props.keys);
		if ('previewKeys' in $$props) $$invalidate('previewKeys', previewKeys = $$props.previewKeys);
	};

	let keys, previewKeys;

	$$self.$$.update = ($$dirty = { value: 1, keys: 1 }) => {
		if ($$dirty.value) { $$invalidate('keys', keys = Object.getOwnPropertyNames(value)); }
		if ($$dirty.keys) { $$invalidate('previewKeys', previewKeys = keys.filter(key => !filteredKey.has(key))); }
	};

	return {
		key,
		value,
		isParentExpanded,
		isParentArray,
		expanded,
		getValue,
		keys,
		previewKeys
	};
}

class JSONArrayNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, ["key", "value", "isParentExpanded", "isParentArray", "expanded"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONArrayNode", options, id: create_fragment$a.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<JSONArrayNode> was created without expected prop 'key'");
		}
		if (ctx.value === undefined && !('value' in props)) {
			console.warn("<JSONArrayNode> was created without expected prop 'value'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<JSONArrayNode> was created without expected prop 'isParentExpanded'");
		}
		if (ctx.isParentArray === undefined && !('isParentArray' in props)) {
			console.warn("<JSONArrayNode> was created without expected prop 'isParentArray'");
		}
	}

	get key() {
		throw new Error("<JSONArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<JSONArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<JSONArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<JSONArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<JSONArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<JSONArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<JSONArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expanded() {
		throw new Error("<JSONArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<JSONArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-json-tree\src\JSONIterableArrayNode.svelte generated by Svelte v3.12.0 */

function create_fragment$b(ctx) {
	var current;

	var jsonnested = new JSONNested({
		props: {
		key: ctx.key,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		keys: ctx.keys,
		getKey: getKey,
		getValue: getValue,
		isArray: true,
		label: "" + ctx.nodeType + "(" + ctx.keys.length + ")",
		bracketOpen: '{',
		bracketClose: '}'
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonnested.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonnested.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonnested_changes = {};
			if (changed.key) jsonnested_changes.key = ctx.key;
			if (changed.isParentExpanded) jsonnested_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonnested_changes.isParentArray = ctx.isParentArray;
			if (changed.keys) jsonnested_changes.keys = ctx.keys;
			if (changed.nodeType || changed.keys) jsonnested_changes.label = "" + ctx.nodeType + "(" + ctx.keys.length + ")";
			jsonnested.$set(jsonnested_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$b.name, type: "component", source: "", ctx });
	return block;
}

function getKey(key) {
  return String(key[0]);
}

function getValue(key) {
  return key[1];
}

function instance$b($$self, $$props, $$invalidate) {
	

  let { key, value, isParentExpanded, isParentArray, nodeType } = $$props;

  let keys = [];

	const writable_props = ['key', 'value', 'isParentExpanded', 'isParentArray', 'nodeType'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONIterableArrayNode> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('nodeType' in $$props) $$invalidate('nodeType', nodeType = $$props.nodeType);
	};

	$$self.$capture_state = () => {
		return { key, value, isParentExpanded, isParentArray, nodeType, keys };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('nodeType' in $$props) $$invalidate('nodeType', nodeType = $$props.nodeType);
		if ('keys' in $$props) $$invalidate('keys', keys = $$props.keys);
	};

	$$self.$$.update = ($$dirty = { value: 1 }) => {
		if ($$dirty.value) { {
        let result = [];
        let i = 0;
        for(const entry of value) {
          result.push([i++, entry]);
        }
        $$invalidate('keys', keys = result);
      } }
	};

	return {
		key,
		value,
		isParentExpanded,
		isParentArray,
		nodeType,
		keys
	};
}

class JSONIterableArrayNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, ["key", "value", "isParentExpanded", "isParentArray", "nodeType"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONIterableArrayNode", options, id: create_fragment$b.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<JSONIterableArrayNode> was created without expected prop 'key'");
		}
		if (ctx.value === undefined && !('value' in props)) {
			console.warn("<JSONIterableArrayNode> was created without expected prop 'value'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<JSONIterableArrayNode> was created without expected prop 'isParentExpanded'");
		}
		if (ctx.isParentArray === undefined && !('isParentArray' in props)) {
			console.warn("<JSONIterableArrayNode> was created without expected prop 'isParentArray'");
		}
		if (ctx.nodeType === undefined && !('nodeType' in props)) {
			console.warn("<JSONIterableArrayNode> was created without expected prop 'nodeType'");
		}
	}

	get key() {
		throw new Error("<JSONIterableArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<JSONIterableArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<JSONIterableArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONIterableArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<JSONIterableArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<JSONIterableArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<JSONIterableArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<JSONIterableArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodeType() {
		throw new Error("<JSONIterableArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeType(value) {
		throw new Error("<JSONIterableArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

class MapEntry {
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
}

/* node_modules\svelte-json-tree\src\JSONIterableMapNode.svelte generated by Svelte v3.12.0 */

function create_fragment$c(ctx) {
	var current;

	var jsonnested = new JSONNested({
		props: {
		key: ctx.key,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		keys: ctx.keys,
		getKey: getKey$1,
		getValue: getValue$1,
		label: "" + ctx.nodeType + "(" + ctx.keys.length + ")",
		colon: "",
		bracketOpen: '{',
		bracketClose: '}'
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonnested.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonnested.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonnested_changes = {};
			if (changed.key) jsonnested_changes.key = ctx.key;
			if (changed.isParentExpanded) jsonnested_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonnested_changes.isParentArray = ctx.isParentArray;
			if (changed.keys) jsonnested_changes.keys = ctx.keys;
			if (changed.nodeType || changed.keys) jsonnested_changes.label = "" + ctx.nodeType + "(" + ctx.keys.length + ")";
			jsonnested.$set(jsonnested_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$c.name, type: "component", source: "", ctx });
	return block;
}

function getKey$1(entry) {
  return entry[0];
}

function getValue$1(entry) {
  return entry[1];
}

function instance$c($$self, $$props, $$invalidate) {
	

  let { key, value, isParentExpanded, isParentArray, nodeType } = $$props;

  let keys = [];

	const writable_props = ['key', 'value', 'isParentExpanded', 'isParentArray', 'nodeType'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONIterableMapNode> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('nodeType' in $$props) $$invalidate('nodeType', nodeType = $$props.nodeType);
	};

	$$self.$capture_state = () => {
		return { key, value, isParentExpanded, isParentArray, nodeType, keys };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('nodeType' in $$props) $$invalidate('nodeType', nodeType = $$props.nodeType);
		if ('keys' in $$props) $$invalidate('keys', keys = $$props.keys);
	};

	$$self.$$.update = ($$dirty = { value: 1 }) => {
		if ($$dirty.value) { {
        let result = [];
        let i = 0;
        for(const entry of value) {
          result.push([i++, new MapEntry(entry[0], entry[1])]);
        }
        $$invalidate('keys', keys = result);
      } }
	};

	return {
		key,
		value,
		isParentExpanded,
		isParentArray,
		nodeType,
		keys
	};
}

class JSONIterableMapNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, ["key", "value", "isParentExpanded", "isParentArray", "nodeType"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONIterableMapNode", options, id: create_fragment$c.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<JSONIterableMapNode> was created without expected prop 'key'");
		}
		if (ctx.value === undefined && !('value' in props)) {
			console.warn("<JSONIterableMapNode> was created without expected prop 'value'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<JSONIterableMapNode> was created without expected prop 'isParentExpanded'");
		}
		if (ctx.isParentArray === undefined && !('isParentArray' in props)) {
			console.warn("<JSONIterableMapNode> was created without expected prop 'isParentArray'");
		}
		if (ctx.nodeType === undefined && !('nodeType' in props)) {
			console.warn("<JSONIterableMapNode> was created without expected prop 'nodeType'");
		}
	}

	get key() {
		throw new Error("<JSONIterableMapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<JSONIterableMapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<JSONIterableMapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONIterableMapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<JSONIterableMapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<JSONIterableMapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<JSONIterableMapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<JSONIterableMapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodeType() {
		throw new Error("<JSONIterableMapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeType(value) {
		throw new Error("<JSONIterableMapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-json-tree\src\JSONMapEntryNode.svelte generated by Svelte v3.12.0 */

function create_fragment$d(ctx) {
	var current;

	var jsonnested = new JSONNested({
		props: {
		expanded: ctx.expanded,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		key: ctx.isParentExpanded ? String(ctx.key) : ctx.value.key,
		keys: ctx.keys,
		getValue: ctx.getValue,
		label: ctx.isParentExpanded ? ': Entry ': '=> ',
		bracketOpen: '{',
		bracketClose: '}'
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonnested.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonnested.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonnested_changes = {};
			if (changed.expanded) jsonnested_changes.expanded = ctx.expanded;
			if (changed.isParentExpanded) jsonnested_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonnested_changes.isParentArray = ctx.isParentArray;
			if (changed.isParentExpanded || changed.key || changed.value) jsonnested_changes.key = ctx.isParentExpanded ? String(ctx.key) : ctx.value.key;
			if (changed.isParentExpanded) jsonnested_changes.label = ctx.isParentExpanded ? ': Entry ': '=> ';
			jsonnested.$set(jsonnested_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$d.name, type: "component", source: "", ctx });
	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	

  let { key, value, isParentExpanded, isParentArray, expanded = false } = $$props;

  const keys = ['key', 'value'];

  function getValue(key) {
    return value[key];
  }

	const writable_props = ['key', 'value', 'isParentExpanded', 'isParentArray', 'expanded'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONMapEntryNode> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
	};

	$$self.$capture_state = () => {
		return { key, value, isParentExpanded, isParentArray, expanded };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
	};

	return {
		key,
		value,
		isParentExpanded,
		isParentArray,
		expanded,
		keys,
		getValue
	};
}

class JSONMapEntryNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, ["key", "value", "isParentExpanded", "isParentArray", "expanded"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONMapEntryNode", options, id: create_fragment$d.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<JSONMapEntryNode> was created without expected prop 'key'");
		}
		if (ctx.value === undefined && !('value' in props)) {
			console.warn("<JSONMapEntryNode> was created without expected prop 'value'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<JSONMapEntryNode> was created without expected prop 'isParentExpanded'");
		}
		if (ctx.isParentArray === undefined && !('isParentArray' in props)) {
			console.warn("<JSONMapEntryNode> was created without expected prop 'isParentArray'");
		}
	}

	get key() {
		throw new Error("<JSONMapEntryNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<JSONMapEntryNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<JSONMapEntryNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONMapEntryNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<JSONMapEntryNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<JSONMapEntryNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<JSONMapEntryNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<JSONMapEntryNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expanded() {
		throw new Error("<JSONMapEntryNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<JSONMapEntryNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-json-tree\src\JSONValueNode.svelte generated by Svelte v3.12.0 */

const file$9 = "node_modules\\svelte-json-tree\\src\\JSONValueNode.svelte";

function create_fragment$e(ctx) {
	var li, t0, span, t1_value = ctx.valueGetter ? ctx.valueGetter(ctx.value) : ctx.value + "", t1, span_class_value, current;

	var jsonkey = new JSONKey({
		props: {
		key: ctx.key,
		colon: ctx.colon,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			li = element("li");
			jsonkey.$$.fragment.c();
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			jsonkey.$$.fragment.l(li_nodes);
			t0 = claim_space(li_nodes);

			span = claim_element(li_nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", span_class_value = "" + null_to_empty(ctx.nodeType) + " svelte-1m3zj06");
			add_location(span, file$9, 47, 2, 947);
			attr_dev(li, "class", "svelte-1m3zj06");
			toggle_class(li, "indent", ctx.isParentExpanded);
			add_location(li, file$9, 45, 0, 845);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(jsonkey, li, null);
			append_dev(li, t0);
			append_dev(li, span);
			append_dev(span, t1);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonkey_changes = {};
			if (changed.key) jsonkey_changes.key = ctx.key;
			if (changed.isParentExpanded) jsonkey_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonkey_changes.isParentArray = ctx.isParentArray;
			jsonkey.$set(jsonkey_changes);

			if ((!current || changed.valueGetter || changed.value) && t1_value !== (t1_value = ctx.valueGetter ? ctx.valueGetter(ctx.value) : ctx.value + "")) {
				set_data_dev(t1, t1_value);
			}

			if ((!current || changed.nodeType) && span_class_value !== (span_class_value = "" + null_to_empty(ctx.nodeType) + " svelte-1m3zj06")) {
				attr_dev(span, "class", span_class_value);
			}

			if (changed.isParentExpanded) {
				toggle_class(li, "indent", ctx.isParentExpanded);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonkey.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonkey.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			destroy_component(jsonkey);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$e.name, type: "component", source: "", ctx });
	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	

  let { key, value, valueGetter = null, isParentExpanded, isParentArray, nodeType } = $$props;

  const { colon } = getContext(contextKey);

	const writable_props = ['key', 'value', 'valueGetter', 'isParentExpanded', 'isParentArray', 'nodeType'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONValueNode> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('valueGetter' in $$props) $$invalidate('valueGetter', valueGetter = $$props.valueGetter);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('nodeType' in $$props) $$invalidate('nodeType', nodeType = $$props.nodeType);
	};

	$$self.$capture_state = () => {
		return { key, value, valueGetter, isParentExpanded, isParentArray, nodeType };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('valueGetter' in $$props) $$invalidate('valueGetter', valueGetter = $$props.valueGetter);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('nodeType' in $$props) $$invalidate('nodeType', nodeType = $$props.nodeType);
	};

	return {
		key,
		value,
		valueGetter,
		isParentExpanded,
		isParentArray,
		nodeType,
		colon
	};
}

class JSONValueNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, ["key", "value", "valueGetter", "isParentExpanded", "isParentArray", "nodeType"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONValueNode", options, id: create_fragment$e.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<JSONValueNode> was created without expected prop 'key'");
		}
		if (ctx.value === undefined && !('value' in props)) {
			console.warn("<JSONValueNode> was created without expected prop 'value'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<JSONValueNode> was created without expected prop 'isParentExpanded'");
		}
		if (ctx.isParentArray === undefined && !('isParentArray' in props)) {
			console.warn("<JSONValueNode> was created without expected prop 'isParentArray'");
		}
		if (ctx.nodeType === undefined && !('nodeType' in props)) {
			console.warn("<JSONValueNode> was created without expected prop 'nodeType'");
		}
	}

	get key() {
		throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueGetter() {
		throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueGetter(value) {
		throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodeType() {
		throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeType(value) {
		throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-json-tree\src\ErrorNode.svelte generated by Svelte v3.12.0 */

const file$a = "node_modules\\svelte-json-tree\\src\\ErrorNode.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.line = list[i];
	child_ctx.index = i;
	return child_ctx;
}

// (40:2) {#if isParentExpanded}
function create_if_block_2$3(ctx) {
	var current;

	var jsonarrow = new JSONArrow({
		props: { expanded: ctx.expanded },
		$$inline: true
	});
	jsonarrow.$on("click", ctx.toggleExpand);

	const block = {
		c: function create() {
			jsonarrow.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonarrow.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonarrow, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonarrow_changes = {};
			if (changed.expanded) jsonarrow_changes.expanded = ctx.expanded;
			jsonarrow.$set(jsonarrow_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonarrow.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonarrow.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonarrow, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2$3.name, type: "if", source: "(40:2) {#if isParentExpanded}", ctx });
	return block;
}

// (45:2) {#if isParentExpanded}
function create_if_block$7(ctx) {
	var ul, current;

	var if_block = (ctx.expanded) && create_if_block_1$4(ctx);

	const block = {
		c: function create() {
			ul = element("ul");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			if (if_block) if_block.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(ul, "class", "svelte-zydcof");
			toggle_class(ul, "collapse", !ctx.expanded);
			add_location(ul, file$a, 45, 4, 1133);
		},

		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			if (if_block) if_block.m(ul, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.expanded) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(ul, null);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}

			if (changed.expanded) {
				toggle_class(ul, "collapse", !ctx.expanded);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(ul);
			}

			if (if_block) if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$7.name, type: "if", source: "(45:2) {#if isParentExpanded}", ctx });
	return block;
}

// (47:6) {#if expanded}
function create_if_block_1$4(ctx) {
	var t0, li, t1, span, current;

	var jsonnode = new JSONNode({
		props: { key: "message", value: ctx.value.message },
		$$inline: true
	});

	var jsonkey = new JSONKey({
		props: {
		key: "stack",
		colon: ":",
		isParentExpanded: ctx.isParentExpanded
	},
		$$inline: true
	});

	let each_value = ctx.stack;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			jsonnode.$$.fragment.c();
			t0 = space();
			li = element("li");
			jsonkey.$$.fragment.c();
			t1 = space();
			span = element("span");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			jsonnode.$$.fragment.l(nodes);
			t0 = claim_space(nodes);

			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			jsonkey.$$.fragment.l(li_nodes);
			t1 = claim_space(li_nodes);

			span = claim_element(li_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(span_nodes);
			}

			span_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			add_location(span, file$a, 50, 10, 1329);
			attr_dev(li, "class", "svelte-zydcof");
			add_location(li, file$a, 48, 8, 1251);
		},

		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, li, anchor);
			mount_component(jsonkey, li, null);
			append_dev(li, t1);
			append_dev(li, span);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(span, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			var jsonnode_changes = {};
			if (changed.value) jsonnode_changes.value = ctx.value.message;
			jsonnode.$set(jsonnode_changes);

			var jsonkey_changes = {};
			if (changed.isParentExpanded) jsonkey_changes.isParentExpanded = ctx.isParentExpanded;
			jsonkey.$set(jsonkey_changes);

			if (changed.stack) {
				each_value = ctx.stack;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(span, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);

			transition_in(jsonkey.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			transition_out(jsonkey.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);

			if (detaching) {
				detach_dev(t0);
				detach_dev(li);
			}

			destroy_component(jsonkey);

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$4.name, type: "if", source: "(47:6) {#if expanded}", ctx });
	return block;
}

// (52:12) {#each stack as line, index}
function create_each_block$3(ctx) {
	var span, t_value = ctx.line + "", t, br;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			br = element("br");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);

			br = claim_element(nodes, "BR", {}, false);
			var br_nodes = children(br);

			br_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "svelte-zydcof");
			toggle_class(span, "indent", ctx.index > 0);
			add_location(span, file$a, 52, 14, 1391);
			add_location(br, file$a, 52, 58, 1435);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
			insert_dev(target, br, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.stack) && t_value !== (t_value = ctx.line + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
				detach_dev(br);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$3.name, type: "each", source: "(52:12) {#each stack as line, index}", ctx });
	return block;
}

function create_fragment$f(ctx) {
	var li, t0, t1, span, t2, t3_value = ctx.expanded?'':ctx.value.message + "", t3, t4, current, dispose;

	var if_block0 = (ctx.isParentExpanded) && create_if_block_2$3(ctx);

	var jsonkey = new JSONKey({
		props: {
		key: ctx.key,
		colon: ctx.context.colon,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray
	},
		$$inline: true
	});

	var if_block1 = (ctx.isParentExpanded) && create_if_block$7(ctx);

	const block = {
		c: function create() {
			li = element("li");
			if (if_block0) if_block0.c();
			t0 = space();
			jsonkey.$$.fragment.c();
			t1 = space();
			span = element("span");
			t2 = text("Error: ");
			t3 = text(t3_value);
			t4 = space();
			if (if_block1) if_block1.c();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			if (if_block0) if_block0.l(li_nodes);
			t0 = claim_space(li_nodes);
			jsonkey.$$.fragment.l(li_nodes);
			t1 = claim_space(li_nodes);

			span = claim_element(li_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t2 = claim_text(span_nodes, "Error: ");
			t3 = claim_text(span_nodes, t3_value);
			span_nodes.forEach(detach_dev);
			t4 = claim_space(li_nodes);
			if (if_block1) if_block1.l(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			add_location(span, file$a, 43, 2, 1032);
			attr_dev(li, "class", "svelte-zydcof");
			toggle_class(li, "indent", ctx.isParentExpanded);
			add_location(li, file$a, 38, 0, 830);
			dispose = listen_dev(span, "click", ctx.toggleExpand);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			if (if_block0) if_block0.m(li, null);
			append_dev(li, t0);
			mount_component(jsonkey, li, null);
			append_dev(li, t1);
			append_dev(li, span);
			append_dev(span, t2);
			append_dev(span, t3);
			append_dev(li, t4);
			if (if_block1) if_block1.m(li, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.isParentExpanded) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_2$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(li, t0);
				}
			} else if (if_block0) {
				group_outros();
				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});
				check_outros();
			}

			var jsonkey_changes = {};
			if (changed.key) jsonkey_changes.key = ctx.key;
			if (changed.isParentExpanded) jsonkey_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonkey_changes.isParentArray = ctx.isParentArray;
			jsonkey.$set(jsonkey_changes);

			if ((!current || changed.expanded || changed.value) && t3_value !== (t3_value = ctx.expanded?'':ctx.value.message + "")) {
				set_data_dev(t3, t3_value);
			}

			if (ctx.isParentExpanded) {
				if (if_block1) {
					if_block1.p(changed, ctx);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block$7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(li, null);
				}
			} else if (if_block1) {
				group_outros();
				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});
				check_outros();
			}

			if (changed.isParentExpanded) {
				toggle_class(li, "indent", ctx.isParentExpanded);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);

			transition_in(jsonkey.$$.fragment, local);

			transition_in(if_block1);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block0);
			transition_out(jsonkey.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			if (if_block0) if_block0.d();

			destroy_component(jsonkey);

			if (if_block1) if_block1.d();
			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$f.name, type: "component", source: "", ctx });
	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	

  let { key, value, isParentExpanded, isParentArray, expanded = false } = $$props;

  const context = getContext(contextKey);
  setContext(contextKey, { ...context, colon: ':' });

  function toggleExpand() {
    $$invalidate('expanded', expanded = !expanded);
  }

	const writable_props = ['key', 'value', 'isParentExpanded', 'isParentArray', 'expanded'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ErrorNode> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
	};

	$$self.$capture_state = () => {
		return { key, value, isParentExpanded, isParentArray, expanded, stack };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
		if ('expanded' in $$props) $$invalidate('expanded', expanded = $$props.expanded);
		if ('stack' in $$props) $$invalidate('stack', stack = $$props.stack);
	};

	let stack;

	$$self.$$.update = ($$dirty = { value: 1, isParentExpanded: 1 }) => {
		if ($$dirty.value) { $$invalidate('stack', stack = value.stack.split('\n')); }
		if ($$dirty.isParentExpanded) { if (!isParentExpanded) {
        $$invalidate('expanded', expanded = false);
      } }
	};

	return {
		key,
		value,
		isParentExpanded,
		isParentArray,
		expanded,
		context,
		toggleExpand,
		stack
	};
}

class ErrorNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, ["key", "value", "isParentExpanded", "isParentArray", "expanded"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "ErrorNode", options, id: create_fragment$f.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<ErrorNode> was created without expected prop 'key'");
		}
		if (ctx.value === undefined && !('value' in props)) {
			console.warn("<ErrorNode> was created without expected prop 'value'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<ErrorNode> was created without expected prop 'isParentExpanded'");
		}
		if (ctx.isParentArray === undefined && !('isParentArray' in props)) {
			console.warn("<ErrorNode> was created without expected prop 'isParentArray'");
		}
	}

	get key() {
		throw new Error("<ErrorNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<ErrorNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<ErrorNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ErrorNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<ErrorNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<ErrorNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<ErrorNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<ErrorNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expanded() {
		throw new Error("<ErrorNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<ErrorNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-json-tree\src\JSONNode.svelte generated by Svelte v3.12.0 */

// (43:0) {:else}
function create_else_block_1(ctx) {
	var current;

	var jsonvaluenode = new JSONValueNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType,
		valueGetter: ctx.func_6
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonvaluenode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonvaluenode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonvaluenode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonvaluenode_changes = {};
			if (changed.key) jsonvaluenode_changes.key = ctx.key;
			if (changed.value) jsonvaluenode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonvaluenode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonvaluenode_changes.isParentArray = ctx.isParentArray;
			jsonvaluenode.$set(jsonvaluenode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonvaluenode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonvaluenode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonvaluenode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block_1.name, type: "else", source: "(43:0) {:else}", ctx });
	return block;
}

// (41:59) 
function create_if_block_12(ctx) {
	var current;

	var jsonvaluenode = new JSONValueNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType,
		valueGetter: func_5
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonvaluenode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonvaluenode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonvaluenode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonvaluenode_changes = {};
			if (changed.key) jsonvaluenode_changes.key = ctx.key;
			if (changed.value) jsonvaluenode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonvaluenode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonvaluenode_changes.isParentArray = ctx.isParentArray;
			jsonvaluenode.$set(jsonvaluenode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonvaluenode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonvaluenode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonvaluenode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_12.name, type: "if", source: "(41:59) ", ctx });
	return block;
}

// (39:35) 
function create_if_block_11(ctx) {
	var current;

	var jsonvaluenode = new JSONValueNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType,
		valueGetter: func_4
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonvaluenode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonvaluenode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonvaluenode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonvaluenode_changes = {};
			if (changed.key) jsonvaluenode_changes.key = ctx.key;
			if (changed.value) jsonvaluenode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonvaluenode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonvaluenode_changes.isParentArray = ctx.isParentArray;
			jsonvaluenode.$set(jsonvaluenode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonvaluenode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonvaluenode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonvaluenode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_11.name, type: "if", source: "(39:35) ", ctx });
	return block;
}

// (37:30) 
function create_if_block_10(ctx) {
	var current;

	var jsonvaluenode = new JSONValueNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType,
		valueGetter: func_3
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonvaluenode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonvaluenode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonvaluenode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonvaluenode_changes = {};
			if (changed.key) jsonvaluenode_changes.key = ctx.key;
			if (changed.value) jsonvaluenode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonvaluenode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonvaluenode_changes.isParentArray = ctx.isParentArray;
			jsonvaluenode.$set(jsonvaluenode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonvaluenode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonvaluenode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonvaluenode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_10.name, type: "if", source: "(37:30) ", ctx });
	return block;
}

// (35:30) 
function create_if_block_9(ctx) {
	var current;

	var jsonvaluenode = new JSONValueNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType,
		valueGetter: func_2
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonvaluenode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonvaluenode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonvaluenode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonvaluenode_changes = {};
			if (changed.key) jsonvaluenode_changes.key = ctx.key;
			if (changed.value) jsonvaluenode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonvaluenode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonvaluenode_changes.isParentArray = ctx.isParentArray;
			jsonvaluenode.$set(jsonvaluenode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonvaluenode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonvaluenode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonvaluenode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_9.name, type: "if", source: "(35:30) ", ctx });
	return block;
}

// (33:33) 
function create_if_block_8(ctx) {
	var current;

	var jsonvaluenode = new JSONValueNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType,
		valueGetter: func_1
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonvaluenode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonvaluenode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonvaluenode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonvaluenode_changes = {};
			if (changed.key) jsonvaluenode_changes.key = ctx.key;
			if (changed.value) jsonvaluenode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonvaluenode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonvaluenode_changes.isParentArray = ctx.isParentArray;
			jsonvaluenode.$set(jsonvaluenode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonvaluenode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonvaluenode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonvaluenode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_8.name, type: "if", source: "(33:33) ", ctx });
	return block;
}

// (31:32) 
function create_if_block_7(ctx) {
	var current;

	var jsonvaluenode = new JSONValueNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonvaluenode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonvaluenode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonvaluenode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonvaluenode_changes = {};
			if (changed.key) jsonvaluenode_changes.key = ctx.key;
			if (changed.value) jsonvaluenode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonvaluenode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonvaluenode_changes.isParentArray = ctx.isParentArray;
			jsonvaluenode.$set(jsonvaluenode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonvaluenode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonvaluenode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonvaluenode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_7.name, type: "if", source: "(31:32) ", ctx });
	return block;
}

// (29:32) 
function create_if_block_6(ctx) {
	var current;

	var jsonvaluenode = new JSONValueNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType,
		valueGetter: func
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonvaluenode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonvaluenode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonvaluenode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonvaluenode_changes = {};
			if (changed.key) jsonvaluenode_changes.key = ctx.key;
			if (changed.value) jsonvaluenode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonvaluenode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonvaluenode_changes.isParentArray = ctx.isParentArray;
			jsonvaluenode.$set(jsonvaluenode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonvaluenode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonvaluenode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonvaluenode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_6.name, type: "if", source: "(29:32) ", ctx });
	return block;
}

// (27:34) 
function create_if_block_5(ctx) {
	var current;

	var jsonmapentrynode = new JSONMapEntryNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonmapentrynode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonmapentrynode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonmapentrynode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonmapentrynode_changes = {};
			if (changed.key) jsonmapentrynode_changes.key = ctx.key;
			if (changed.value) jsonmapentrynode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonmapentrynode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonmapentrynode_changes.isParentArray = ctx.isParentArray;
			jsonmapentrynode.$set(jsonmapentrynode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonmapentrynode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonmapentrynode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonmapentrynode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_5.name, type: "if", source: "(27:34) ", ctx });
	return block;
}

// (21:78) 
function create_if_block_3$1(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block_4,
		create_else_block$3
	];

	var if_blocks = [];

	function select_block_type_1(changed, ctx) {
		if (typeof ctx.value.set === 'function') return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_3$1.name, type: "if", source: "(21:78) ", ctx });
	return block;
}

// (19:31) 
function create_if_block_2$4(ctx) {
	var current;

	var jsonarraynode = new JSONArrayNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonarraynode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonarraynode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonarraynode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonarraynode_changes = {};
			if (changed.key) jsonarraynode_changes.key = ctx.key;
			if (changed.value) jsonarraynode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonarraynode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonarraynode_changes.isParentArray = ctx.isParentArray;
			jsonarraynode.$set(jsonarraynode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonarraynode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonarraynode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonarraynode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2$4.name, type: "if", source: "(19:31) ", ctx });
	return block;
}

// (17:31) 
function create_if_block_1$5(ctx) {
	var current;

	var errornode = new ErrorNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			errornode.$$.fragment.c();
		},

		l: function claim(nodes) {
			errornode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(errornode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var errornode_changes = {};
			if (changed.key) errornode_changes.key = ctx.key;
			if (changed.value) errornode_changes.value = ctx.value;
			if (changed.isParentExpanded) errornode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) errornode_changes.isParentArray = ctx.isParentArray;
			errornode.$set(errornode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(errornode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(errornode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(errornode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$5.name, type: "if", source: "(17:31) ", ctx });
	return block;
}

// (15:0) {#if nodeType === 'Object'}
function create_if_block$8(ctx) {
	var current;

	var jsonobjectnode = new JSONObjectNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonobjectnode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonobjectnode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonobjectnode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonobjectnode_changes = {};
			if (changed.key) jsonobjectnode_changes.key = ctx.key;
			if (changed.value) jsonobjectnode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsonobjectnode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsonobjectnode_changes.isParentArray = ctx.isParentArray;
			jsonobjectnode.$set(jsonobjectnode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonobjectnode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonobjectnode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonobjectnode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$8.name, type: "if", source: "(15:0) {#if nodeType === 'Object'}", ctx });
	return block;
}

// (24:2) {:else}
function create_else_block$3(ctx) {
	var current;

	var jsoniterablearraynode = new JSONIterableArrayNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsoniterablearraynode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsoniterablearraynode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsoniterablearraynode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsoniterablearraynode_changes = {};
			if (changed.key) jsoniterablearraynode_changes.key = ctx.key;
			if (changed.value) jsoniterablearraynode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsoniterablearraynode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsoniterablearraynode_changes.isParentArray = ctx.isParentArray;
			jsoniterablearraynode.$set(jsoniterablearraynode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsoniterablearraynode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsoniterablearraynode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsoniterablearraynode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$3.name, type: "else", source: "(24:2) {:else}", ctx });
	return block;
}

// (22:2) {#if typeof value.set === 'function'}
function create_if_block_4(ctx) {
	var current;

	var jsoniterablemapnode = new JSONIterableMapNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: ctx.isParentExpanded,
		isParentArray: ctx.isParentArray,
		nodeType: ctx.nodeType
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			jsoniterablemapnode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsoniterablemapnode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsoniterablemapnode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsoniterablemapnode_changes = {};
			if (changed.key) jsoniterablemapnode_changes.key = ctx.key;
			if (changed.value) jsoniterablemapnode_changes.value = ctx.value;
			if (changed.isParentExpanded) jsoniterablemapnode_changes.isParentExpanded = ctx.isParentExpanded;
			if (changed.isParentArray) jsoniterablemapnode_changes.isParentArray = ctx.isParentArray;
			jsoniterablemapnode.$set(jsoniterablemapnode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsoniterablemapnode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsoniterablemapnode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsoniterablemapnode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_4.name, type: "if", source: "(22:2) {#if typeof value.set === 'function'}", ctx });
	return block;
}

function create_fragment$g(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block$8,
		create_if_block_1$5,
		create_if_block_2$4,
		create_if_block_3$1,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_if_block_9,
		create_if_block_10,
		create_if_block_11,
		create_if_block_12,
		create_else_block_1
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.nodeType === 'Object') return 0;
		if (ctx.nodeType === 'Error') return 1;
		if (ctx.nodeType === 'Array') return 2;
		if (ctx.nodeType === 'Iterable' || ctx.nodeType === 'Map' || ctx.nodeType === 'Set') return 3;
		if (ctx.nodeType === 'MapEntry') return 4;
		if (ctx.nodeType === 'String') return 5;
		if (ctx.nodeType === 'Number') return 6;
		if (ctx.nodeType === 'Boolean') return 7;
		if (ctx.nodeType === 'Date') return 8;
		if (ctx.nodeType === 'Null') return 9;
		if (ctx.nodeType === 'Undefined') return 10;
		if (ctx.nodeType === 'Function' || ctx.nodeType === 'Symbol') return 11;
		return 12;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if_block.p(changed, ctx);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$g.name, type: "component", source: "", ctx });
	return block;
}

const func = (raw) => `"${raw}"`;

const func_1 = (raw) => (raw ? 'true' : 'false');

const func_2 = (raw) => raw.toISOString();

const func_3 = () => 'null';

const func_4 = () => 'undefined';

const func_5 = (raw) => raw.toString();

function instance$g($$self, $$props, $$invalidate) {
	

  let { key, value, isParentExpanded, isParentArray } = $$props;
  const nodeType = objType(value);

	const writable_props = ['key', 'value', 'isParentExpanded', 'isParentArray'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<JSONNode> was created with unknown prop '${key}'`);
	});

	const func_6 = () => `<${nodeType}>`;

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
	};

	$$self.$capture_state = () => {
		return { key, value, isParentExpanded, isParentArray };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
		if ('isParentExpanded' in $$props) $$invalidate('isParentExpanded', isParentExpanded = $$props.isParentExpanded);
		if ('isParentArray' in $$props) $$invalidate('isParentArray', isParentArray = $$props.isParentArray);
	};

	return {
		key,
		value,
		isParentExpanded,
		isParentArray,
		nodeType,
		func_6
	};
}

class JSONNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$g, create_fragment$g, safe_not_equal, ["key", "value", "isParentExpanded", "isParentArray"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "JSONNode", options, id: create_fragment$g.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.key === undefined && !('key' in props)) {
			console.warn("<JSONNode> was created without expected prop 'key'");
		}
		if (ctx.value === undefined && !('value' in props)) {
			console.warn("<JSONNode> was created without expected prop 'value'");
		}
		if (ctx.isParentExpanded === undefined && !('isParentExpanded' in props)) {
			console.warn("<JSONNode> was created without expected prop 'isParentExpanded'");
		}
		if (ctx.isParentArray === undefined && !('isParentArray' in props)) {
			console.warn("<JSONNode> was created without expected prop 'isParentArray'");
		}
	}

	get key() {
		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentExpanded() {
		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentExpanded(value) {
		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isParentArray() {
		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isParentArray(value) {
		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\svelte-json-tree\src\index.svelte generated by Svelte v3.12.0 */

const file$b = "node_modules\\svelte-json-tree\\src\\index.svelte";

function create_fragment$h(ctx) {
	var ul, current;

	var jsonnode = new JSONNode({
		props: {
		key: ctx.key,
		value: ctx.value,
		isParentExpanded: true,
		isParentArray: false
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			ul = element("ul");
			jsonnode.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			jsonnode.$$.fragment.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(ul, "class", "svelte-fisoh6");
			add_location(ul, file$b, 36, 0, 867);
		},

		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			mount_component(jsonnode, ul, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonnode_changes = {};
			if (changed.key) jsonnode_changes.key = ctx.key;
			if (changed.value) jsonnode_changes.value = ctx.value;
			jsonnode.$set(jsonnode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(ul);
			}

			destroy_component(jsonnode);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$h.name, type: "component", source: "", ctx });
	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	

  setContext(contextKey, {});

  let { key = '', value } = $$props;

	const writable_props = ['key', 'value'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
	};

	$$self.$capture_state = () => {
		return { key, value };
	};

	$$self.$inject_state = $$props => {
		if ('key' in $$props) $$invalidate('key', key = $$props.key);
		if ('value' in $$props) $$invalidate('value', value = $$props.value);
	};

	return { key, value };
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$h, create_fragment$h, safe_not_equal, ["key", "value"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$h.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.value === undefined && !('value' in props)) {
			console.warn("<Index> was created without expected prop 'value'");
		}
	}

	get key() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Output\Console.svelte generated by Svelte v3.12.0 */

const file$c = "node_modules\\@sveltejs\\svelte-repl\\src\\Output\\Console.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.arg = list[i];
	return child_ctx;
}

function get_each_context$4(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.log = list[i];
	return child_ctx;
}

// (10:3) {#if log.count > 1}
function create_if_block_2$5(ctx) {
	var span, t0_value = ctx.log.count + "", t0, t1;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = text("x");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t0 = claim_text(span_nodes, t0_value);
			t1 = claim_text(span_nodes, "x");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "count svelte-wfxu7a");
			add_location(span, file$c, 10, 4, 193);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, t1);
		},

		p: function update(changed, ctx) {
			if ((changed.logs) && t0_value !== (t0_value = ctx.log.count + "")) {
				set_data_dev(t0, t0_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2$5.name, type: "if", source: "(10:3) {#if log.count > 1}", ctx });
	return block;
}

// (18:3) {:else}
function create_else_block$4(ctx) {
	var each_1_anchor, current;

	let each_value_1 = ctx.log.args;

	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},

		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},

		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.logs) {
				each_value_1 = ctx.log.args;

				let i;
				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();
				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach_dev(each_1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$4.name, type: "else", source: "(18:3) {:else}", ctx });
	return block;
}

// (16:40) 
function create_if_block_1$6(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Message could not be cloned. Open devtools to see it");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "Message could not be cloned. Open devtools to see it");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "info error svelte-wfxu7a");
			add_location(span, file$c, 16, 4, 369);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$6.name, type: "if", source: "(16:40) ", ctx });
	return block;
}

// (14:3) {#if log.level === 'clear'}
function create_if_block$9(ctx) {
	var span, t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Console was cleared");
			this.h();
		},

		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t = claim_text(span_nodes, "Console was cleared");
			span_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "info svelte-wfxu7a");
			add_location(span, file$c, 14, 4, 278);
		},

		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(span);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$9.name, type: "if", source: "(14:3) {#if log.level === 'clear'}", ctx });
	return block;
}

// (19:4) {#each log.args as arg}
function create_each_block_1(ctx) {
	var current;

	var jsonnode = new Index({
		props: { value: ctx.arg },
		$$inline: true
	});

	const block = {
		c: function create() {
			jsonnode.$$.fragment.c();
		},

		l: function claim(nodes) {
			jsonnode.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var jsonnode_changes = {};
			if (changed.logs) jsonnode_changes.value = ctx.arg;
			jsonnode.$set(jsonnode_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block_1.name, type: "each", source: "(19:4) {#each log.args as arg}", ctx });
	return block;
}

// (8:1) {#each logs as log}
function create_each_block$4(ctx) {
	var div, t0, current_block_type_index, if_block1, t1, div_class_value, current;

	var if_block0 = (ctx.log.count > 1) && create_if_block_2$5(ctx);

	var if_block_creators = [
		create_if_block$9,
		create_if_block_1$6,
		create_else_block$4
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.log.level === 'clear') return 0;
		if (ctx.log.level === 'unclonable') return 1;
		return 2;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if_block1.c();
			t1 = space();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "log console-" + ctx.log.level + " svelte-wfxu7a");
			add_location(div, file$c, 8, 2, 128);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t1);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.log.count > 1) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_2$5(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block1 = if_blocks[current_block_type_index];
				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}
				transition_in(if_block1, 1);
				if_block1.m(div, t1);
			}

			if ((!current || changed.logs) && div_class_value !== (div_class_value = "log console-" + ctx.log.level + " svelte-wfxu7a")) {
				attr_dev(div, "class", div_class_value);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$4.name, type: "each", source: "(8:1) {#each logs as log}", ctx });
	return block;
}

function create_fragment$i(ctx) {
	var div, current;

	let each_value = ctx.logs;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "container");
			add_location(div, file$c, 6, 0, 81);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.logs) {
				each_value = ctx.logs;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();
				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$i.name, type: "component", source: "", ctx });
	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	let { logs } = $$props;

	const writable_props = ['logs'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Console> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('logs' in $$props) $$invalidate('logs', logs = $$props.logs);
	};

	$$self.$capture_state = () => {
		return { logs };
	};

	$$self.$inject_state = $$props => {
		if ('logs' in $$props) $$invalidate('logs', logs = $$props.logs);
	};

	return { logs };
}

class Console extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$i, safe_not_equal, ["logs"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Console", options, id: create_fragment$i.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.logs === undefined && !('logs' in props)) {
			console.warn("<Console> was created without expected prop 'logs'");
		}
	}

	get logs() {
		throw new Error("<Console>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set logs(value) {
		throw new Error("<Console>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var srcdoc = "<!doctype html>\n<html>\n\t<head>\n\t\t<style>\n\t\t\thtml, body {\n\tposition: relative;\n\twidth: 100%;\n\theight: 100%;\n}\n\nbody {\n\tcolor: #333;\n\tmargin: 0;\n\tpadding: 8px;\n\tbox-sizing: border-box;\n\tfont-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\n}\n\na {\n\tcolor: rgb(0,100,200);\n\ttext-decoration: none;\n}\n\na:hover {\n\ttext-decoration: underline;\n}\n\na:visited {\n\tcolor: rgb(0,80,160);\n}\n\nlabel {\n\tdisplay: block;\n}\n\ninput, button, select, textarea {\n\tfont-family: inherit;\n\tfont-size: inherit;\n\tpadding: 0.4em;\n\tmargin: 0 0 0.5em 0;\n\tbox-sizing: border-box;\n\tborder: 1px solid #ccc;\n\tborder-radius: 2px;\n}\n\ninput:disabled {\n\tcolor: #ccc;\n}\n\ninput[type=\"range\"] {\n\theight: 0;\n}\n\nbutton {\n\tcolor: #333;\n\tbackground-color: #f4f4f4;\n\toutline: none;\n}\n\nbutton:disabled {\n\tcolor: #999;\n}\n\nbutton:not(:disabled):active {\n\tbackground-color: #ddd;\n}\n\nbutton:focus {\n\tborder-color: #666;\n}\n\n\t\t</style>\n\n\t\t<script>\n\t\t\t(function(){\n\t\t\t\tfunction handle_message(ev) {\n\t\t\t\t\tlet { action, cmd_id } = ev.data;\n\t\t\t\t\tconst send_message = (payload) => parent.postMessage( { ...payload }, ev.origin);\n\t\t\t\t\tconst send_reply = (payload) => send_message({ ...payload, cmd_id });\n\t\t\t\t\tconst send_ok = () => send_reply({ action: 'cmd_ok' });\n\t\t\t\t\tconst send_error = (message, stack) => send_reply({ action: 'cmd_error', message, stack });\n\n\t\t\t\t\tif (action === 'eval') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst { script } = ev.data.args;\n\t\t\t\t\t\t\teval(script);\n\t\t\t\t\t\t\tsend_ok();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tsend_error(e.message, e.stack);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (action === 'catch_clicks') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst top_origin = ev.origin;\n\t\t\t\t\t\t\tdocument.body.addEventListener('click', event => {\n\t\t\t\t\t\t\t\tif (event.which !== 1) return;\n\t\t\t\t\t\t\t\tif (event.metaKey || event.ctrlKey || event.shiftKey) return;\n\t\t\t\t\t\t\t\tif (event.defaultPrevented) return;\n\n\t\t\t\t\t\t\t\t// ensure target is a link\n\t\t\t\t\t\t\t\tlet el = event.target;\n\t\t\t\t\t\t\t\twhile (el && el.nodeName !== 'A') el = el.parentNode;\n\t\t\t\t\t\t\t\tif (!el || el.nodeName !== 'A') return;\n\n\t\t\t\t\t\t\t\tif (el.hasAttribute('download') || el.getAttribute('rel') === 'external' || el.target) return;\n\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t\t\t\tif (el.href.startsWith(top_origin)) {\n\t\t\t\t\t\t\t\t\tconst url = new URL(el.href);\n\t\t\t\t\t\t\t\t\tif (url.hash[0] === '#') {\n\t\t\t\t\t\t\t\t\t\twindow.location.hash = url.hash;\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twindow.open(el.href, '_blank');\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tsend_ok();\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\tsend_error(e.message, e.stack);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener('message', handle_message, false);\n\n\t\t\t\twindow.onerror = function (msg, url, lineNo, columnNo, error) {\n\t\t\t\t\tparent.postMessage({ action: 'error', value: error }, '*');\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener(\"unhandledrejection\", event => {\n\t\t\t\t\tparent.postMessage({ action: 'unhandledrejection', value: event.reason }, '*');\n\t\t\t\t});\n\t\t\t}).call(this);\n\n\t\t\t// TODO handle group/groupEnd, table, trace, etc\n\t\t\tlet previous = { level: null, args: null };\n\n\t\t\t['clear', 'log', 'info', 'dir', 'warn', 'error'].forEach((level) => {\n\t\t\t\tconst original = console[level];\n\t\t\t\tconsole[level] = (...args) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tprevious.level === level &&\n\t\t\t\t\t\tprevious.args.length === args.length &&\n\t\t\t\t\t\tprevious.args.every((a, i) => a === args[i])\n\t\t\t\t\t) {\n\t\t\t\t\t\tparent.postMessage({ action: 'console', level, duplicate: true }, '*');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprevious = { level, args };\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tparent.postMessage({ action: 'console', level, args }, '*');\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tparent.postMessage({ action: 'console', level: 'unclonable' }, '*');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\toriginal(...args);\n\t\t\t\t}\n\t\t\t})\n\t\t</script>\n\t</head>\n\t<body></body>\n</html>";

/* node_modules\@sveltejs\svelte-repl\src\Output\Viewer.svelte generated by Svelte v3.12.0 */
const { console: console_1$1 } = globals;

const file$d = "node_modules\\@sveltejs\\svelte-repl\\src\\Output\\Viewer.svelte";

// (206:2) <div slot="main">
function create_main_slot(ctx) {
	var div, iframe_1, iframe_1_sandbox_value, iframe_1_class_value;

	const block = {
		c: function create() {
			div = element("div");
			iframe_1 = element("iframe");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true }, false);
			var div_nodes = children(div);

			iframe_1 = claim_element(div_nodes, "IFRAME", { title: true, sandbox: true, class: true, srcdoc: true }, false);
			var iframe_1_nodes = children(iframe_1);

			iframe_1_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(iframe_1, "title", "Result");
			attr_dev(iframe_1, "sandbox", iframe_1_sandbox_value = "allow-popups-to-escape-sandbox allow-scripts allow-popups allow-forms allow-pointer-lock allow-top-navigation allow-modals " + (ctx.relaxed ? 'allow-same-origin' : ''));
			attr_dev(iframe_1, "class", iframe_1_class_value = "" + null_to_empty((ctx.error || pending || ctx.pending_imports ? 'greyed-out' : '')) + " svelte-ivx2cg");
			attr_dev(iframe_1, "srcdoc", srcdoc);
			toggle_class(iframe_1, "inited", ctx.inited);
			add_location(iframe_1, file$d, 206, 3, 3990);
			attr_dev(div, "slot", "main");
			add_location(div, file$d, 205, 2, 3969);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, iframe_1);
			ctx.iframe_1_binding(iframe_1);
		},

		p: function update(changed, ctx) {
			if ((changed.relaxed) && iframe_1_sandbox_value !== (iframe_1_sandbox_value = "allow-popups-to-escape-sandbox allow-scripts allow-popups allow-forms allow-pointer-lock allow-top-navigation allow-modals " + (ctx.relaxed ? 'allow-same-origin' : ''))) {
				attr_dev(iframe_1, "sandbox", iframe_1_sandbox_value);
			}

			if ((changed.error || changed.pending_imports) && iframe_1_class_value !== (iframe_1_class_value = "" + null_to_empty((ctx.error || pending || ctx.pending_imports ? 'greyed-out' : '')) + " svelte-ivx2cg")) {
				attr_dev(iframe_1, "class", iframe_1_class_value);
			}

			if ((changed.error || changed.pending_imports || changed.inited)) {
				toggle_class(iframe_1, "inited", ctx.inited);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			ctx.iframe_1_binding(null);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_main_slot.name, type: "slot", source: "(206:2) <div slot=\"main\">", ctx });
	return block;
}

// (219:4) {#if (logs.length > 0)}
function create_if_block_2$6(ctx) {
	var t0, t1_value = ctx.logs.length + "", t1, t2;

	const block = {
		c: function create() {
			t0 = text("(");
			t1 = text(t1_value);
			t2 = text(")");
		},

		l: function claim(nodes) {
			t0 = claim_text(nodes, "(");
			t1 = claim_text(nodes, t1_value);
			t2 = claim_text(nodes, ")");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, t2, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.logs) && t1_value !== (t1_value = ctx.logs.length + "")) {
				set_data_dev(t1, t1_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
				detach_dev(t2);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2$6.name, type: "if", source: "(219:4) {#if (logs.length > 0)}", ctx });
	return block;
}

// (217:2) <div slot="panel-header">
function create_panel_header_slot(ctx) {
	var div, button, t, dispose;

	var if_block = ((ctx.logs.length > 0)) && create_if_block_2$6(ctx);

	const block = {
		c: function create() {
			div = element("div");
			button = element("button");
			if (if_block) if_block.c();
			t = text("\n\t\t\t\tClear");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true }, false);
			var div_nodes = children(div);

			button = claim_element(div_nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			if (if_block) if_block.l(button_nodes);
			t = claim_text(button_nodes, "\n\t\t\t\tClear");
			button_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(button, "class", "svelte-ivx2cg");
			add_location(button, file$d, 217, 3, 4369);
			attr_dev(div, "slot", "panel-header");
			add_location(div, file$d, 216, 2, 4340);
			dispose = listen_dev(button, "click", stop_propagation(ctx.clear_logs), false, false, true);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, button);
			if (if_block) if_block.m(button, null);
			append_dev(button, t);
		},

		p: function update(changed, ctx) {
			if ((ctx.logs.length > 0)) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block_2$6(ctx);
					if_block.c();
					if_block.m(button, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block) if_block.d();
			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_panel_header_slot.name, type: "slot", source: "(217:2) <div slot=\"panel-header\">", ctx });
	return block;
}

// (224:2) <section slot="panel-body">
function create_panel_body_slot(ctx) {
	var section, current;

	var console = new Console({
		props: { logs: ctx.logs },
		$$inline: true
	});
	console.$on("clear", ctx.clear_logs);

	const block = {
		c: function create() {
			section = element("section");
			console.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true }, false);
			var section_nodes = children(section);

			console.$$.fragment.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(section, "slot", "panel-body");
			add_location(section, file$d, 223, 2, 4499);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(console, section, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var console_changes = {};
			if (changed.logs) console_changes.logs = ctx.logs;
			console.$set(console_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(console.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(console.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			destroy_component(console);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_panel_body_slot.name, type: "slot", source: "(224:2) <section slot=\"panel-body\">", ctx });
	return block;
}

// (205:1) <PaneWithPanel pos={100} panel="Console">
function create_default_slot_1(ctx) {
	var t0, t1;

	const block = {
		c: function create() {
			t0 = space();
			t1 = space();
		},

		l: function claim(nodes) {
			t0 = claim_space(nodes);
			t1 = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(t1);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_1.name, type: "slot", source: "(205:1) <PaneWithPanel pos={100} panel=\"Console\">", ctx });
	return block;
}

// (232:31) 
function create_if_block_1$7(ctx) {
	var current;

	var message = new Message({
		props: {
		kind: "info",
		truncate: true,
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			message.$$.fragment.c();
		},

		l: function claim(nodes) {
			message.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(message, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var message_changes = {};
			if (changed.$$scope || changed.status) message_changes.$$scope = { changed, ctx };
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(message, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$7.name, type: "if", source: "(232:31) ", ctx });
	return block;
}

// (230:2) {#if error}
function create_if_block$a(ctx) {
	var current;

	var message = new Message({
		props: { kind: "error", details: ctx.error },
		$$inline: true
	});

	const block = {
		c: function create() {
			message.$$.fragment.c();
		},

		l: function claim(nodes) {
			message.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(message, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var message_changes = {};
			if (changed.error) message_changes.details = ctx.error;
			message.$set(message_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(message.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(message.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(message, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$a.name, type: "if", source: "(230:2) {#if error}", ctx });
	return block;
}

// (233:3) <Message kind="info" truncate>
function create_default_slot$2(ctx) {
	var t_value = ctx.status || 'loading Svelte compiler...' + "", t;

	const block = {
		c: function create() {
			t = text(t_value);
		},

		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.status) && t_value !== (t_value = ctx.status || 'loading Svelte compiler...' + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$2.name, type: "slot", source: "(233:3) <Message kind=\"info\" truncate>", ctx });
	return block;
}

function create_fragment$j(ctx) {
	var div1, t, div0, current_block_type_index, if_block, current;

	var panewithpanel = new PaneWithPanel({
		props: {
		pos: 100,
		panel: "Console",
		$$slots: {
		default: [create_default_slot_1],
		"panel-body": [create_panel_body_slot],
		"panel-header": [create_panel_header_slot],
		main: [create_main_slot]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	var if_block_creators = [
		create_if_block$a,
		create_if_block_1$7
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.error) return 0;
		if (ctx.status || !ctx.$bundle) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(null, ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			panewithpanel.$$.fragment.c();
			t = space();
			div0 = element("div");
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			panewithpanel.$$.fragment.l(div1_nodes);
			t = claim_space(div1_nodes);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			if (if_block) if_block.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "overlay svelte-ivx2cg");
			add_location(div0, file$d, 228, 1, 4603);
			attr_dev(div1, "class", "iframe-container svelte-ivx2cg");
			add_location(div1, file$d, 203, 0, 3893);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(panewithpanel, div1, null);
			append_dev(div1, t);
			append_dev(div1, div0);
			if (~current_block_type_index) if_blocks[current_block_type_index].m(div0, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var panewithpanel_changes = {};
			if (changed.$$scope || changed.logs || changed.relaxed || changed.error || changed.pending_imports || changed.iframe || changed.inited) panewithpanel_changes.$$scope = { changed, ctx };
			panewithpanel.$set(panewithpanel_changes);

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				if (if_block) {
					group_outros();
					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});
					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}
					transition_in(if_block, 1);
					if_block.m(div0, null);
				} else {
					if_block = null;
				}
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(panewithpanel.$$.fragment, local);

			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(panewithpanel.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			destroy_component(panewithpanel);

			if (~current_block_type_index) if_blocks[current_block_type_index].d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$j.name, type: "component", source: "", ctx });
	return block;
}

let pending = false;

function instance$j($$self, $$props, $$invalidate) {
	let $bundle;

	

	const { bundle } = getContext('REPL'); validate_store(bundle, 'bundle'); component_subscribe($$self, bundle, $$value => { $bundle = $$value; $$invalidate('$bundle', $bundle); });

	let { error } = $$props; // TODO should this be exposed as a prop?
	let logs = [];

	function setProp(prop, value) {
		if (!proxy) return;
		proxy.setProp(prop, value);
	}

	let { status, relaxed = false, injectedJS = '', injectedCSS = '' } = $$props;

	let iframe;
	let pending_imports = 0;

	let proxy = null;

	let ready = false;
	let inited = false;

	let log_height = 90;
	let prev_height;

	let last_console_event;

	onMount(() => {
		proxy = new ReplProxy(iframe, {
			on_fetch_progress: progress => {
				$$invalidate('pending_imports', pending_imports = progress);
			},
			on_error: event => {
				push_logs({ level: 'error', args: [event.value]});
			},
			on_unhandled_rejection: event => {
				let error = event.value;
				if (typeof error === 'string') error = { message: error };
				error.message = 'Uncaught (in promise): ' + error.message;
				push_logs({ level: 'error', args: [error]});
			},
			on_console: log => {
				if (log.level === 'clear') {
					$$invalidate('logs', logs = [log]);
				} else if (log.duplicate) {
					const last_log = logs[logs.length - 1];

					if (last_log) {
						last_log.count = (last_log.count || 1) + 1;
						$$invalidate('logs', logs);
					} else {
						last_console_event.count = 1;
						$$invalidate('logs', logs = [last_console_event]);
					}
				} else {
					push_logs(log);
					last_console_event = log;
				}
			}
		});

		iframe.addEventListener('load', () => {
			proxy.handle_links();
			$$invalidate('ready', ready = true);
		});


		return () => {
			proxy.destroy();
		}
	});

	async function apply_bundle($bundle) {
		if (!$bundle || $bundle.error) return;

		try {
			clear_logs();

			await proxy.eval(`
				${injectedJS}

				${styles}

				const styles = document.querySelectorAll('style[id^=svelte-]');

				${$bundle.dom.code}

				let i = styles.length;
				while (i--) styles[i].parentNode.removeChild(styles[i]);

				if (window.component) {
					try {
						window.component.$destroy();
					} catch (err) {
						console.error(err);
					}
				}

				document.body.innerHTML = '';
				window.location.hash = '';
				window._svelteTransitionManager = null;

				window.component = new SvelteComponent.default({
					target: document.body
				});
			`);

			$$invalidate('error', error = null);
		} catch (e) {
			show_error(e);
		}

		$$invalidate('inited', inited = true);
	}

	function show_error(e) {
		const loc = getLocationFromStack(e.stack, $bundle.dom.map);
		if (loc) {
			e.filename = loc.source;
			e.loc = { line: loc.line, column: loc.column };
		}

		$$invalidate('error', error = e);
	}

	function push_logs(log) {
		$$invalidate('logs', logs = [...logs, log]);
	}

	function clear_logs() {
		$$invalidate('logs', logs = []);
	}

	const writable_props = ['error', 'status', 'relaxed', 'injectedJS', 'injectedCSS'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$1.warn(`<Viewer> was created with unknown prop '${key}'`);
	});

	function iframe_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('iframe', iframe = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
	};

	$$self.$capture_state = () => {
		return { error, logs, status, relaxed, injectedJS, injectedCSS, iframe, pending_imports, pending, proxy, ready, inited, log_height, prev_height, last_console_event, styles, $bundle };
	};

	$$self.$inject_state = $$props => {
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
		if ('logs' in $$props) $$invalidate('logs', logs = $$props.logs);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
		if ('iframe' in $$props) $$invalidate('iframe', iframe = $$props.iframe);
		if ('pending_imports' in $$props) $$invalidate('pending_imports', pending_imports = $$props.pending_imports);
		if ('pending' in $$props) $$invalidate('pending', pending = $$props.pending);
		if ('proxy' in $$props) proxy = $$props.proxy;
		if ('ready' in $$props) $$invalidate('ready', ready = $$props.ready);
		if ('inited' in $$props) $$invalidate('inited', inited = $$props.inited);
		if ('log_height' in $$props) log_height = $$props.log_height;
		if ('prev_height' in $$props) prev_height = $$props.prev_height;
		if ('last_console_event' in $$props) last_console_event = $$props.last_console_event;
		if ('styles' in $$props) styles = $$props.styles;
		if ('$bundle' in $$props) bundle.set($bundle);
	};

	let styles;

	$$self.$$.update = ($$dirty = { ready: 1, $bundle: 1, injectedCSS: 1 }) => {
		if ($$dirty.ready || $$dirty.$bundle) { if (ready) apply_bundle($bundle); }
		if ($$dirty.injectedCSS) { styles = injectedCSS && `{
		const style = document.createElement('style');
		style.textContent = ${JSON.stringify(injectedCSS)};
		document.head.appendChild(style);
	}`; }
	};

	return {
		bundle,
		error,
		logs,
		setProp,
		status,
		relaxed,
		injectedJS,
		injectedCSS,
		iframe,
		pending_imports,
		inited,
		clear_logs,
		$bundle,
		iframe_1_binding
	};
}

class Viewer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$j, safe_not_equal, ["error", "setProp", "status", "relaxed", "injectedJS", "injectedCSS"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Viewer", options, id: create_fragment$j.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.error === undefined && !('error' in props)) {
			console_1$1.warn("<Viewer> was created without expected prop 'error'");
		}
		if (ctx.setProp === undefined && !('setProp' in props)) {
			console_1$1.warn("<Viewer> was created without expected prop 'setProp'");
		}
		if (ctx.status === undefined && !('status' in props)) {
			console_1$1.warn("<Viewer> was created without expected prop 'status'");
		}
	}

	get error() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setProp() {
		return this.$$.ctx.setProp;
	}

	set setProp(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get status() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get relaxed() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set relaxed(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedJS() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedJS(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedCSS() {
		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedCSS(value) {
		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Output\CompilerOptions.svelte generated by Svelte v3.12.0 */

const file$e = "node_modules\\@sveltejs\\svelte-repl\\src\\Output\\CompilerOptions.svelte";

function create_fragment$k(ctx) {
	var div1, t0, div0, span0, t1, t2, input0, t3, label0, span1, t4, t5, input1, t6, label1, span2, t7, t8, t9, label2, span3, t10, t11, input2, t12, span4, t13_value = ctx.$compile_options.dev + "", t13, t14, t15, label3, span5, t16, t17, input3, t18, span6, t19_value = ctx.$compile_options.css + "", t19, t20, t21, label4, span7, t22, t23, input4, t24, span8, t25_value = ctx.$compile_options.hydratable + "", t25, t26, t27, label5, span9, t28, t29, input5, t30, span10, t31_value = ctx.$compile_options.customElement + "", t31, t32, t33, label6, span11, t34, t35, input6, t36, span12, t37_value = ctx.$compile_options.immutable + "", t37, t38, t39, label7, span13, t40, t41, input7, t42, span14, t43_value = ctx.$compile_options.legacy + "", t43, t44, dispose;

	const block = {
		c: function create() {
			div1 = element("div");
			t0 = text("result = svelte.compile(source, {\n\t");
			div0 = element("div");
			span0 = element("span");
			t1 = text("generate:");
			t2 = space();
			input0 = element("input");
			t3 = space();
			label0 = element("label");
			span1 = element("span");
			t4 = text("\"dom\"");
			t5 = space();
			input1 = element("input");
			t6 = space();
			label1 = element("label");
			span2 = element("span");
			t7 = text("\"ssr\"");
			t8 = text(",");
			t9 = space();
			label2 = element("label");
			span3 = element("span");
			t10 = text("dev:");
			t11 = space();
			input2 = element("input");
			t12 = space();
			span4 = element("span");
			t13 = text(t13_value);
			t14 = text(",");
			t15 = space();
			label3 = element("label");
			span5 = element("span");
			t16 = text("css:");
			t17 = space();
			input3 = element("input");
			t18 = space();
			span6 = element("span");
			t19 = text(t19_value);
			t20 = text(",");
			t21 = space();
			label4 = element("label");
			span7 = element("span");
			t22 = text("hydratable:");
			t23 = space();
			input4 = element("input");
			t24 = space();
			span8 = element("span");
			t25 = text(t25_value);
			t26 = text(",");
			t27 = space();
			label5 = element("label");
			span9 = element("span");
			t28 = text("customElement:");
			t29 = space();
			input5 = element("input");
			t30 = space();
			span10 = element("span");
			t31 = text(t31_value);
			t32 = text(",");
			t33 = space();
			label6 = element("label");
			span11 = element("span");
			t34 = text("immutable:");
			t35 = space();
			input6 = element("input");
			t36 = space();
			span12 = element("span");
			t37 = text(t37_value);
			t38 = text(",");
			t39 = space();
			label7 = element("label");
			span13 = element("span");
			t40 = text("legacy:");
			t41 = space();
			input7 = element("input");
			t42 = space();
			span14 = element("span");
			t43 = text(t43_value);
			t44 = text("\n\t});");
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			t0 = claim_text(div1_nodes, "result = svelte.compile(source, {\n\t");

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			span0 = claim_element(div0_nodes, "SPAN", { class: true }, false);
			var span0_nodes = children(span0);

			t1 = claim_text(span0_nodes, "generate:");
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);

			input0 = claim_element(div0_nodes, "INPUT", { id: true, type: true, value: true, class: true }, false);
			var input0_nodes = children(input0);

			input0_nodes.forEach(detach_dev);
			t3 = claim_space(div0_nodes);

			label0 = claim_element(div0_nodes, "LABEL", { for: true, class: true }, false);
			var label0_nodes = children(label0);

			span1 = claim_element(label0_nodes, "SPAN", { class: true }, false);
			var span1_nodes = children(span1);

			t4 = claim_text(span1_nodes, "\"dom\"");
			span1_nodes.forEach(detach_dev);
			label0_nodes.forEach(detach_dev);
			t5 = claim_space(div0_nodes);

			input1 = claim_element(div0_nodes, "INPUT", { id: true, type: true, value: true, class: true }, false);
			var input1_nodes = children(input1);

			input1_nodes.forEach(detach_dev);
			t6 = claim_space(div0_nodes);

			label1 = claim_element(div0_nodes, "LABEL", { for: true, class: true }, false);
			var label1_nodes = children(label1);

			span2 = claim_element(label1_nodes, "SPAN", { class: true }, false);
			var span2_nodes = children(span2);

			t7 = claim_text(span2_nodes, "\"ssr\"");
			span2_nodes.forEach(detach_dev);
			t8 = claim_text(label1_nodes, ",");
			label1_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t9 = claim_space(div1_nodes);

			label2 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label2_nodes = children(label2);

			span3 = claim_element(label2_nodes, "SPAN", { class: true }, false);
			var span3_nodes = children(span3);

			t10 = claim_text(span3_nodes, "dev:");
			span3_nodes.forEach(detach_dev);
			t11 = claim_space(label2_nodes);

			input2 = claim_element(label2_nodes, "INPUT", { type: true, class: true }, false);
			var input2_nodes = children(input2);

			input2_nodes.forEach(detach_dev);
			t12 = claim_space(label2_nodes);

			span4 = claim_element(label2_nodes, "SPAN", { class: true }, false);
			var span4_nodes = children(span4);

			t13 = claim_text(span4_nodes, t13_value);
			span4_nodes.forEach(detach_dev);
			t14 = claim_text(label2_nodes, ",");
			label2_nodes.forEach(detach_dev);
			t15 = claim_space(div1_nodes);

			label3 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label3_nodes = children(label3);

			span5 = claim_element(label3_nodes, "SPAN", { class: true }, false);
			var span5_nodes = children(span5);

			t16 = claim_text(span5_nodes, "css:");
			span5_nodes.forEach(detach_dev);
			t17 = claim_space(label3_nodes);

			input3 = claim_element(label3_nodes, "INPUT", { type: true, class: true }, false);
			var input3_nodes = children(input3);

			input3_nodes.forEach(detach_dev);
			t18 = claim_space(label3_nodes);

			span6 = claim_element(label3_nodes, "SPAN", { class: true }, false);
			var span6_nodes = children(span6);

			t19 = claim_text(span6_nodes, t19_value);
			span6_nodes.forEach(detach_dev);
			t20 = claim_text(label3_nodes, ",");
			label3_nodes.forEach(detach_dev);
			t21 = claim_space(div1_nodes);

			label4 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label4_nodes = children(label4);

			span7 = claim_element(label4_nodes, "SPAN", { class: true }, false);
			var span7_nodes = children(span7);

			t22 = claim_text(span7_nodes, "hydratable:");
			span7_nodes.forEach(detach_dev);
			t23 = claim_space(label4_nodes);

			input4 = claim_element(label4_nodes, "INPUT", { type: true, class: true }, false);
			var input4_nodes = children(input4);

			input4_nodes.forEach(detach_dev);
			t24 = claim_space(label4_nodes);

			span8 = claim_element(label4_nodes, "SPAN", { class: true }, false);
			var span8_nodes = children(span8);

			t25 = claim_text(span8_nodes, t25_value);
			span8_nodes.forEach(detach_dev);
			t26 = claim_text(label4_nodes, ",");
			label4_nodes.forEach(detach_dev);
			t27 = claim_space(div1_nodes);

			label5 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label5_nodes = children(label5);

			span9 = claim_element(label5_nodes, "SPAN", { class: true }, false);
			var span9_nodes = children(span9);

			t28 = claim_text(span9_nodes, "customElement:");
			span9_nodes.forEach(detach_dev);
			t29 = claim_space(label5_nodes);

			input5 = claim_element(label5_nodes, "INPUT", { type: true, class: true }, false);
			var input5_nodes = children(input5);

			input5_nodes.forEach(detach_dev);
			t30 = claim_space(label5_nodes);

			span10 = claim_element(label5_nodes, "SPAN", { class: true }, false);
			var span10_nodes = children(span10);

			t31 = claim_text(span10_nodes, t31_value);
			span10_nodes.forEach(detach_dev);
			t32 = claim_text(label5_nodes, ",");
			label5_nodes.forEach(detach_dev);
			t33 = claim_space(div1_nodes);

			label6 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label6_nodes = children(label6);

			span11 = claim_element(label6_nodes, "SPAN", { class: true }, false);
			var span11_nodes = children(span11);

			t34 = claim_text(span11_nodes, "immutable:");
			span11_nodes.forEach(detach_dev);
			t35 = claim_space(label6_nodes);

			input6 = claim_element(label6_nodes, "INPUT", { type: true, class: true }, false);
			var input6_nodes = children(input6);

			input6_nodes.forEach(detach_dev);
			t36 = claim_space(label6_nodes);

			span12 = claim_element(label6_nodes, "SPAN", { class: true }, false);
			var span12_nodes = children(span12);

			t37 = claim_text(span12_nodes, t37_value);
			span12_nodes.forEach(detach_dev);
			t38 = claim_text(label6_nodes, ",");
			label6_nodes.forEach(detach_dev);
			t39 = claim_space(div1_nodes);

			label7 = claim_element(div1_nodes, "LABEL", { class: true }, false);
			var label7_nodes = children(label7);

			span13 = claim_element(label7_nodes, "SPAN", { class: true }, false);
			var span13_nodes = children(span13);

			t40 = claim_text(span13_nodes, "legacy:");
			span13_nodes.forEach(detach_dev);
			t41 = claim_space(label7_nodes);

			input7 = claim_element(label7_nodes, "INPUT", { type: true, class: true }, false);
			var input7_nodes = children(input7);

			input7_nodes.forEach(detach_dev);
			t42 = claim_space(label7_nodes);

			span14 = claim_element(label7_nodes, "SPAN", { class: true }, false);
			var span14_nodes = children(span14);

			t43 = claim_text(span14_nodes, t43_value);
			span14_nodes.forEach(detach_dev);
			label7_nodes.forEach(detach_dev);
			t44 = claim_text(div1_nodes, "\n\t});");
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span0, "class", "key svelte-159cly1");
			add_location(span0, file$e, 107, 2, 1829);
			ctx.$$binding_groups[0].push(input0);
			attr_dev(input0, "id", "dom-input");
			attr_dev(input0, "type", "radio");
			input0.__value = "dom";
			input0.value = input0.__value;
			attr_dev(input0, "class", "svelte-159cly1");
			add_location(input0, file$e, 109, 2, 1867);
			attr_dev(span1, "class", "string svelte-159cly1");
			add_location(span1, file$e, 110, 25, 1979);
			attr_dev(label0, "for", "dom-input");
			attr_dev(label0, "class", "svelte-159cly1");
			add_location(label0, file$e, 110, 2, 1956);
			ctx.$$binding_groups[0].push(input1);
			attr_dev(input1, "id", "ssr-input");
			attr_dev(input1, "type", "radio");
			input1.__value = "ssr";
			input1.value = input1.__value;
			attr_dev(input1, "class", "svelte-159cly1");
			add_location(input1, file$e, 112, 2, 2024);
			attr_dev(span2, "class", "string svelte-159cly1");
			add_location(span2, file$e, 113, 25, 2136);
			attr_dev(label1, "for", "ssr-input");
			attr_dev(label1, "class", "svelte-159cly1");
			add_location(label1, file$e, 113, 2, 2113);
			attr_dev(div0, "class", "option svelte-159cly1");
			add_location(div0, file$e, 106, 1, 1806);
			attr_dev(span3, "class", "key svelte-159cly1");
			add_location(span3, file$e, 117, 2, 2214);
			attr_dev(input2, "type", "checkbox");
			attr_dev(input2, "class", "svelte-159cly1");
			add_location(input2, file$e, 118, 2, 2246);
			attr_dev(span4, "class", "boolean svelte-159cly1");
			add_location(span4, file$e, 118, 62, 2306);
			attr_dev(label2, "class", "option svelte-159cly1");
			add_location(label2, file$e, 116, 1, 2189);
			attr_dev(span5, "class", "key svelte-159cly1");
			add_location(span5, file$e, 122, 2, 2396);
			attr_dev(input3, "type", "checkbox");
			attr_dev(input3, "class", "svelte-159cly1");
			add_location(input3, file$e, 123, 2, 2428);
			attr_dev(span6, "class", "boolean svelte-159cly1");
			add_location(span6, file$e, 123, 62, 2488);
			attr_dev(label3, "class", "option svelte-159cly1");
			add_location(label3, file$e, 121, 1, 2371);
			attr_dev(span7, "class", "key svelte-159cly1");
			add_location(span7, file$e, 127, 2, 2578);
			attr_dev(input4, "type", "checkbox");
			attr_dev(input4, "class", "svelte-159cly1");
			add_location(input4, file$e, 128, 2, 2617);
			attr_dev(span8, "class", "boolean svelte-159cly1");
			add_location(span8, file$e, 128, 69, 2684);
			attr_dev(label4, "class", "option svelte-159cly1");
			add_location(label4, file$e, 126, 1, 2553);
			attr_dev(span9, "class", "key svelte-159cly1");
			add_location(span9, file$e, 132, 2, 2781);
			attr_dev(input5, "type", "checkbox");
			attr_dev(input5, "class", "svelte-159cly1");
			add_location(input5, file$e, 133, 2, 2823);
			attr_dev(span10, "class", "boolean svelte-159cly1");
			add_location(span10, file$e, 133, 72, 2893);
			attr_dev(label5, "class", "option svelte-159cly1");
			add_location(label5, file$e, 131, 1, 2756);
			attr_dev(span11, "class", "key svelte-159cly1");
			add_location(span11, file$e, 137, 2, 2993);
			attr_dev(input6, "type", "checkbox");
			attr_dev(input6, "class", "svelte-159cly1");
			add_location(input6, file$e, 138, 2, 3031);
			attr_dev(span12, "class", "boolean svelte-159cly1");
			add_location(span12, file$e, 138, 68, 3097);
			attr_dev(label6, "class", "option svelte-159cly1");
			add_location(label6, file$e, 136, 1, 2968);
			attr_dev(span13, "class", "key svelte-159cly1");
			add_location(span13, file$e, 142, 2, 3193);
			attr_dev(input7, "type", "checkbox");
			attr_dev(input7, "class", "svelte-159cly1");
			add_location(input7, file$e, 143, 2, 3228);
			attr_dev(span14, "class", "boolean svelte-159cly1");
			add_location(span14, file$e, 143, 65, 3291);
			attr_dev(label7, "class", "option svelte-159cly1");
			add_location(label7, file$e, 141, 1, 3168);
			attr_dev(div1, "class", "options svelte-159cly1");
			add_location(div1, file$e, 104, 0, 1743);

			dispose = [
				listen_dev(input0, "change", ctx.input0_change_handler),
				listen_dev(input1, "change", ctx.input1_change_handler),
				listen_dev(input2, "change", ctx.input2_change_handler),
				listen_dev(input3, "change", ctx.input3_change_handler),
				listen_dev(input4, "change", ctx.input4_change_handler),
				listen_dev(input5, "change", ctx.input5_change_handler),
				listen_dev(input6, "change", ctx.input6_change_handler),
				listen_dev(input7, "change", ctx.input7_change_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, span0);
			append_dev(span0, t1);
			append_dev(div0, t2);
			append_dev(div0, input0);

			input0.checked = input0.__value === ctx.$compile_options.generate;

			append_dev(div0, t3);
			append_dev(div0, label0);
			append_dev(label0, span1);
			append_dev(span1, t4);
			append_dev(div0, t5);
			append_dev(div0, input1);

			input1.checked = input1.__value === ctx.$compile_options.generate;

			append_dev(div0, t6);
			append_dev(div0, label1);
			append_dev(label1, span2);
			append_dev(span2, t7);
			append_dev(label1, t8);
			append_dev(div1, t9);
			append_dev(div1, label2);
			append_dev(label2, span3);
			append_dev(span3, t10);
			append_dev(label2, t11);
			append_dev(label2, input2);

			input2.checked = ctx.$compile_options.dev;

			append_dev(label2, t12);
			append_dev(label2, span4);
			append_dev(span4, t13);
			append_dev(label2, t14);
			append_dev(div1, t15);
			append_dev(div1, label3);
			append_dev(label3, span5);
			append_dev(span5, t16);
			append_dev(label3, t17);
			append_dev(label3, input3);

			input3.checked = ctx.$compile_options.css;

			append_dev(label3, t18);
			append_dev(label3, span6);
			append_dev(span6, t19);
			append_dev(label3, t20);
			append_dev(div1, t21);
			append_dev(div1, label4);
			append_dev(label4, span7);
			append_dev(span7, t22);
			append_dev(label4, t23);
			append_dev(label4, input4);

			input4.checked = ctx.$compile_options.hydratable;

			append_dev(label4, t24);
			append_dev(label4, span8);
			append_dev(span8, t25);
			append_dev(label4, t26);
			append_dev(div1, t27);
			append_dev(div1, label5);
			append_dev(label5, span9);
			append_dev(span9, t28);
			append_dev(label5, t29);
			append_dev(label5, input5);

			input5.checked = ctx.$compile_options.customElement;

			append_dev(label5, t30);
			append_dev(label5, span10);
			append_dev(span10, t31);
			append_dev(label5, t32);
			append_dev(div1, t33);
			append_dev(div1, label6);
			append_dev(label6, span11);
			append_dev(span11, t34);
			append_dev(label6, t35);
			append_dev(label6, input6);

			input6.checked = ctx.$compile_options.immutable;

			append_dev(label6, t36);
			append_dev(label6, span12);
			append_dev(span12, t37);
			append_dev(label6, t38);
			append_dev(div1, t39);
			append_dev(div1, label7);
			append_dev(label7, span13);
			append_dev(span13, t40);
			append_dev(label7, t41);
			append_dev(label7, input7);

			input7.checked = ctx.$compile_options.legacy;

			append_dev(label7, t42);
			append_dev(label7, span14);
			append_dev(span14, t43);
			append_dev(div1, t44);
		},

		p: function update(changed, ctx) {
			if (changed.$compile_options) input0.checked = input0.__value === ctx.$compile_options.generate;
			if (changed.$compile_options) input1.checked = input1.__value === ctx.$compile_options.generate;
			if (changed.$compile_options) input2.checked = ctx.$compile_options.dev;

			if ((changed.$compile_options) && t13_value !== (t13_value = ctx.$compile_options.dev + "")) {
				set_data_dev(t13, t13_value);
			}

			if (changed.$compile_options) input3.checked = ctx.$compile_options.css;

			if ((changed.$compile_options) && t19_value !== (t19_value = ctx.$compile_options.css + "")) {
				set_data_dev(t19, t19_value);
			}

			if (changed.$compile_options) input4.checked = ctx.$compile_options.hydratable;

			if ((changed.$compile_options) && t25_value !== (t25_value = ctx.$compile_options.hydratable + "")) {
				set_data_dev(t25, t25_value);
			}

			if (changed.$compile_options) input5.checked = ctx.$compile_options.customElement;

			if ((changed.$compile_options) && t31_value !== (t31_value = ctx.$compile_options.customElement + "")) {
				set_data_dev(t31, t31_value);
			}

			if (changed.$compile_options) input6.checked = ctx.$compile_options.immutable;

			if ((changed.$compile_options) && t37_value !== (t37_value = ctx.$compile_options.immutable + "")) {
				set_data_dev(t37, t37_value);
			}

			if (changed.$compile_options) input7.checked = ctx.$compile_options.legacy;

			if ((changed.$compile_options) && t43_value !== (t43_value = ctx.$compile_options.legacy + "")) {
				set_data_dev(t43, t43_value);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input0), 1);
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input1), 1);
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$k.name, type: "component", source: "", ctx });
	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	let $compile_options;

	const { compile_options } = getContext('REPL'); validate_store(compile_options, 'compile_options'); component_subscribe($$self, compile_options, $$value => { $compile_options = $$value; $$invalidate('$compile_options', $compile_options); });

	const $$binding_groups = [[]];

	function input0_change_handler() {
		compile_options.update($$value => ($$value.generate = this.__value, $$value));
	}

	function input1_change_handler() {
		compile_options.update($$value => ($$value.generate = this.__value, $$value));
	}

	function input2_change_handler() {
		compile_options.update($$value => ($$value.dev = this.checked, $$value));
	}

	function input3_change_handler() {
		compile_options.update($$value => ($$value.css = this.checked, $$value));
	}

	function input4_change_handler() {
		compile_options.update($$value => ($$value.hydratable = this.checked, $$value));
	}

	function input5_change_handler() {
		compile_options.update($$value => ($$value.customElement = this.checked, $$value));
	}

	function input6_change_handler() {
		compile_options.update($$value => ($$value.immutable = this.checked, $$value));
	}

	function input7_change_handler() {
		compile_options.update($$value => ($$value.legacy = this.checked, $$value));
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ('$compile_options' in $$props) compile_options.set($compile_options);
	};

	return {
		compile_options,
		$compile_options,
		input0_change_handler,
		input1_change_handler,
		input2_change_handler,
		input3_change_handler,
		input4_change_handler,
		input5_change_handler,
		input6_change_handler,
		input7_change_handler,
		$$binding_groups
	};
}

class CompilerOptions extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$k, safe_not_equal, []);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "CompilerOptions", options, id: create_fragment$k.name });
	}
}

const workers = new Map();

let uid$1 = 1;

class Compiler {
	constructor(workersUrl, svelteUrl) {
		if (!workers.has(svelteUrl)) {
			const worker = new Worker(`${workersUrl}/compiler.js`);
			worker.postMessage({ type: 'init', svelteUrl });
			workers.set(svelteUrl, worker);
		}

		this.worker = workers.get(svelteUrl);

		this.handlers = new Map();

		this.worker.addEventListener('message', event => {
			const handler = this.handlers.get(event.data.id);

			if (handler) { // if no handler, was meant for a different REPL
				handler(event.data.result);
				this.handlers.delete(event.data.id);
			}
		});
	}

	compile(component, options) {
		return new Promise(fulfil => {
			const id = uid$1++;

			this.handlers.set(id, fulfil);

			this.worker.postMessage({
				id,
				type: 'compile',
				source: component.source,
				options: Object.assign({
					name: component.name,
					filename: `${component.name}.svelte`
				}, options),
				entry: component.name === 'App'
			});
		});
	}

	destroy() {
		this.worker.terminate();
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Output\index.svelte generated by Svelte v3.12.0 */

const file$f = "node_modules\\@sveltejs\\svelte-repl\\src\\Output\\index.svelte";

// (146:1) {:else}
function create_else_block$5(ctx) {
	var current;

	var panewithpanel = new PaneWithPanel({
		props: {
		pos: 67,
		panel: "Compiler options",
		$$slots: {
		default: [create_default_slot$3],
		"panel-body": [create_panel_body_slot$1],
		main: [create_main_slot$1]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			panewithpanel.$$.fragment.c();
		},

		l: function claim(nodes) {
			panewithpanel.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(panewithpanel, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var panewithpanel_changes = {};
			if (changed.$$scope || changed.sourceErrorLoc || changed.js_editor) panewithpanel_changes.$$scope = { changed, ctx };
			panewithpanel.$set(panewithpanel_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(panewithpanel.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(panewithpanel.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(panewithpanel, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$5.name, type: "else", source: "(146:1) {:else}", ctx });
	return block;
}

// (139:1) {#if embedded}
function create_if_block$b(ctx) {
	var current;

	let codemirror_props = {
		mode: "js",
		errorLoc: ctx.sourceErrorLoc,
		readonly: true
	};
	var codemirror = new CodeMirror_1({ props: codemirror_props, $$inline: true });

	ctx.codemirror_binding(codemirror);

	const block = {
		c: function create() {
			codemirror.$$.fragment.c();
		},

		l: function claim(nodes) {
			codemirror.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(codemirror, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var codemirror_changes = {};
			if (changed.sourceErrorLoc) codemirror_changes.errorLoc = ctx.sourceErrorLoc;
			codemirror.$set(codemirror_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(codemirror.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(codemirror.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			ctx.codemirror_binding(null);

			destroy_component(codemirror, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$b.name, type: "if", source: "(139:1) {#if embedded}", ctx });
	return block;
}

// (148:3) <div slot="main">
function create_main_slot$1(ctx) {
	var div, current;

	let codemirror_props = {
		mode: "js",
		errorLoc: ctx.sourceErrorLoc,
		readonly: true
	};
	var codemirror = new CodeMirror_1({ props: codemirror_props, $$inline: true });

	ctx.codemirror_binding_1(codemirror);

	const block = {
		c: function create() {
			div = element("div");
			codemirror.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true, class: true }, false);
			var div_nodes = children(div);

			codemirror.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "slot", "main");
			attr_dev(div, "class", "svelte-1jj4wee");
			add_location(div, file$f, 147, 3, 3238);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(codemirror, div, null);
			current = true;
		},

		p: function update(changed, ctx) {
			var codemirror_changes = {};
			if (changed.sourceErrorLoc) codemirror_changes.errorLoc = ctx.sourceErrorLoc;
			codemirror.$set(codemirror_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(codemirror.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(codemirror.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			ctx.codemirror_binding_1(null);

			destroy_component(codemirror);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_main_slot$1.name, type: "slot", source: "(148:3) <div slot=\"main\">", ctx });
	return block;
}

// (157:3) <div slot="panel-body">
function create_panel_body_slot$1(ctx) {
	var div, current;

	var compileroptions = new CompilerOptions({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			compileroptions.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true, class: true }, false);
			var div_nodes = children(div);

			compileroptions.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "slot", "panel-body");
			attr_dev(div, "class", "svelte-1jj4wee");
			add_location(div, file$f, 156, 3, 3380);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(compileroptions, div, null);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(compileroptions.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(compileroptions.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(compileroptions);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_panel_body_slot$1.name, type: "slot", source: "(157:3) <div slot=\"panel-body\">", ctx });
	return block;
}

// (147:2) <PaneWithPanel pos={67} panel="Compiler options">
function create_default_slot$3(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$3.name, type: "slot", source: "(147:2) <PaneWithPanel pos={67} panel=\"Compiler options\">", ctx });
	return block;
}

function create_fragment$l(ctx) {
	var div0, button0, t0, t1, button1, t2, t3, button2, t4, t5, div1, updating_error, t6, div2, current_block_type_index, if_block, t7, div3, current, dispose;

	function viewer_1_error_binding(value) {
		ctx.viewer_1_error_binding.call(null, value);
		updating_error = true;
		add_flush_callback(() => updating_error = false);
	}

	let viewer_1_props = {
		status: ctx.status,
		relaxed: ctx.relaxed,
		injectedJS: ctx.injectedJS,
		injectedCSS: ctx.injectedCSS
	};
	if (ctx.runtimeError !== void 0) {
		viewer_1_props.error = ctx.runtimeError;
	}
	var viewer_1 = new Viewer({ props: viewer_1_props, $$inline: true });

	ctx.viewer_1_binding(viewer_1);
	binding_callbacks.push(() => bind(viewer_1, 'error', viewer_1_error_binding));

	var if_block_creators = [
		create_if_block$b,
		create_else_block$5
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.embedded) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let codemirror_props = {
		mode: "css",
		errorLoc: ctx.sourceErrorLoc,
		readonly: true
	};
	var codemirror = new CodeMirror_1({ props: codemirror_props, $$inline: true });

	ctx.codemirror_binding_2(codemirror);

	const block = {
		c: function create() {
			div0 = element("div");
			button0 = element("button");
			t0 = text("Result");
			t1 = space();
			button1 = element("button");
			t2 = text("JS output");
			t3 = space();
			button2 = element("button");
			t4 = text("CSS output");
			t5 = space();
			div1 = element("div");
			viewer_1.$$.fragment.c();
			t6 = space();
			div2 = element("div");
			if_block.c();
			t7 = space();
			div3 = element("div");
			codemirror.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			button0 = claim_element(div0_nodes, "BUTTON", { class: true }, false);
			var button0_nodes = children(button0);

			t0 = claim_text(button0_nodes, "Result");
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);

			button1 = claim_element(div0_nodes, "BUTTON", { class: true }, false);
			var button1_nodes = children(button1);

			t2 = claim_text(button1_nodes, "JS output");
			button1_nodes.forEach(detach_dev);
			t3 = claim_space(div0_nodes);

			button2 = claim_element(div0_nodes, "BUTTON", { class: true }, false);
			var button2_nodes = children(button2);

			t4 = claim_text(button2_nodes, "CSS output");
			button2_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);

			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			viewer_1.$$.fragment.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t6 = claim_space(nodes);

			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			if_block.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);

			div3 = claim_element(nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			codemirror.$$.fragment.l(div3_nodes);
			div3_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(button0, "class", "svelte-1jj4wee");
			toggle_class(button0, "active", ctx.view === 'result');
			add_location(button0, file$f, 108, 1, 2466);
			attr_dev(button1, "class", "svelte-1jj4wee");
			toggle_class(button1, "active", ctx.view === 'js');
			add_location(button1, file$f, 113, 1, 2568);
			attr_dev(button2, "class", "svelte-1jj4wee");
			toggle_class(button2, "active", ctx.view === 'css');
			add_location(button2, file$f, 118, 1, 2665);
			attr_dev(div0, "class", "view-toggle svelte-1jj4wee");
			add_location(div0, file$f, 107, 0, 2439);
			attr_dev(div1, "class", "tab-content svelte-1jj4wee");
			toggle_class(div1, "visible", ctx.view === 'result');
			add_location(div1, file$f, 125, 0, 2797);
			attr_dev(div2, "class", "tab-content svelte-1jj4wee");
			toggle_class(div2, "visible", ctx.view === 'js');
			add_location(div2, file$f, 137, 0, 3002);
			attr_dev(div3, "class", "tab-content svelte-1jj4wee");
			toggle_class(div3, "visible", ctx.view === 'css');
			add_location(div3, file$f, 164, 0, 3491);

			dispose = [
				listen_dev(button0, "click", ctx.click_handler),
				listen_dev(button1, "click", ctx.click_handler_1),
				listen_dev(button2, "click", ctx.click_handler_2)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			append_dev(div0, button0);
			append_dev(button0, t0);
			append_dev(div0, t1);
			append_dev(div0, button1);
			append_dev(button1, t2);
			append_dev(div0, t3);
			append_dev(div0, button2);
			append_dev(button2, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, div1, anchor);
			mount_component(viewer_1, div1, null);
			insert_dev(target, t6, anchor);
			insert_dev(target, div2, anchor);
			if_blocks[current_block_type_index].m(div2, null);
			insert_dev(target, t7, anchor);
			insert_dev(target, div3, anchor);
			mount_component(codemirror, div3, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.view) {
				toggle_class(button0, "active", ctx.view === 'result');
				toggle_class(button1, "active", ctx.view === 'js');
				toggle_class(button2, "active", ctx.view === 'css');
			}

			var viewer_1_changes = {};
			if (changed.status) viewer_1_changes.status = ctx.status;
			if (changed.relaxed) viewer_1_changes.relaxed = ctx.relaxed;
			if (changed.injectedJS) viewer_1_changes.injectedJS = ctx.injectedJS;
			if (changed.injectedCSS) viewer_1_changes.injectedCSS = ctx.injectedCSS;
			if (!updating_error && changed.runtimeError) {
				viewer_1_changes.error = ctx.runtimeError;
			}
			viewer_1.$set(viewer_1_changes);

			if (changed.view) {
				toggle_class(div1, "visible", ctx.view === 'result');
			}

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(div2, null);
			}

			if (changed.view) {
				toggle_class(div2, "visible", ctx.view === 'js');
			}

			var codemirror_changes = {};
			if (changed.sourceErrorLoc) codemirror_changes.errorLoc = ctx.sourceErrorLoc;
			codemirror.$set(codemirror_changes);

			if (changed.view) {
				toggle_class(div3, "visible", ctx.view === 'css');
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(viewer_1.$$.fragment, local);

			transition_in(if_block);

			transition_in(codemirror.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(viewer_1.$$.fragment, local);
			transition_out(if_block);
			transition_out(codemirror.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div0);
				detach_dev(t5);
				detach_dev(div1);
			}

			ctx.viewer_1_binding(null);

			destroy_component(viewer_1);

			if (detaching) {
				detach_dev(t6);
				detach_dev(div2);
			}

			if_blocks[current_block_type_index].d();

			if (detaching) {
				detach_dev(t7);
				detach_dev(div3);
			}

			ctx.codemirror_binding_2(null);

			destroy_component(codemirror);

			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$l.name, type: "component", source: "", ctx });
	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	

	const { register_output } = getContext('REPL');

	let { svelteUrl, workersUrl, status, sourceErrorLoc = null, runtimeError = null, embedded = false, relaxed = false, injectedJS, injectedCSS } = $$props;

	let foo; // TODO workaround for https://github.com/sveltejs/svelte/issues/2122

	register_output({
		set: async (selected, options) => {
			if (selected.type === 'js') {
				js_editor.set(`/* Select a component to see its compiled code */`);
				css_editor.set(`/* Select a component to see its compiled code */`);
				return;
			}

			const compiled = await compiler.compile(selected, options);
			if (!js_editor) return; // unmounted

			js_editor.set(compiled.js, 'js');
			css_editor.set(compiled.css, 'css');
		},

		update: async (selected, options) => {
			if (selected.type === 'js') return;

			const compiled = await compiler.compile(selected, options);
			if (!js_editor) return; // unmounted

			js_editor.update(compiled.js);
			css_editor.update(compiled.css);
		}
	});

	const compiler = is_browser && new Compiler(workersUrl, svelteUrl);

	// refs
	let viewer;
	let js_editor;
	let css_editor;

	let view = 'result';

	const writable_props = ['svelteUrl', 'workersUrl', 'status', 'sourceErrorLoc', 'runtimeError', 'embedded', 'relaxed', 'injectedJS', 'injectedCSS'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate('view', view = 'result');

	const click_handler_1 = () => $$invalidate('view', view = 'js');

	const click_handler_2 = () => $$invalidate('view', view = 'css');

	function viewer_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('viewer', viewer = $$value);
		});
	}

	function viewer_1_error_binding(value) {
		runtimeError = value;
		$$invalidate('runtimeError', runtimeError);
	}

	function codemirror_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('js_editor', js_editor = $$value);
		});
	}

	function codemirror_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('js_editor', js_editor = $$value);
		});
	}

	function codemirror_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('css_editor', css_editor = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('svelteUrl' in $$props) $$invalidate('svelteUrl', svelteUrl = $$props.svelteUrl);
		if ('workersUrl' in $$props) $$invalidate('workersUrl', workersUrl = $$props.workersUrl);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('sourceErrorLoc' in $$props) $$invalidate('sourceErrorLoc', sourceErrorLoc = $$props.sourceErrorLoc);
		if ('runtimeError' in $$props) $$invalidate('runtimeError', runtimeError = $$props.runtimeError);
		if ('embedded' in $$props) $$invalidate('embedded', embedded = $$props.embedded);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
	};

	$$self.$capture_state = () => {
		return { svelteUrl, workersUrl, status, sourceErrorLoc, runtimeError, embedded, relaxed, injectedJS, injectedCSS, foo, viewer, js_editor, css_editor, view };
	};

	$$self.$inject_state = $$props => {
		if ('svelteUrl' in $$props) $$invalidate('svelteUrl', svelteUrl = $$props.svelteUrl);
		if ('workersUrl' in $$props) $$invalidate('workersUrl', workersUrl = $$props.workersUrl);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('sourceErrorLoc' in $$props) $$invalidate('sourceErrorLoc', sourceErrorLoc = $$props.sourceErrorLoc);
		if ('runtimeError' in $$props) $$invalidate('runtimeError', runtimeError = $$props.runtimeError);
		if ('embedded' in $$props) $$invalidate('embedded', embedded = $$props.embedded);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
		if ('foo' in $$props) foo = $$props.foo;
		if ('viewer' in $$props) $$invalidate('viewer', viewer = $$props.viewer);
		if ('js_editor' in $$props) $$invalidate('js_editor', js_editor = $$props.js_editor);
		if ('css_editor' in $$props) $$invalidate('css_editor', css_editor = $$props.css_editor);
		if ('view' in $$props) $$invalidate('view', view = $$props.view);
	};

	return {
		svelteUrl,
		workersUrl,
		status,
		sourceErrorLoc,
		runtimeError,
		embedded,
		relaxed,
		injectedJS,
		injectedCSS,
		viewer,
		js_editor,
		css_editor,
		view,
		click_handler,
		click_handler_1,
		click_handler_2,
		viewer_1_binding,
		viewer_1_error_binding,
		codemirror_binding,
		codemirror_binding_1,
		codemirror_binding_2
	};
}

class Index$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$l, create_fragment$l, safe_not_equal, ["svelteUrl", "workersUrl", "status", "sourceErrorLoc", "runtimeError", "embedded", "relaxed", "injectedJS", "injectedCSS"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$l.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.svelteUrl === undefined && !('svelteUrl' in props)) {
			console.warn("<Index> was created without expected prop 'svelteUrl'");
		}
		if (ctx.workersUrl === undefined && !('workersUrl' in props)) {
			console.warn("<Index> was created without expected prop 'workersUrl'");
		}
		if (ctx.status === undefined && !('status' in props)) {
			console.warn("<Index> was created without expected prop 'status'");
		}
		if (ctx.injectedJS === undefined && !('injectedJS' in props)) {
			console.warn("<Index> was created without expected prop 'injectedJS'");
		}
		if (ctx.injectedCSS === undefined && !('injectedCSS' in props)) {
			console.warn("<Index> was created without expected prop 'injectedCSS'");
		}
	}

	get svelteUrl() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set svelteUrl(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get workersUrl() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set workersUrl(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get status() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sourceErrorLoc() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sourceErrorLoc(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get runtimeError() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set runtimeError(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get embedded() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set embedded(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get relaxed() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set relaxed(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedJS() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedJS(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedCSS() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedCSS(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const workers$1 = new Map();

let uid$2 = 1;

class Bundler {
	constructor({ workersUrl, packagesUrl, svelteUrl, onstatus }) {
		const hash = `${packagesUrl}:${svelteUrl}`;

		if (!workers$1.has(hash)) {
			const worker = new Worker(`${workersUrl}/bundler.js`);
			worker.postMessage({ type: 'init', packagesUrl, svelteUrl });
			workers$1.set(hash, worker);
		}

		this.worker = workers$1.get(hash);

		this.handlers = new Map();

		this.worker.addEventListener('message', event => {
			const handler = this.handlers.get(event.data.uid);

			if (handler) { // if no handler, was meant for a different REPL
				if (event.data.type === 'status') {
					onstatus(event.data.message);
					return;
				}

				onstatus(null);
				handler(event.data);
				this.handlers.delete(event.data.uid);
			}
		});
	}

	bundle(components) {
		return new Promise(fulfil => {
			this.handlers.set(uid$2, fulfil);

			this.worker.postMessage({
				uid: uid$2,
				type: 'bundle',
				components
			});

			uid$2 += 1;
		});
	}

	destroy() {
		this.worker.terminate();
	}
}

/* node_modules\@sveltejs\svelte-repl\src\Repl.svelte generated by Svelte v3.12.0 */
const { Error: Error_1 } = globals;

const file$g = "node_modules\\@sveltejs\\svelte-repl\\src\\Repl.svelte";

// (217:2) <section slot=a>
function create_a_slot$1(ctx) {
	var section, t, current;

	var componentselector = new ComponentSelector({
		props: { handle_select: ctx.handle_select },
		$$inline: true
	});

	let moduleeditor_props = { errorLoc: ctx.sourceErrorLoc || ctx.runtimeErrorLoc };
	var moduleeditor = new ModuleEditor({
		props: moduleeditor_props,
		$$inline: true
	});

	ctx.moduleeditor_binding(moduleeditor);

	const block = {
		c: function create() {
			section = element("section");
			componentselector.$$.fragment.c();
			t = space();
			moduleeditor.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true }, false);
			var section_nodes = children(section);

			componentselector.$$.fragment.l(section_nodes);
			t = claim_space(section_nodes);
			moduleeditor.$$.fragment.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(section, "slot", "a");
			add_location(section, file$g, 216, 2, 5067);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(componentselector, section, null);
			append_dev(section, t);
			mount_component(moduleeditor, section, null);
			current = true;
		},

		p: function update_1(changed, ctx) {
			var moduleeditor_changes = {};
			moduleeditor.$set(moduleeditor_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(componentselector.$$.fragment, local);

			transition_in(moduleeditor.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(componentselector.$$.fragment, local);
			transition_out(moduleeditor.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			destroy_component(componentselector);

			ctx.moduleeditor_binding(null);

			destroy_component(moduleeditor);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_a_slot$1.name, type: "slot", source: "(217:2) <section slot=a>", ctx });
	return block;
}

// (222:2) <section slot=b style='height: 100%;'>
function create_b_slot$1(ctx) {
	var section, current;

	var output_1 = new Index$1({
		props: {
		svelteUrl: ctx.svelteUrl,
		workersUrl: ctx.workersUrl,
		status: ctx.status,
		embedded: ctx.embedded,
		relaxed: ctx.relaxed,
		injectedJS: ctx.injectedJS,
		injectedCSS: ctx.injectedCSS
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			section = element("section");
			output_1.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true, style: true }, false);
			var section_nodes = children(section);

			output_1.$$.fragment.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(section, "slot", "b");
			set_style(section, "height", "100%");
			add_location(section, file$g, 221, 2, 5224);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(output_1, section, null);
			current = true;
		},

		p: function update_1(changed, ctx) {
			var output_1_changes = {};
			if (changed.svelteUrl) output_1_changes.svelteUrl = ctx.svelteUrl;
			if (changed.workersUrl) output_1_changes.workersUrl = ctx.workersUrl;
			if (changed.status) output_1_changes.status = ctx.status;
			if (changed.embedded) output_1_changes.embedded = ctx.embedded;
			if (changed.relaxed) output_1_changes.relaxed = ctx.relaxed;
			if (changed.injectedJS) output_1_changes.injectedJS = ctx.injectedJS;
			if (changed.injectedCSS) output_1_changes.injectedCSS = ctx.injectedCSS;
			output_1.$set(output_1_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(output_1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(output_1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			destroy_component(output_1);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_b_slot$1.name, type: "slot", source: "(222:2) <section slot=b style='height: 100%;'>", ctx });
	return block;
}

// (212:1) <SplitPane   type="{orientation === 'rows' ? 'vertical' : 'horizontal'}"   pos="{fixed ? fixedPos : orientation === 'rows' ? 50 : 60}"   {fixed}  >
function create_default_slot$4(ctx) {
	var t;

	const block = {
		c: function create() {
			t = space();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$4.name, type: "slot", source: "(212:1) <SplitPane   type=\"{orientation === 'rows' ? 'vertical' : 'horizontal'}\"   pos=\"{fixed ? fixedPos : orientation === 'rows' ? 50 : 60}\"   {fixed}  >", ctx });
	return block;
}

function create_fragment$m(ctx) {
	var div, current;

	var splitpane = new SplitPane({
		props: {
		type: ctx.orientation === 'rows' ? 'vertical' : 'horizontal',
		pos: ctx.fixed ? ctx.fixedPos : ctx.orientation === 'rows' ? 50 : 60,
		fixed: ctx.fixed,
		$$slots: {
		default: [create_default_slot$4],
		b: [create_b_slot$1],
		a: [create_a_slot$1]
	},
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			div = element("div");
			splitpane.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			splitpane.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "container svelte-177xqak");
			toggle_class(div, "orientation", ctx.orientation);
			add_location(div, file$g, 210, 0, 4874);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(splitpane, div, null);
			current = true;
		},

		p: function update_1(changed, ctx) {
			var splitpane_changes = {};
			if (changed.orientation) splitpane_changes.type = ctx.orientation === 'rows' ? 'vertical' : 'horizontal';
			if (changed.fixed || changed.fixedPos || changed.orientation) splitpane_changes.pos = ctx.fixed ? ctx.fixedPos : ctx.orientation === 'rows' ? 50 : 60;
			if (changed.fixed) splitpane_changes.fixed = ctx.fixed;
			if (changed.$$scope || changed.svelteUrl || changed.workersUrl || changed.status || changed.embedded || changed.relaxed || changed.injectedJS || changed.injectedCSS || changed.input) splitpane_changes.$$scope = { changed, ctx };
			splitpane.$set(splitpane_changes);

			if (changed.orientation) {
				toggle_class(div, "orientation", ctx.orientation);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(splitpane.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(splitpane.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(splitpane);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$m.name, type: "component", source: "", ctx });
	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let $bundle, $components, $selected, $compile_options;

	

	let { workersUrl, packagesUrl = 'https://unpkg.com', svelteUrl = `${packagesUrl}/svelte`, embedded = false, orientation = 'columns', relaxed = false, fixed = false, fixedPos = 50, injectedJS = '', injectedCSS = '' } = $$props;

	function toJSON() {
		return {
			imports: $bundle.imports,
			components: $components
		};
	}

	async function set(data) {
		components.set(data.components);
		selected.set(data.components[0]);

		rebundle();

		await module_editor_ready;
		await output_ready;

		$$invalidate('injectedCSS', injectedCSS = data.css || '');
		module_editor.set($selected.source, $selected.type);
		output.set($selected, $compile_options);
	}

	function update(data) {
		const { name, type } = $selected || {};

		components.set(data.components);

		const matched_component = data.components.find(file => file.name === name && file.type === type);
		selected.set(matched_component || data.components[0]);

		$$invalidate('injectedCSS', injectedCSS = data.css || '');

		if (matched_component) {
			module_editor.update(matched_component.source);
			output.update(matched_component, $compile_options);
		} else {
			module_editor.set(matched_component.source, matched_component.type);
			output.set(matched_component, $compile_options);
		}
	}

	if (!workersUrl) {
		throw new Error(`You must supply workersUrl prop to <Repl>`);
	}

	const dispatch = createEventDispatcher();

	const components = writable([]); validate_store(components, 'components'); component_subscribe($$self, components, $$value => { $components = $$value; $$invalidate('$components', $components); });
	const selected = writable(null); validate_store(selected, 'selected'); component_subscribe($$self, selected, $$value => { $selected = $$value; $$invalidate('$selected', $selected); });
	const bundle = writable(null); validate_store(bundle, 'bundle'); component_subscribe($$self, bundle, $$value => { $bundle = $$value; $$invalidate('$bundle', $bundle); });

	const compile_options = writable({
		generate: 'dom',
		dev: false,
		css: false,
		hydratable: false,
		customElement: false,
		immutable: false,
		legacy: false
	}); validate_store(compile_options, 'compile_options'); component_subscribe($$self, compile_options, $$value => { $compile_options = $$value; $$invalidate('$compile_options', $compile_options); });

	let module_editor;
	let output;

	let current_token;
	async function rebundle() {
		const token = current_token = {};
		const result = await bundler.bundle($components);
		if (result && token === current_token) bundle.set(result);
	}

	// TODO this is a horrible kludge, written in a panic. fix it
	let fulfil_module_editor_ready;
	let module_editor_ready = new Promise(f => fulfil_module_editor_ready = f);

	let fulfil_output_ready;
	let output_ready = new Promise(f => fulfil_output_ready = f);


	setContext('REPL', {
		components,
		selected,
		bundle,
		compile_options,

		rebundle,

		navigate: item => {
			const match = /^(.+)\.(\w+)$/.exec(item.filename);
			if (!match) return; // ???

			const [, name, type] = match;
			const component = $components.find(c => c.name === name && c.type === type);
			handle_select(component);

			// TODO select the line/column in question
		},

		handle_change: event => {
			selected.update(component => {
				// TODO this is a bit hacky  we're relying on mutability
				// so that updating components works... might be better
				// if a) components had unique IDs, b) we tracked selected
				// *index* rather than component, and c) `selected` was
				// derived from `components` and `index`
				component.source = event.detail.value;
				return component;
			});

			components.update(c => c);

			// recompile selected component
			output.update($selected, $compile_options);

			rebundle();

			dispatch('change', {
				components: $components
			});
		},

		register_module_editor(editor) {
			module_editor = editor;
			fulfil_module_editor_ready();
		},

		register_output(handlers) {
			$$invalidate('output', output = handlers);
			fulfil_output_ready();
		},

		request_focus() {
			module_editor.focus();
		}
	});

	function handle_select(component) {
		selected.set(component);
		module_editor.set(component.source, component.type);
		output.set($selected, $compile_options);
	}

	let input;
	let sourceErrorLoc;
	let runtimeErrorLoc; // TODO refactor this stuff  runtimeErrorLoc is unused
	let status = null;

	const bundler = is_browser && new Bundler({
		workersUrl,
		packagesUrl,
		svelteUrl,
		onstatus: message => {
			$$invalidate('status', status = message);
		}
	});

	const writable_props = ['workersUrl', 'packagesUrl', 'svelteUrl', 'embedded', 'orientation', 'relaxed', 'fixed', 'fixedPos', 'injectedJS', 'injectedCSS'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Repl> was created with unknown prop '${key}'`);
	});

	function moduleeditor_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('input', input = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('workersUrl' in $$props) $$invalidate('workersUrl', workersUrl = $$props.workersUrl);
		if ('packagesUrl' in $$props) $$invalidate('packagesUrl', packagesUrl = $$props.packagesUrl);
		if ('svelteUrl' in $$props) $$invalidate('svelteUrl', svelteUrl = $$props.svelteUrl);
		if ('embedded' in $$props) $$invalidate('embedded', embedded = $$props.embedded);
		if ('orientation' in $$props) $$invalidate('orientation', orientation = $$props.orientation);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('fixed' in $$props) $$invalidate('fixed', fixed = $$props.fixed);
		if ('fixedPos' in $$props) $$invalidate('fixedPos', fixedPos = $$props.fixedPos);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
	};

	$$self.$capture_state = () => {
		return { workersUrl, packagesUrl, svelteUrl, embedded, orientation, relaxed, fixed, fixedPos, injectedJS, injectedCSS, module_editor, output, current_token, fulfil_module_editor_ready, module_editor_ready, fulfil_output_ready, output_ready, input, sourceErrorLoc, runtimeErrorLoc, status, $bundle, $components, $selected, $compile_options };
	};

	$$self.$inject_state = $$props => {
		if ('workersUrl' in $$props) $$invalidate('workersUrl', workersUrl = $$props.workersUrl);
		if ('packagesUrl' in $$props) $$invalidate('packagesUrl', packagesUrl = $$props.packagesUrl);
		if ('svelteUrl' in $$props) $$invalidate('svelteUrl', svelteUrl = $$props.svelteUrl);
		if ('embedded' in $$props) $$invalidate('embedded', embedded = $$props.embedded);
		if ('orientation' in $$props) $$invalidate('orientation', orientation = $$props.orientation);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('fixed' in $$props) $$invalidate('fixed', fixed = $$props.fixed);
		if ('fixedPos' in $$props) $$invalidate('fixedPos', fixedPos = $$props.fixedPos);
		if ('injectedJS' in $$props) $$invalidate('injectedJS', injectedJS = $$props.injectedJS);
		if ('injectedCSS' in $$props) $$invalidate('injectedCSS', injectedCSS = $$props.injectedCSS);
		if ('module_editor' in $$props) module_editor = $$props.module_editor;
		if ('output' in $$props) $$invalidate('output', output = $$props.output);
		if ('current_token' in $$props) current_token = $$props.current_token;
		if ('fulfil_module_editor_ready' in $$props) fulfil_module_editor_ready = $$props.fulfil_module_editor_ready;
		if ('module_editor_ready' in $$props) module_editor_ready = $$props.module_editor_ready;
		if ('fulfil_output_ready' in $$props) fulfil_output_ready = $$props.fulfil_output_ready;
		if ('output_ready' in $$props) output_ready = $$props.output_ready;
		if ('input' in $$props) $$invalidate('input', input = $$props.input);
		if ('sourceErrorLoc' in $$props) $$invalidate('sourceErrorLoc', sourceErrorLoc = $$props.sourceErrorLoc);
		if ('runtimeErrorLoc' in $$props) $$invalidate('runtimeErrorLoc', runtimeErrorLoc = $$props.runtimeErrorLoc);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('$bundle' in $$props) bundle.set($bundle);
		if ('$components' in $$props) components.set($components);
		if ('$selected' in $$props) selected.set($selected);
		if ('$compile_options' in $$props) compile_options.set($compile_options);
	};

	$$self.$$.update = ($$dirty = { output: 1, $selected: 1, $compile_options: 1 }) => {
		if ($$dirty.output || $$dirty.$selected || $$dirty.$compile_options) { if (output && $selected) {
				output.update($selected, $compile_options);
			} }
	};

	return {
		workersUrl,
		packagesUrl,
		svelteUrl,
		embedded,
		orientation,
		relaxed,
		fixed,
		fixedPos,
		injectedJS,
		injectedCSS,
		toJSON,
		set,
		update,
		components,
		selected,
		bundle,
		compile_options,
		handle_select,
		input,
		sourceErrorLoc,
		runtimeErrorLoc,
		status,
		moduleeditor_binding
	};
}

class Repl extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$m, create_fragment$m, safe_not_equal, ["workersUrl", "packagesUrl", "svelteUrl", "embedded", "orientation", "relaxed", "fixed", "fixedPos", "injectedJS", "injectedCSS", "toJSON", "set", "update"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Repl", options, id: create_fragment$m.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.workersUrl === undefined && !('workersUrl' in props)) {
			console.warn("<Repl> was created without expected prop 'workersUrl'");
		}
		if (ctx.toJSON === undefined && !('toJSON' in props)) {
			console.warn("<Repl> was created without expected prop 'toJSON'");
		}
		if (ctx.set === undefined && !('set' in props)) {
			console.warn("<Repl> was created without expected prop 'set'");
		}
		if (ctx.update === undefined && !('update' in props)) {
			console.warn("<Repl> was created without expected prop 'update'");
		}
	}

	get workersUrl() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set workersUrl(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get packagesUrl() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set packagesUrl(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get svelteUrl() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set svelteUrl(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get embedded() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set embedded(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get orientation() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orientation(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get relaxed() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set relaxed(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fixed() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fixed(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fixedPos() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fixedPos(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedJS() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedJS(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get injectedCSS() {
		throw new Error_1("<Repl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set injectedCSS(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toJSON() {
		return this.$$.ctx.toJSON;
	}

	set toJSON(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get set() {
		return this.$$.ctx.set;
	}

	set set(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get update() {
		return this.$$.ctx.update;
	}

	set update(value) {
		throw new Error_1("<Repl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Repl as R };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmVwbC44YTMwN2M3My5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3lvb3RpbHMveW9vdGlscy5lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL1NwbGl0UGFuZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9JbnB1dC9Db21wb25lbnRTZWxlY3Rvci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9lbnYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL2Vhc2luZy9pbmRleC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3RyYW5zaXRpb24vaW5kZXgubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdmVsdGVqcy9zdmVsdGUtcmVwbC9zcmMvTWVzc2FnZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9Db2RlTWlycm9yLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL0lucHV0L01vZHVsZUVkaXRvci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL25vZGVfbW9kdWxlcy9zb3VyY2VtYXAtY29kZWMvZGlzdC9zb3VyY2VtYXAtY29kZWMuZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9PdXRwdXQvZ2V0TG9jYXRpb25Gcm9tU3RhY2suanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL21vdGlvbi9pbmRleC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9PdXRwdXQvUGFuZVdpdGhQYW5lbC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9PdXRwdXQvUmVwbFByb3h5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1qc29uLXRyZWUvc3JjL0pTT05BcnJvdy5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWpzb24tdHJlZS9zcmMvb2JqVHlwZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtanNvbi10cmVlL3NyYy9KU09OS2V5LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtanNvbi10cmVlL3NyYy9jb250ZXh0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1qc29uLXRyZWUvc3JjL0pTT05OZXN0ZWQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1qc29uLXRyZWUvc3JjL0pTT05PYmplY3ROb2RlLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtanNvbi10cmVlL3NyYy9KU09OQXJyYXlOb2RlLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtanNvbi10cmVlL3NyYy9KU09OSXRlcmFibGVBcnJheU5vZGUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1qc29uLXRyZWUvc3JjL3V0aWxzL01hcEVudHJ5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1qc29uLXRyZWUvc3JjL0pTT05JdGVyYWJsZU1hcE5vZGUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1qc29uLXRyZWUvc3JjL0pTT05NYXBFbnRyeU5vZGUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1qc29uLXRyZWUvc3JjL0pTT05WYWx1ZU5vZGUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1qc29uLXRyZWUvc3JjL0Vycm9yTm9kZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWpzb24tdHJlZS9zcmMvSlNPTk5vZGUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1qc29uLXRyZWUvc3JjL2luZGV4LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL091dHB1dC9Db25zb2xlLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL091dHB1dC9zcmNkb2MvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9PdXRwdXQvVmlld2VyLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL091dHB1dC9Db21waWxlck9wdGlvbnMuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdmVsdGVqcy9zdmVsdGUtcmVwbC9zcmMvT3V0cHV0L0NvbXBpbGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdmVsdGVqcy9zdmVsdGUtcmVwbC9zcmMvT3V0cHV0L2luZGV4LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc3ZlbHRlLXJlcGwvc3JjL0J1bmRsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsL3NyYy9SZXBsLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGVmYXVsdF9zb3J0ID0gZnVuY3Rpb24gKGl0ZW0sIG5lZWRsZSkgeyByZXR1cm4gaXRlbSAtIG5lZWRsZTsgfTtcbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnJheSwgc2VhcmNoLCBmbikge1xuICAgIGlmIChmbiA9PT0gdm9pZCAwKSB7IGZuID0gZGVmYXVsdF9zb3J0OyB9XG4gICAgdmFyIGxvdyA9IDA7XG4gICAgdmFyIGhpZ2ggPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHZhciBzb3J0ID0gZm4ubGVuZ3RoID09PSAxXG4gICAgICAgID8gZnVuY3Rpb24gKGl0ZW0sIG5lZWRsZSkgeyByZXR1cm4gZm4oaXRlbSkgLSBzZWFyY2g7IH1cbiAgICAgICAgOiBmbjtcbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgdmFyIGkgPSAoaGlnaCArIGxvdykgPj4gMTtcbiAgICAgICAgdmFyIGQgPSBzb3J0KGFycmF5W2ldLCBzZWFyY2gpO1xuICAgICAgICBpZiAoZCA8IDApIHtcbiAgICAgICAgICAgIGxvdyA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGQgPiAwKSB7XG4gICAgICAgICAgICBoaWdoID0gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLWxvdyAtIDE7XG59XG5cbmZ1bmN0aW9uIHBpY2tSYW5kb20oYXJyYXkpIHtcbiAgICB2YXIgaSA9IH5+KE1hdGgucmFuZG9tKCkgKiBhcnJheS5sZW5ndGgpO1xuICAgIHJldHVybiBhcnJheVtpXTtcbn1cblxuLy8gaHR0cDovL2Jvc3Qub2Nrcy5vcmcvbWlrZS9zaHVmZmxlL1xuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgIHZhciBtID0gYXJyYXkubGVuZ3RoO1xuICAgIC8vIFdoaWxlIHRoZXJlIHJlbWFpbiBlbGVtZW50cyB0byBzaHVmZmxl4oCmXG4gICAgd2hpbGUgKG0gPiAwKSB7XG4gICAgICAgIC8vIFBpY2sgYSByZW1haW5pbmcgZWxlbWVudOKAplxuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG0tLSk7XG4gICAgICAgIC8vIEFuZCBzd2FwIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgICAgdmFyIHQgPSBhcnJheVttXTtcbiAgICAgICAgYXJyYXlbbV0gPSBhcnJheVtpXTtcbiAgICAgICAgYXJyYXlbaV0gPSB0O1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlKG1heCkge1xuICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSA0OyB9XG4gICAgdmFyIGl0ZW1zID0gW107IC8vIFRPRE9cbiAgICB2YXIgcGVuZGluZyA9IDA7XG4gICAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICAgIHZhciBmdWxmaWxfY2xvc2VkO1xuICAgIGZ1bmN0aW9uIGRlcXVldWUoKSB7XG4gICAgICAgIGlmIChwZW5kaW5nID09PSAwICYmIGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGZ1bGZpbF9jbG9zZWQpXG4gICAgICAgICAgICAgICAgZnVsZmlsX2Nsb3NlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZW5kaW5nID49IG1heClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGVuZGluZyArPSAxO1xuICAgICAgICB2YXIgX2EgPSBpdGVtcy5zaGlmdCgpLCBmbiA9IF9hLmZuLCBmdWxmaWwgPSBfYS5mdWxmaWwsIHJlamVjdCA9IF9hLnJlamVjdDtcbiAgICAgICAgdmFyIHByb21pc2UgPSBmbigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bGZpbCwgcmVqZWN0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgZGVxdWV1ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICBwZW5kaW5nIC09IDE7XG4gICAgICAgICAgICBkZXF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVxdWV1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgdG8gYSBjbG9zZWQgcXVldWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbCwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7IGZuOiBmbiwgZnVsZmlsOiBmdWxmaWwsIHJlamVjdDogcmVqZWN0IH0pO1xuICAgICAgICAgICAgICAgIGRlcXVldWUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmdWxmaWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbF9jbG9zZWQgPSBmdWxmaWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTcHJpdGUod2lkdGgsIGhlaWdodCwgZm4pIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZm4oY3R4LCBjYW52YXMpO1xuICAgIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gbnVtIDwgbWluID8gbWluIDogbnVtID4gbWF4ID8gbWF4IDogbnVtO1xufVxuXG5mdW5jdGlvbiByYW5kb20oYSwgYikge1xuICAgIGlmIChiID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogYTtcbiAgICByZXR1cm4gYSArIE1hdGgucmFuZG9tKCkgKiAoYiAtIGEpO1xufVxuXG5mdW5jdGlvbiBsaW5lYXIoZG9tYWluLCByYW5nZSkge1xuICAgIHZhciBkMCA9IGRvbWFpblswXTtcbiAgICB2YXIgcjAgPSByYW5nZVswXTtcbiAgICB2YXIgbSA9IChyYW5nZVsxXSAtIHIwKSAvIChkb21haW5bMV0gLSBkMCk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG51bSkge1xuICAgICAgICByZXR1cm4gcjAgKyAobnVtIC0gZDApICogbTtcbiAgICB9LCB7XG4gICAgICAgIGludmVyc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmVhcihyYW5nZSwgZG9tYWluKTsgfVxuICAgIH0pO1xufVxuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yOTAxMTAyL2hvdy10by1wcmludC1hLW51bWJlci13aXRoLWNvbW1hcy1hcy10aG91c2FuZHMtc2VwYXJhdG9ycy1pbi1qYXZhc2NyaXB0XG5mdW5jdGlvbiBjb21tYXMobnVtKSB7XG4gICAgdmFyIHBhcnRzID0gU3RyaW5nKG51bSkuc3BsaXQoJy4nKTtcbiAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csICcsJyk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbn1cblxuLy8gYXJyYXlcblxuZXhwb3J0IHsgYmluYXJ5U2VhcmNoLCBwaWNrUmFuZG9tLCBzaHVmZmxlLCBxdWV1ZSwgY3JlYXRlU3ByaXRlLCBjbGFtcCwgcmFuZG9tLCBsaW5lYXIgYXMgbGluZWFyU2NhbGUsIGNvbW1hcyB9O1xuIiwiPHNjcmlwdD5cblx0aW1wb3J0ICogYXMgeW9vdGlscyBmcm9tICd5b290aWxzJztcblx0aW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcblxuXHRjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG5cdGV4cG9ydCBsZXQgdHlwZTtcblx0ZXhwb3J0IGxldCBwb3MgPSA1MDtcblx0ZXhwb3J0IGxldCBmaXhlZCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGJ1ZmZlciA9IDQwO1xuXHRleHBvcnQgbGV0IG1pbjtcblx0ZXhwb3J0IGxldCBtYXg7XG5cblx0bGV0IHc7XG5cdGxldCBoO1xuXHQkOiBzaXplID0gdHlwZSA9PT0gJ3ZlcnRpY2FsJyA/IGggOiB3O1xuXG5cdCQ6IG1pbiA9IDEwMCAqIChidWZmZXIgLyBzaXplKTtcblx0JDogbWF4ID0gMTAwIC0gbWluO1xuXHQkOiBwb3MgPSB5b290aWxzLmNsYW1wKHBvcywgbWluLCBtYXgpO1xuXG5cdGNvbnN0IHJlZnMgPSB7fTtcblxuXHRsZXQgZHJhZ2dpbmcgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBzZXRQb3MoZXZlbnQpIHtcblx0XHRjb25zdCB7IHRvcCwgbGVmdCB9ID0gcmVmcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRjb25zdCBweCA9IHR5cGUgPT09ICd2ZXJ0aWNhbCdcblx0XHRcdD8gKGV2ZW50LmNsaWVudFkgLSB0b3ApXG5cdFx0XHQ6IChldmVudC5jbGllbnRYIC0gbGVmdCk7XG5cblx0XHRwb3MgPSAxMDAgKiBweCAvIHNpemU7XG5cdFx0ZGlzcGF0Y2goJ2NoYW5nZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZHJhZyhub2RlLCBjYWxsYmFjaykge1xuXHRcdGNvbnN0IG1vdXNlZG93biA9IGV2ZW50ID0+IHtcblx0XHRcdGlmIChldmVudC53aGljaCAhPT0gMSkgcmV0dXJuO1xuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRkcmFnZ2luZyA9IHRydWU7XG5cblx0XHRcdGNvbnN0IG9ubW91c2V1cCA9ICgpID0+IHtcblx0XHRcdFx0ZHJhZ2dpbmcgPSBmYWxzZTtcblxuXHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgY2FsbGJhY2ssIGZhbHNlKTtcblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbm1vdXNldXAsIGZhbHNlKTtcblx0XHRcdH07XG5cblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBjYWxsYmFjaywgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbm1vdXNldXAsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlZG93biwgZmFsc2UpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRlc3Ryb3koKSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25tb3VzZWRvd24sIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0JDogc2lkZSA9IHR5cGUgPT09ICdob3Jpem9udGFsJyA/ICdsZWZ0JyA6ICd0b3AnO1xuXHQkOiBkaW1lbnNpb24gPSB0eXBlID09PSAnaG9yaXpvbnRhbCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuY29udGFpbmVyIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG5cblx0LnBhbmUge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRmbG9hdDogbGVmdDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0b3ZlcmZsb3c6IGF1dG87XG5cdH1cblxuXHQubW91c2VjYXRjaGVyIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0bGVmdDogMDtcblx0XHR0b3A6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJhY2tncm91bmQ6IHJnYmEoMjU1LDI1NSwyNTUsLjAxKTtcblx0fVxuXG5cdC5kaXZpZGVyIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0ei1pbmRleDogMTA7XG5cdFx0ZGlzcGxheTogbm9uZTtcblx0fVxuXG5cdC5kaXZpZGVyOjphZnRlciB7XG5cdFx0Y29udGVudDogJyc7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdC8qIGJhY2tncm91bmQtY29sb3I6ICNlZWU7ICovXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0fVxuXG5cdC5ob3Jpem9udGFsIHtcblx0XHRwYWRkaW5nOiAwIDhweDtcblx0XHR3aWR0aDogMDtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Y3Vyc29yOiBldy1yZXNpemU7XG5cdH1cblxuXHQuaG9yaXpvbnRhbDo6YWZ0ZXIge1xuXHRcdGxlZnQ6IDhweDtcblx0XHR0b3A6IDA7XG5cdFx0d2lkdGg6IDFweDtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cblxuXHQudmVydGljYWwge1xuXHRcdHBhZGRpbmc6IDhweCAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMDtcblx0XHRjdXJzb3I6IG5zLXJlc2l6ZTtcblx0fVxuXG5cdC52ZXJ0aWNhbDo6YWZ0ZXIge1xuXHRcdHRvcDogOHB4O1xuXHRcdGxlZnQ6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxcHg7XG5cdH1cblxuXHQubGVmdCwgLnJpZ2h0LCAuZGl2aWRlciB7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdH1cblxuXHQubGVmdCwgLnJpZ2h0IHtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0ZmxvYXQ6IGxlZnQ7XG5cdH1cblxuXHQudG9wLCAuYm90dG9tIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdH1cblxuXHQudG9wIHsgdG9wOiAwOyB9XG5cdC5ib3R0b20geyBib3R0b206IDA7IH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJjb250YWluZXJcIiBiaW5kOnRoaXM9e3JlZnMuY29udGFpbmVyfSBiaW5kOmNsaWVudFdpZHRoPXt3fSBiaW5kOmNsaWVudEhlaWdodD17aH0+XG5cdDxkaXYgY2xhc3M9XCJwYW5lXCIgc3R5bGU9XCJ7ZGltZW5zaW9ufToge3Bvc30lO1wiPlxuXHRcdDxzbG90IG5hbWU9XCJhXCI+PC9zbG90PlxuXHQ8L2Rpdj5cblxuXHQ8ZGl2IGNsYXNzPVwicGFuZVwiIHN0eWxlPVwie2RpbWVuc2lvbn06IHsxMDAgLSAocG9zKX0lO1wiPlxuXHRcdDxzbG90IG5hbWU9XCJiXCI+PC9zbG90PlxuXHQ8L2Rpdj5cblxuXHR7I2lmICFmaXhlZH1cblx0XHQ8ZGl2IGNsYXNzPVwie3R5cGV9IGRpdmlkZXJcIiBzdHlsZT1cIntzaWRlfTogY2FsYyh7cG9zfSUgLSA4cHgpXCIgdXNlOmRyYWc9e3NldFBvc30+PC9kaXY+XG5cdHsvaWZ9XG48L2Rpdj5cblxueyNpZiBkcmFnZ2luZ31cblx0PGRpdiBjbGFzcz1cIm1vdXNlY2F0Y2hlclwiPjwvZGl2Plxuey9pZn0iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IGhhbmRsZV9zZWxlY3Q7XG5cblx0Y29uc3QgeyBjb21wb25lbnRzLCBzZWxlY3RlZCwgcmVxdWVzdF9mb2N1cywgcmVidW5kbGUgfSA9IGdldENvbnRleHQoJ1JFUEwnKTtcblxuXHRsZXQgZWRpdGluZyA9IG51bGw7XG5cblx0ZnVuY3Rpb24gc2VsZWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuXHRcdGlmICgkc2VsZWN0ZWQgIT09IGNvbXBvbmVudCkge1xuXHRcdFx0ZWRpdGluZyA9IG51bGw7XG5cdFx0XHRoYW5kbGVfc2VsZWN0KGNvbXBvbmVudCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZWRpdFRhYihjb21wb25lbnQpIHtcblx0XHRpZiAoJHNlbGVjdGVkID09PSBjb21wb25lbnQpIHtcblx0XHRcdGVkaXRpbmcgPSAkc2VsZWN0ZWQ7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2xvc2VFZGl0KCkge1xuXHRcdGNvbnN0IG1hdGNoID0gLyguKylcXC4oc3ZlbHRlfGpzKSQvLmV4ZWMoJHNlbGVjdGVkLm5hbWUpO1xuXHRcdCRzZWxlY3RlZC5uYW1lID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICRzZWxlY3RlZC5uYW1lO1xuXHRcdGlmIChpc0NvbXBvbmVudE5hbWVVc2VkKCRzZWxlY3RlZCkpIHtcblx0XHRcdCRzZWxlY3RlZC5uYW1lID0gJHNlbGVjdGVkLm5hbWUgKyAnXzEnO1xuXHRcdH1cblx0XHRpZiAobWF0Y2ggJiYgbWF0Y2hbMl0pICRzZWxlY3RlZC50eXBlID0gbWF0Y2hbMl07XG5cblxuXHRcdGVkaXRpbmcgPSBudWxsO1xuXG5cdFx0Ly8gcmUtc2VsZWN0LCBpbiBjYXNlIHRoZSB0eXBlIGNoYW5nZWRcblx0XHRoYW5kbGVfc2VsZWN0KCRzZWxlY3RlZCk7XG5cblx0XHRjb21wb25lbnRzID0gY29tcG9uZW50czsgLy8gVE9ETyBuZWNlc3Nhcnk/XG5cblx0XHQvLyBmb2N1cyB0aGUgZWRpdG9yLCBidXQgd2FpdCBhIGJlYXQgKHNvIGtleSBldmVudHMgYXJlbid0IG1pc2RpcmVjdGVkKVxuXHRcdHNldFRpbWVvdXQocmVxdWVzdF9mb2N1cyk7XG5cblx0XHRyZWJ1bmRsZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlKGNvbXBvbmVudCkge1xuXHRcdGxldCByZXN1bHQgPSBjb25maXJtKGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlICR7Y29tcG9uZW50Lm5hbWV9LiR7Y29tcG9uZW50LnR5cGV9P2ApO1xuXG5cdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSAkY29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCk7XG5cblx0XHRcdGlmICh+aW5kZXgpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5zZXQoJGNvbXBvbmVudHMuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdCgkY29tcG9uZW50cy5zbGljZShpbmRleCArIDEpKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgZmluZCBjb21wb25lbnQhIFRoYXQncy4uLiBvZGRgKTtcblx0XHRcdH1cblxuXHRcdFx0aGFuZGxlX3NlbGVjdCgkY29tcG9uZW50c1tpbmRleF0gfHwgJGNvbXBvbmVudHNbJGNvbXBvbmVudHMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNlbGVjdElucHV0KGV2ZW50KSB7XG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRldmVudC50YXJnZXQuc2VsZWN0KCk7XG5cdFx0fSk7XG5cdH1cblxuXHRsZXQgdWlkID0gMTtcblxuXHRmdW5jdGlvbiBhZGROZXcoKSB7XG5cdFx0Y29uc3QgY29tcG9uZW50ID0ge1xuXHRcdFx0bmFtZTogdWlkKysgPyBgQ29tcG9uZW50JHt1aWR9YCA6ICdDb21wb25lbnQxJyxcblx0XHRcdHR5cGU6ICdzdmVsdGUnLFxuXHRcdFx0c291cmNlOiAnJ1xuXHRcdH07XG5cblx0XHRlZGl0aW5nID0gY29tcG9uZW50O1xuXG5cdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHQvLyBUT0RPIHdlIGNhbiBkbyB0aGlzIHdpdGhvdXQgSURzXG5cdFx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb21wb25lbnQubmFtZSkuc2Nyb2xsSW50b1ZpZXcoZmFsc2UpO1xuXHRcdH0pO1xuXG5cdFx0Y29tcG9uZW50cy51cGRhdGUoY29tcG9uZW50cyA9PiBjb21wb25lbnRzLmNvbmNhdChjb21wb25lbnQpKTtcblx0XHRoYW5kbGVfc2VsZWN0KGNvbXBvbmVudCk7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0NvbXBvbmVudE5hbWVVc2VkKGVkaXRpbmcpIHtcblx0XHRyZXR1cm4gJGNvbXBvbmVudHMuZmluZChjb21wb25lbnQgPT4gY29tcG9uZW50ICE9PSBlZGl0aW5nICYmIGNvbXBvbmVudC5uYW1lID09PSBlZGl0aW5nLm5hbWUpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuY29tcG9uZW50LXNlbGVjdG9yIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0fVxuXG5cdC5maWxlLXRhYnMge1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRtYXJnaW46IDA7XG5cdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRvdmVyZmxvdy14OiBhdXRvO1xuXHRcdG92ZXJmbG93LXk6IGhpZGRlbjtcblx0XHRoZWlnaHQ6IDEwZW07XG5cdH1cblxuXHQuZmlsZS10YWJzIC5idXR0b24sIC5maWxlLXRhYnMgYnV0dG9uIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRcdGZvbnQ6IDQwMCAxMnB4LzEuNSB2YXIoLS1mb250KTtcblx0XHRiYWNrZ3JvdW5kOiB3aGl0ZTtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym9yZGVyLWJvdHRvbTogM3B4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRcdHBhZGRpbmc6IDEycHggMTRweCA4cHggOHB4O1xuXHRcdG1hcmdpbjogMDtcblx0XHRjb2xvcjogIzk5OTtcblx0XHRib3JkZXItcmFkaXVzOiAwO1xuXHR9XG5cblx0LmZpbGUtdGFicyAuYnV0dG9uOmZpcnN0LWNoaWxkIHtcblx0XHRwYWRkaW5nLWxlZnQ6IDEycHg7XG5cdH1cblxuXHQuZmlsZS10YWJzIC5idXR0b24uYWN0aXZlIHtcblx0XHQvKiBjb2xvcjogdmFyKC0tc2Vjb25kKTsgKi9cblx0XHRjb2xvcjogIzMzMztcblx0XHRib3JkZXItYm90dG9tOiAzcHggc29saWQgdmFyKC0tcHJpbWUpO1xuXHR9XG5cblx0LmVkaXRhYmxlLCAudW5lZGl0YWJsZSwgLmlucHV0LXNpemVyLCBpbnB1dCB7XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRsaW5lLWhlaWdodDogMTtcblx0fVxuXG5cdC5pbnB1dC1zaXplciB7XG5cdFx0Y29sb3I6ICNjY2M7XG5cdH1cblxuXHRpbnB1dCB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGxlZnQ6IDhweDtcblx0XHR0b3A6IDEycHg7XG5cdFx0Zm9udDogNDAwIDEycHgvMS41IHZhcigtLWZvbnQpO1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRjb2xvcjogdmFyKC0tZmxhc2gpO1xuXHRcdG91dGxpbmU6IG5vbmU7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdH1cblxuXHQuZHVwbGljYXRlIHtcblx0XHRjb2xvcjogdmFyKC0tcHJpbWUpO1xuXHR9XG5cblx0LnJlbW92ZSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdGRpc3BsYXk6IG5vbmU7XG5cdFx0cmlnaHQ6IDFweDtcblx0XHR0b3A6IDRweDtcblx0XHR3aWR0aDogMTZweDtcblx0XHR0ZXh0LWFsaWduOiByaWdodDtcblx0XHRwYWRkaW5nOiAxMnB4IDAgMTJweCA1cHg7XG5cdFx0Zm9udC1zaXplOiA4cHg7XG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHR9XG5cblx0LnJlbW92ZTpob3ZlciB7XG5cdFx0Y29sb3I6IHZhcigtLWZsYXNoKTtcblx0fVxuXG5cdC5maWxlLXRhYnMgLmJ1dHRvbi5hY3RpdmUgLmVkaXRhYmxlIHtcblx0XHRjdXJzb3I6IHRleHQ7XG5cdH1cblxuXHQuZmlsZS10YWJzIC5idXR0b24uYWN0aXZlIC5yZW1vdmUge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHR9XG5cblx0LmFkZC1uZXcge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRsZWZ0OiAwO1xuXHRcdHRvcDogMDtcblx0XHRwYWRkaW5nOiAxMnB4IDEwcHggOHB4IDAgIWltcG9ydGFudDtcblx0XHRoZWlnaHQ6IDQwcHg7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXHR9XG5cblx0LmFkZC1uZXc6aG92ZXIge1xuXHRcdGNvbG9yOiB2YXIoLS1mbGFzaCkgIWltcG9ydGFudDtcblx0fVxuXG5cdHN2ZyB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHQtby1vYmplY3QtZml0OiBjb250YWluO1xuXHRcdG9iamVjdC1maXQ6IGNvbnRhaW47XG5cdFx0LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXIgY2VudGVyO1xuXHRcdHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG5cblx0XHRzdHJva2U6IGN1cnJlbnRDb2xvcjtcblx0XHRzdHJva2Utd2lkdGg6IDI7XG5cdFx0c3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xuXHRcdHN0cm9rZS1saW5lam9pbjogcm91bmQ7XG5cdFx0ZmlsbDogbm9uZTtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImNvbXBvbmVudC1zZWxlY3RvclwiPlxuXHR7I2lmICRjb21wb25lbnRzLmxlbmd0aH1cblx0XHQ8ZGl2IGNsYXNzPVwiZmlsZS10YWJzXCIgb246ZGJsY2xpY2s9XCJ7YWRkTmV3fVwiPlxuXHRcdFx0eyNlYWNoICRjb21wb25lbnRzIGFzIGNvbXBvbmVudCwgaW5kZXh9XG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRpZD17Y29tcG9uZW50Lm5hbWV9XG5cdFx0XHRcdFx0Y2xhc3M9XCJidXR0b25cIlxuXHRcdFx0XHRcdHJvbGU9XCJidXR0b25cIlxuXHRcdFx0XHRcdGNsYXNzOmFjdGl2ZT1cIntjb21wb25lbnQgPT09ICRzZWxlY3RlZH1cIlxuXHRcdFx0XHRcdG9uOmNsaWNrPVwieygpID0+IHNlbGVjdENvbXBvbmVudChjb21wb25lbnQpfVwiXG5cdFx0XHRcdFx0b246ZGJsY2xpY2s9XCJ7ZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpfVwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7I2lmIGNvbXBvbmVudC5uYW1lID09ICdBcHAnICYmIGluZGV4ID09PSAwfVxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cInVuZWRpdGFibGVcIj5cblx0XHRcdFx0XHRcdFx0QXBwLnN2ZWx0ZVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdFx0eyNpZiBjb21wb25lbnQgPT09IGVkaXRpbmd9XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaW5wdXQtc2l6ZXJcIj57ZWRpdGluZy5uYW1lICsgKC9cXC4vLnRlc3QoZWRpdGluZy5uYW1lKSA/ICcnIDogYC4ke2VkaXRpbmcudHlwZX1gKX08L3NwYW4+XG5cblx0XHRcdFx0XHRcdFx0PCEtLSBzdmVsdGUtaWdub3JlIGExMXktYXV0b2ZvY3VzIC0tPlxuXHRcdFx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdFx0XHRhdXRvZm9jdXNcblx0XHRcdFx0XHRcdFx0XHRzcGVsbGNoZWNrPXtmYWxzZX1cblx0XHRcdFx0XHRcdFx0XHRiaW5kOnZhbHVlPXtlZGl0aW5nLm5hbWV9XG5cdFx0XHRcdFx0XHRcdFx0b246Zm9jdXM9e3NlbGVjdElucHV0fVxuXHRcdFx0XHRcdFx0XHRcdG9uOmJsdXI9e2Nsb3NlRWRpdH1cblx0XHRcdFx0XHRcdFx0XHRvbjprZXlkb3duPXtlID0+IGUud2hpY2ggPT09IDEzICYmICFpc0NvbXBvbmVudE5hbWVVc2VkKGVkaXRpbmcpICYmIGUudGFyZ2V0LmJsdXIoKX1cblx0XHRcdFx0XHRcdFx0XHRjbGFzczpkdXBsaWNhdGU9e2lzQ29tcG9uZW50TmFtZVVzZWQoZWRpdGluZyl9XG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzPVwiZWRpdGFibGVcIlxuXHRcdFx0XHRcdFx0XHRcdHRpdGxlPVwiZWRpdCBjb21wb25lbnQgbmFtZVwiXG5cdFx0XHRcdFx0XHRcdFx0b246Y2xpY2s9XCJ7KCkgPT4gZWRpdFRhYihjb21wb25lbnQpfVwiXG5cdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHR7Y29tcG9uZW50Lm5hbWV9Lntjb21wb25lbnQudHlwZX1cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJyZW1vdmVcIiBvbjpjbGljaz1cInsoKSA9PiByZW1vdmUoY29tcG9uZW50KX1cIj5cblx0XHRcdFx0XHRcdFx0XHQ8c3ZnIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCIxMlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cblx0XHRcdFx0XHRcdFx0XHRcdDxsaW5lIHN0cm9rZT1cIiM5OTlcIiB4MT0nMTgnIHkxPSc2JyB4Mj0nNicgeTI9JzE4JyAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGxpbmUgc3Ryb2tlPVwiIzk5OVwiIHgxPSc2JyB5MT0nNicgeDI9JzE4JyB5Mj0nMTgnIC8+XG5cdFx0XHRcdFx0XHRcdFx0PC9zdmc+XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2VhY2h9XG5cblx0XHRcdDxidXR0b24gY2xhc3M9XCJhZGQtbmV3XCIgb246Y2xpY2s9e2FkZE5ld30gdGl0bGU9XCJhZGQgbmV3IGNvbXBvbmVudFwiPlxuXHRcdFx0XHQ8c3ZnIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCIxMlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cblx0XHRcdFx0XHQ8bGluZSBzdHJva2U9XCIjOTk5XCIgeDE9JzEyJyB5MT0nNScgeDI9JzEyJyB5Mj0nMTknIC8+XG5cdFx0XHRcdFx0PGxpbmUgc3Ryb2tlPVwiIzk5OVwiIHgxPSc1JyB5MT0nMTInIHgyPScxOScgeTI9JzEyJyAvPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdDwvZGl2PlxuXHR7L2lmfVxuPC9kaXY+XG4iLCJleHBvcnQgY29uc3QgaXNfYnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnOyIsImV4cG9ydCB7IGlkZW50aXR5IGFzIGxpbmVhciB9IGZyb20gJy4uL2ludGVybmFsJztcblxuLypcbkFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2xcbkRpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9lYXNlcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4qL1xuZnVuY3Rpb24gYmFja0luT3V0KHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgIGlmICgodCAqPSAyKSA8IDEpXG4gICAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSk7XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDIpO1xufVxuZnVuY3Rpb24gYmFja0luKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbn1cbmZ1bmN0aW9uIGJhY2tPdXQodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAtLXQgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xufVxuZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgICBjb25zdCBhID0gNC4wIC8gMTEuMDtcbiAgICBjb25zdCBiID0gOC4wIC8gMTEuMDtcbiAgICBjb25zdCBjID0gOS4wIC8gMTAuMDtcbiAgICBjb25zdCBjYSA9IDQzNTYuMCAvIDM2MS4wO1xuICAgIGNvbnN0IGNiID0gMzU0NDIuMCAvIDE4MDUuMDtcbiAgICBjb25zdCBjYyA9IDE2MDYxLjAgLyAxODA1LjA7XG4gICAgY29uc3QgdDIgPSB0ICogdDtcbiAgICByZXR1cm4gdCA8IGFcbiAgICAgICAgPyA3LjU2MjUgKiB0MlxuICAgICAgICA6IHQgPCBiXG4gICAgICAgICAgICA/IDkuMDc1ICogdDIgLSA5LjkgKiB0ICsgMy40XG4gICAgICAgICAgICA6IHQgPCBjXG4gICAgICAgICAgICAgICAgPyBjYSAqIHQyIC0gY2IgKiB0ICsgY2NcbiAgICAgICAgICAgICAgICA6IDEwLjggKiB0ICogdCAtIDIwLjUyICogdCArIDEwLjcyO1xufVxuZnVuY3Rpb24gYm91bmNlSW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41XG4gICAgICAgID8gMC41ICogKDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0ICogMi4wKSlcbiAgICAgICAgOiAwLjUgKiBib3VuY2VPdXQodCAqIDIuMCAtIDEuMCkgKyAwLjU7XG59XG5mdW5jdGlvbiBib3VuY2VJbih0KSB7XG4gICAgcmV0dXJuIDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0KTtcbn1cbmZ1bmN0aW9uIGNpcmNJbk91dCh0KSB7XG4gICAgaWYgKCh0ICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcbiAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xufVxuZnVuY3Rpb24gY2lyY0luKHQpIHtcbiAgICByZXR1cm4gMS4wIC0gTWF0aC5zcXJ0KDEuMCAtIHQgKiB0KTtcbn1cbmZ1bmN0aW9uIGNpcmNPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tdCAqIHQpO1xufVxuZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyA0LjAgKiB0ICogdCAqIHQgOiAwLjUgKiBNYXRoLnBvdygyLjAgKiB0IC0gMi4wLCAzLjApICsgMS4wO1xufVxuZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgICBjb25zdCBmID0gdCAtIDEuMDtcbiAgICByZXR1cm4gZiAqIGYgKiBmICsgMS4wO1xufVxuZnVuY3Rpb24gZWxhc3RpY0luT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNVxuICAgICAgICA/IDAuNSAqXG4gICAgICAgICAgICBNYXRoLnNpbigoKCsxMy4wICogTWF0aC5QSSkgLyAyKSAqIDIuMCAqIHQpICpcbiAgICAgICAgICAgIE1hdGgucG93KDIuMCwgMTAuMCAqICgyLjAgKiB0IC0gMS4wKSlcbiAgICAgICAgOiAwLjUgKlxuICAgICAgICAgICAgTWF0aC5zaW4oKCgtMTMuMCAqIE1hdGguUEkpIC8gMikgKiAoMi4wICogdCAtIDEuMCArIDEuMCkpICpcbiAgICAgICAgICAgIE1hdGgucG93KDIuMCwgLTEwLjAgKiAoMi4wICogdCAtIDEuMCkpICtcbiAgICAgICAgICAgIDEuMDtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNJbih0KSB7XG4gICAgcmV0dXJuIE1hdGguc2luKCgxMy4wICogdCAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIChNYXRoLnNpbigoLTEzLjAgKiAodCArIDEuMCkgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpICsgMS4wKTtcbn1cbmZ1bmN0aW9uIGV4cG9Jbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPT09IDAuMCB8fCB0ID09PSAxLjBcbiAgICAgICAgPyB0XG4gICAgICAgIDogdCA8IDAuNVxuICAgICAgICAgICAgPyArMC41ICogTWF0aC5wb3coMi4wLCAyMC4wICogdCAtIDEwLjApXG4gICAgICAgICAgICA6IC0wLjUgKiBNYXRoLnBvdygyLjAsIDEwLjAgLSB0ICogMjAuMCkgKyAxLjA7XG59XG5mdW5jdGlvbiBleHBvSW4odCkge1xuICAgIHJldHVybiB0ID09PSAwLjAgPyB0IDogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cbmZ1bmN0aW9uIGV4cG9PdXQodCkge1xuICAgIHJldHVybiB0ID09PSAxLjAgPyB0IDogMS4wIC0gTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpO1xufVxuZnVuY3Rpb24gcXVhZEluT3V0KHQpIHtcbiAgICB0IC89IDAuNTtcbiAgICBpZiAodCA8IDEpXG4gICAgICAgIHJldHVybiAwLjUgKiB0ICogdDtcbiAgICB0LS07XG4gICAgcmV0dXJuIC0wLjUgKiAodCAqICh0IC0gMikgLSAxKTtcbn1cbmZ1bmN0aW9uIHF1YWRJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xufVxuZnVuY3Rpb24gcXVhZE91dCh0KSB7XG4gICAgcmV0dXJuIC10ICogKHQgLSAyLjApO1xufVxuZnVuY3Rpb24gcXVhcnRJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjVcbiAgICAgICAgPyArOC4wICogTWF0aC5wb3codCwgNC4wKVxuICAgICAgICA6IC04LjAgKiBNYXRoLnBvdyh0IC0gMS4wLCA0LjApICsgMS4wO1xufVxuZnVuY3Rpb24gcXVhcnRJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIDQuMCk7XG59XG5mdW5jdGlvbiBxdWFydE91dCh0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQgLSAxLjAsIDMuMCkgKiAoMS4wIC0gdCkgKyAxLjA7XG59XG5mdW5jdGlvbiBxdWludEluT3V0KHQpIHtcbiAgICBpZiAoKHQgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKTtcbn1cbmZ1bmN0aW9uIHF1aW50SW4odCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIHF1aW50T3V0KHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqIHQgKiB0ICogdCArIDE7XG59XG5mdW5jdGlvbiBzaW5lSW5PdXQodCkge1xuICAgIHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xufVxuZnVuY3Rpb24gc2luZUluKHQpIHtcbiAgICBjb25zdCB2ID0gTWF0aC5jb3ModCAqIE1hdGguUEkgKiAwLjUpO1xuICAgIGlmIChNYXRoLmFicyh2KSA8IDFlLTE0KVxuICAgICAgICByZXR1cm4gMTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiAxIC0gdjtcbn1cbmZ1bmN0aW9uIHNpbmVPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnNpbigodCAqIE1hdGguUEkpIC8gMik7XG59XG5cbmV4cG9ydCB7IGJhY2tJbiwgYmFja0luT3V0LCBiYWNrT3V0LCBib3VuY2VJbiwgYm91bmNlSW5PdXQsIGJvdW5jZU91dCwgY2lyY0luLCBjaXJjSW5PdXQsIGNpcmNPdXQsIGN1YmljSW4sIGN1YmljSW5PdXQsIGN1YmljT3V0LCBlbGFzdGljSW4sIGVsYXN0aWNJbk91dCwgZWxhc3RpY091dCwgZXhwb0luLCBleHBvSW5PdXQsIGV4cG9PdXQsIHF1YWRJbiwgcXVhZEluT3V0LCBxdWFkT3V0LCBxdWFydEluLCBxdWFydEluT3V0LCBxdWFydE91dCwgcXVpbnRJbiwgcXVpbnRJbk91dCwgcXVpbnRPdXQsIHNpbmVJbiwgc2luZUluT3V0LCBzaW5lT3V0IH07XG4iLCJpbXBvcnQgeyBjdWJpY0luT3V0LCBjdWJpY091dCB9IGZyb20gJy4uL2Vhc2luZyc7XG5pbXBvcnQgeyBpc19mdW5jdGlvbiwgYXNzaWduIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmZ1bmN0aW9uIGJsdXIobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY0luT3V0LCBhbW91bnQgPSA1LCBvcGFjaXR5ID0gMCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgZiA9IHN0eWxlLmZpbHRlciA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS5maWx0ZXI7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgb3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfTsgZmlsdGVyOiAke2Z9IGJsdXIoJHt1ICogYW1vdW50fXB4KTtgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZhZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwIH0pIHtcbiAgICBjb25zdCBvID0gK2dldENvbXB1dGVkU3R5bGUobm9kZSkub3BhY2l0eTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGNzczogdCA9PiBgb3BhY2l0eTogJHt0ICogb31gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZseShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCB4ID0gMCwgeSA9IDAsIG9wYWNpdHkgPSAwIH0pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHsoMSAtIHQpICogeH1weCwgJHsoMSAtIHQpICogeX1weCk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9YFxuICAgIH07XG59XG5mdW5jdGlvbiBzbGlkZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0IH0pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IGhlaWdodCA9IHBhcnNlRmxvYXQoc3R5bGUuaGVpZ2h0KTtcbiAgICBjb25zdCBwYWRkaW5nX3RvcCA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1RvcCk7XG4gICAgY29uc3QgcGFkZGluZ19ib3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdCb3R0b20pO1xuICAgIGNvbnN0IG1hcmdpbl90b3AgPSBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblRvcCk7XG4gICAgY29uc3QgbWFyZ2luX2JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luQm90dG9tKTtcbiAgICBjb25zdCBib3JkZXJfdG9wX3dpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCk7XG4gICAgY29uc3QgYm9yZGVyX2JvdHRvbV93aWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IHQgPT4gYG92ZXJmbG93OiBoaWRkZW47YCArXG4gICAgICAgICAgICBgb3BhY2l0eTogJHtNYXRoLm1pbih0ICogMjAsIDEpICogb3BhY2l0eX07YCArXG4gICAgICAgICAgICBgaGVpZ2h0OiAke3QgKiBoZWlnaHR9cHg7YCArXG4gICAgICAgICAgICBgcGFkZGluZy10b3A6ICR7dCAqIHBhZGRpbmdfdG9wfXB4O2AgK1xuICAgICAgICAgICAgYHBhZGRpbmctYm90dG9tOiAke3QgKiBwYWRkaW5nX2JvdHRvbX1weDtgICtcbiAgICAgICAgICAgIGBtYXJnaW4tdG9wOiAke3QgKiBtYXJnaW5fdG9wfXB4O2AgK1xuICAgICAgICAgICAgYG1hcmdpbi1ib3R0b206ICR7dCAqIG1hcmdpbl9ib3R0b219cHg7YCArXG4gICAgICAgICAgICBgYm9yZGVyLXRvcC13aWR0aDogJHt0ICogYm9yZGVyX3RvcF93aWR0aH1weDtgICtcbiAgICAgICAgICAgIGBib3JkZXItYm90dG9tLXdpZHRoOiAke3QgKiBib3JkZXJfYm90dG9tX3dpZHRofXB4O2BcbiAgICB9O1xufVxuZnVuY3Rpb24gc2NhbGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgc3RhcnQgPSAwLCBvcGFjaXR5ID0gMCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICBjb25zdCBzZCA9IDEgLSBzdGFydDtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAoX3QsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHNjYWxlKCR7MSAtIChzZCAqIHUpfSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gKG9kICogdSl9XG5cdFx0YFxuICAgIH07XG59XG5mdW5jdGlvbiBkcmF3KG5vZGUsIHsgZGVsYXkgPSAwLCBzcGVlZCwgZHVyYXRpb24sIGVhc2luZyA9IGN1YmljSW5PdXQgfSkge1xuICAgIGNvbnN0IGxlbiA9IG5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICBpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSA4MDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IGxlbiAvIHNwZWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uKGxlbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6ICh0LCB1KSA9PiBgc3Ryb2tlLWRhc2hhcnJheTogJHt0ICogbGVufSAke3UgKiBsZW59YFxuICAgIH07XG59XG5mdW5jdGlvbiBjcm9zc2ZhZGUoX2EpIHtcbiAgICB2YXIgeyBmYWxsYmFjayB9ID0gX2EsIGRlZmF1bHRzID0gX19yZXN0KF9hLCBbXCJmYWxsYmFja1wiXSk7XG4gICAgY29uc3QgdG9fcmVjZWl2ZSA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB0b19zZW5kID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGNyb3NzZmFkZShmcm9tLCBub2RlLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gZCA9PiBNYXRoLnNxcnQoZCkgKiAzMCwgZWFzaW5nID0gY3ViaWNPdXQgfSA9IGFzc2lnbihhc3NpZ24oe30sIGRlZmF1bHRzKSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBkeCA9IGZyb20ubGVmdCAtIHRvLmxlZnQ7XG4gICAgICAgIGNvbnN0IGR5ID0gZnJvbS50b3AgLSB0by50b3A7XG4gICAgICAgIGNvbnN0IGR3ID0gZnJvbS53aWR0aCAvIHRvLndpZHRoO1xuICAgICAgICBjb25zdCBkaCA9IGZyb20uaGVpZ2h0IC8gdG8uaGVpZ2h0O1xuICAgICAgICBjb25zdCBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBpc19mdW5jdGlvbihkdXJhdGlvbikgPyBkdXJhdGlvbihkKSA6IGR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nLFxuICAgICAgICAgICAgY3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0XHRvcGFjaXR5OiAke3QgKiBvcGFjaXR5fTtcblx0XHRcdFx0dHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XG5cdFx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke3UgKiBkeH1weCwke3UgKiBkeX1weCkgc2NhbGUoJHt0ICsgKDEgLSB0KSAqIGR3fSwgJHt0ICsgKDEgLSB0KSAqIGRofSk7XG5cdFx0XHRgXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb24oaXRlbXMsIGNvdW50ZXJwYXJ0cywgaW50cm8pIHtcbiAgICAgICAgcmV0dXJuIChub2RlLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGl0ZW1zLnNldChwYXJhbXMua2V5LCB7XG4gICAgICAgICAgICAgICAgcmVjdDogbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVycGFydHMuaGFzKHBhcmFtcy5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVjdCB9ID0gY291bnRlcnBhcnRzLmdldChwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnBhcnRzLmRlbGV0ZShwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZmFkZShyZWN0LCBub2RlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBpcyBkaXNhcHBlYXJpbmcgYWx0b2dldGhlclxuICAgICAgICAgICAgICAgIC8vIChpLmUuIHdhc24ndCBjbGFpbWVkIGJ5IHRoZSBvdGhlciBsaXN0KVxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBzdXBwbHkgYW4gb3V0cm9cbiAgICAgICAgICAgICAgICBpdGVtcy5kZWxldGUocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrICYmIGZhbGxiYWNrKG5vZGUsIHBhcmFtcywgaW50cm8pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdHJhbnNpdGlvbih0b19zZW5kLCB0b19yZWNlaXZlLCBmYWxzZSksXG4gICAgICAgIHRyYW5zaXRpb24odG9fcmVjZWl2ZSwgdG9fc2VuZCwgdHJ1ZSlcbiAgICBdO1xufVxuXG5leHBvcnQgeyBibHVyLCBjcm9zc2ZhZGUsIGRyYXcsIGZhZGUsIGZseSwgc2NhbGUsIHNsaWRlIH07XG4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHsgc2xpZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XG5cblx0Y29uc3QgeyBuYXZpZ2F0ZSB9ID0gZ2V0Q29udGV4dCgnUkVQTCcpO1xuXG5cdGV4cG9ydCBsZXQga2luZDtcblx0ZXhwb3J0IGxldCBkZXRhaWxzID0gbnVsbDtcblx0ZXhwb3J0IGxldCBmaWxlbmFtZSA9IG51bGw7XG5cdGV4cG9ydCBsZXQgdHJ1bmNhdGU7XG5cblx0ZnVuY3Rpb24gbWVzc2FnZShkZXRhaWxzKSB7XG5cdFx0bGV0IHN0ciA9IGRldGFpbHMubWVzc2FnZSB8fCAnW21pc3NpbmcgbWVzc2FnZV0nO1xuXG5cdFx0bGV0IGxvYyA9IFtdO1xuXG5cdFx0aWYgKGRldGFpbHMuZmlsZW5hbWUgJiYgZGV0YWlscy5maWxlbmFtZSAhPT0gZmlsZW5hbWUpIHtcblx0XHRcdGxvYy5wdXNoKGRldGFpbHMuZmlsZW5hbWUpO1xuXHRcdH1cblxuXHRcdGlmIChkZXRhaWxzLnN0YXJ0KSBsb2MucHVzaChkZXRhaWxzLnN0YXJ0LmxpbmUsIGRldGFpbHMuc3RhcnQuY29sdW1uKTtcblxuXHRcdHJldHVybiBzdHIgKyAobG9jLmxlbmd0aCA/IGAgKCR7bG9jLmpvaW4oJzonKX0pYCA6IGBgKTtcblx0fTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cdC5tZXNzYWdlIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0Y29sb3I6IHdoaXRlO1xuXHRcdHBhZGRpbmc6IDEycHggMTZweCAxMnB4IDQ0cHg7XG5cdFx0Zm9udDogNDAwIDEycHgvMS43IHZhcigtLWZvbnQpO1xuXHRcdG1hcmdpbjogMDtcblx0XHRib3JkZXItdG9wOiAxcHggc29saWQgd2hpdGU7XG5cdH1cblxuXHQubmF2aWdhYmxlIHtcblx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdH1cblxuXHQubWVzc2FnZTo6YmVmb3JlIHtcblx0XHRjb250ZW50OiAnISc7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdGxlZnQ6IDEycHg7XG5cdFx0dG9wOiAxMHB4O1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRsaW5lLWhlaWdodDogMTtcblx0XHRwYWRkaW5nOiA0cHg7XG5cdFx0Ym9yZGVyLXJhZGl1czogNTAlO1xuXHRcdGNvbG9yOiB3aGl0ZTtcblx0XHRib3JkZXI6IDJweCBzb2xpZCB3aGl0ZTtcblx0XHRib3gtc2l6aW5nOiBjb250ZW50LWJveDtcblx0XHR3aWR0aDogMTBweDtcblx0XHRoZWlnaHQ6IDEwcHg7XG5cdFx0Zm9udC1zaXplOiAxMXB4O1xuXHRcdGZvbnQtd2VpZ2h0OiA3MDA7XG5cdH1cblxuXHQudHJ1bmNhdGUge1xuXHRcdHdoaXRlLXNwYWNlOiBwcmU7XG5cdFx0b3ZlcmZsb3cteDogaGlkZGVuO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHR9XG5cblx0cCB7XG5cdFx0bWFyZ2luOiAwO1xuXHR9XG5cblx0LmVycm9yIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiAjZGExMDZlO1xuXHR9XG5cblx0Lndhcm5pbmcge1xuXHRcdGJhY2tncm91bmQtY29sb3I6ICNlNDdlMGE7XG5cdH1cblxuXHQuaW5mbyB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBpbjpzbGlkZT17e2RlbGF5OiAxNTAsIGR1cmF0aW9uOiAxMDB9fSBvdXQ6c2xpZGU9e3tkdXJhdGlvbjogMTAwfX0gY2xhc3M9XCJtZXNzYWdlIHtraW5kfVwiIGNsYXNzOnRydW5jYXRlPlxuXHR7I2lmIGRldGFpbHN9XG5cdFx0PHBcblx0XHRcdGNsYXNzOm5hdmlnYWJsZT17ZGV0YWlscy5maWxlbmFtZX1cblx0XHRcdG9uOmNsaWNrPVwieygpID0+IG5hdmlnYXRlKGRldGFpbHMpfVwiXG5cdFx0PnttZXNzYWdlKGRldGFpbHMpfTwvcD5cblx0ezplbHNlfVxuXHRcdDxzbG90Pjwvc2xvdD5cblx0ey9pZn1cbjwvZGl2PiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuXHRpbXBvcnQgeyBpc19icm93c2VyIH0gZnJvbSAnLi9lbnYuanMnO1xuXG5cdGxldCBjb2RlbWlycm9yX3Byb21pc2U7XG5cdGxldCBfQ29kZU1pcnJvcjtcblxuXHRpZiAoaXNfYnJvd3Nlcikge1xuXHRcdGNvZGVtaXJyb3JfcHJvbWlzZSA9IGltcG9ydCgnLi9jb2RlbWlycm9yLmpzJyk7XG5cblx0XHRjb2RlbWlycm9yX3Byb21pc2UudGhlbihtb2QgPT4ge1xuXHRcdFx0X0NvZGVNaXJyb3IgPSBtb2QuZGVmYXVsdDtcblx0XHR9KTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IG9uTW91bnQsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBNZXNzYWdlIGZyb20gJy4vTWVzc2FnZS5zdmVsdGUnO1xuXG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cblx0ZXhwb3J0IGxldCByZWFkb25seSA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGVycm9yTG9jID0gbnVsbDtcblx0ZXhwb3J0IGxldCBmbGV4ID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgbGluZU51bWJlcnMgPSB0cnVlO1xuXHRleHBvcnQgbGV0IHRhYiA9IHRydWU7XG5cblx0bGV0IHc7XG5cdGxldCBoO1xuXHRsZXQgY29kZSA9ICcnO1xuXHRsZXQgbW9kZTtcblxuXHQvLyBXZSBoYXZlIHRvIGV4cG9zZSBzZXQgYW5kIHVwZGF0ZSBtZXRob2RzLCByYXRoZXJcblx0Ly8gdGhhbiBtYWtpbmcgdGhpcyBzdGF0ZS1kcml2ZW4gdGhyb3VnaCBwcm9wcyxcblx0Ly8gYmVjYXVzZSBpdCdzIGRpZmZpY3VsdCB0byB1cGRhdGUgYW4gZWRpdG9yXG5cdC8vIHdpdGhvdXQgcmVzZXR0aW5nIHNjcm9sbCBvdGhlcndpc2Vcblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldChuZXdfY29kZSwgbmV3X21vZGUpIHtcblx0XHRpZiAobmV3X21vZGUgIT09IG1vZGUpIHtcblx0XHRcdGF3YWl0IGNyZWF0ZUVkaXRvcihtb2RlID0gbmV3X21vZGUpO1xuXHRcdH1cblxuXHRcdGNvZGUgPSBuZXdfY29kZTtcblx0XHR1cGRhdGluZ19leHRlcm5hbGx5ID0gdHJ1ZTtcblx0XHRpZiAoZWRpdG9yKSBlZGl0b3Iuc2V0VmFsdWUoY29kZSk7XG5cdFx0dXBkYXRpbmdfZXh0ZXJuYWxseSA9IGZhbHNlO1xuXHR9XG5cblx0ZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZShuZXdfY29kZSkge1xuXHRcdGNvZGUgPSBuZXdfY29kZTtcblxuXHRcdGlmIChlZGl0b3IpIHtcblx0XHRcdGNvbnN0IHsgbGVmdCwgdG9wIH0gPSBlZGl0b3IuZ2V0U2Nyb2xsSW5mbygpO1xuXHRcdFx0ZWRpdG9yLnNldFZhbHVlKGNvZGUgPSBuZXdfY29kZSk7XG5cdFx0XHRlZGl0b3Iuc2Nyb2xsVG8obGVmdCwgdG9wKTtcblx0XHR9XG5cdH1cblxuXHRleHBvcnQgZnVuY3Rpb24gcmVzaXplKCkge1xuXHRcdGVkaXRvci5yZWZyZXNoKCk7XG5cdH1cblxuXHRleHBvcnQgZnVuY3Rpb24gZm9jdXMoKSB7XG5cdFx0ZWRpdG9yLmZvY3VzKCk7XG5cdH1cblxuXHRjb25zdCBtb2RlcyA9IHtcblx0XHRqczoge1xuXHRcdFx0bmFtZTogJ2phdmFzY3JpcHQnLFxuXHRcdFx0anNvbjogZmFsc2Vcblx0XHR9LFxuXHRcdGpzb246IHtcblx0XHRcdG5hbWU6ICdqYXZhc2NyaXB0Jyxcblx0XHRcdGpzb246IHRydWVcblx0XHR9LFxuXHRcdHN2ZWx0ZToge1xuXHRcdFx0bmFtZTogJ2hhbmRsZWJhcnMnLFxuXHRcdFx0YmFzZTogJ3RleHQvaHRtbCdcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgcmVmcyA9IHt9O1xuXHRsZXQgZWRpdG9yO1xuXHRsZXQgdXBkYXRpbmdfZXh0ZXJuYWxseSA9IGZhbHNlO1xuXHRsZXQgbWFya2VyO1xuXHRsZXQgZXJyb3JfbGluZTtcblx0bGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuXHRsZXQgQ29kZU1pcnJvcjtcblxuXHQkOiBpZiAoZWRpdG9yICYmIHcgJiYgaCkge1xuXHRcdGVkaXRvci5yZWZyZXNoKCk7XG5cdH1cblxuXHQkOiB7XG5cdFx0aWYgKG1hcmtlcikgbWFya2VyLmNsZWFyKCk7XG5cblx0XHRpZiAoZXJyb3JMb2MpIHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlcnJvckxvYy5saW5lIC0gMTtcblx0XHRcdGNvbnN0IGNoID0gZXJyb3JMb2MuY29sdW1uO1xuXG5cdFx0XHRtYXJrZXIgPSBlZGl0b3IubWFya1RleHQoeyBsaW5lLCBjaCB9LCB7IGxpbmUsIGNoOiBjaCArIDEgfSwge1xuXHRcdFx0XHRjbGFzc05hbWU6ICdlcnJvci1sb2MnXG5cdFx0XHR9KTtcblxuXHRcdFx0ZXJyb3JfbGluZSA9IGxpbmU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVycm9yX2xpbmUgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGxldCBwcmV2aW91c19lcnJvcl9saW5lO1xuXHQkOiBpZiAoZWRpdG9yKSB7XG5cdFx0aWYgKHByZXZpb3VzX2Vycm9yX2xpbmUgIT0gbnVsbCkge1xuXHRcdFx0ZWRpdG9yLnJlbW92ZUxpbmVDbGFzcyhwcmV2aW91c19lcnJvcl9saW5lLCAnd3JhcCcsICdlcnJvci1saW5lJylcblx0XHR9XG5cblx0XHRpZiAoZXJyb3JfbGluZSAmJiAoZXJyb3JfbGluZSAhPT0gcHJldmlvdXNfZXJyb3JfbGluZSkpIHtcblx0XHRcdGVkaXRvci5hZGRMaW5lQ2xhc3MoZXJyb3JfbGluZSwgJ3dyYXAnLCAnZXJyb3ItbGluZScpO1xuXHRcdFx0cHJldmlvdXNfZXJyb3JfbGluZSA9IGVycm9yX2xpbmU7XG5cdFx0fVxuXHR9XG5cblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0aWYgKF9Db2RlTWlycm9yKSB7XG5cdFx0XHRDb2RlTWlycm9yID0gX0NvZGVNaXJyb3I7XG5cdFx0XHRjcmVhdGVFZGl0b3IobW9kZSB8fCAnc3ZlbHRlJykudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmIChlZGl0b3IpIGVkaXRvci5zZXRWYWx1ZShjb2RlIHx8ICcnKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb2RlbWlycm9yX3Byb21pc2UudGhlbihhc3luYyBtb2QgPT4ge1xuXHRcdFx0XHRDb2RlTWlycm9yID0gbW9kLmRlZmF1bHQ7XG5cdFx0XHRcdGF3YWl0IGNyZWF0ZUVkaXRvcihtb2RlIHx8ICdzdmVsdGUnKTtcblx0XHRcdFx0aWYgKGVkaXRvcikgZWRpdG9yLnNldFZhbHVlKGNvZGUgfHwgJycpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGRlc3Ryb3llZCA9IHRydWU7XG5cdFx0XHRpZiAoZWRpdG9yKSBlZGl0b3IudG9UZXh0QXJlYSgpO1xuXHRcdH1cblx0fSk7XG5cblx0bGV0IGZpcnN0ID0gdHJ1ZTtcblxuXHRhc3luYyBmdW5jdGlvbiBjcmVhdGVFZGl0b3IobW9kZSkge1xuXHRcdGlmIChkZXN0cm95ZWQgfHwgIUNvZGVNaXJyb3IpIHJldHVybjtcblxuXHRcdGlmIChlZGl0b3IpIGVkaXRvci50b1RleHRBcmVhKCk7XG5cblx0XHRjb25zdCBvcHRzID0ge1xuXHRcdFx0bGluZU51bWJlcnMsXG5cdFx0XHRsaW5lV3JhcHBpbmc6IHRydWUsXG5cdFx0XHRpbmRlbnRXaXRoVGFiczogdHJ1ZSxcblx0XHRcdGluZGVudFVuaXQ6IDIsXG5cdFx0XHR0YWJTaXplOiAyLFxuXHRcdFx0dmFsdWU6ICcnLFxuXHRcdFx0bW9kZTogbW9kZXNbbW9kZV0gfHwge1xuXHRcdFx0XHRuYW1lOiBtb2RlXG5cdFx0XHR9LFxuXHRcdFx0cmVhZE9ubHk6IHJlYWRvbmx5LFxuXHRcdFx0YXV0b0Nsb3NlQnJhY2tldHM6IHRydWUsXG5cdFx0XHRhdXRvQ2xvc2VUYWdzOiB0cnVlXG5cdFx0fTtcblxuXHRcdGlmICghdGFiKSBvcHRzLmV4dHJhS2V5cyA9IHtcblx0XHRcdFRhYjogdGFiLFxuXHRcdFx0J1NoaWZ0LVRhYic6IHRhYlxuXHRcdH07XG5cblx0XHQvLyBDcmVhdGluZyBhIHRleHQgZWRpdG9yIGlzIGEgbG90IG9mIHdvcmssIHNvIHdlIHlpZWxkXG5cdFx0Ly8gdGhlIG1haW4gdGhyZWFkIGZvciBhIG1vbWVudC4gVGhpcyBoZWxwcyByZWR1Y2UgamFua1xuXHRcdGlmIChmaXJzdCkgYXdhaXQgc2xlZXAoNTApO1xuXG5cdFx0aWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuXG5cdFx0ZWRpdG9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEocmVmcy5lZGl0b3IsIG9wdHMpO1xuXG5cdFx0ZWRpdG9yLm9uKCdjaGFuZ2UnLCBpbnN0YW5jZSA9PiB7XG5cdFx0XHRpZiAoIXVwZGF0aW5nX2V4dGVybmFsbHkpIHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBpbnN0YW5jZS5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRkaXNwYXRjaCgnY2hhbmdlJywgeyB2YWx1ZSB9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChmaXJzdCkgYXdhaXQgc2xlZXAoNTApO1xuXHRcdGVkaXRvci5yZWZyZXNoKCk7XG5cblx0XHRmaXJzdCA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2xlZXAobXMpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVsZmlsID0+IHNldFRpbWVvdXQoZnVsZmlsLCBtcykpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuY29kZW1pcnJvci1jb250YWluZXIge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGxpbmUtaGVpZ2h0OiAxLjU7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0fVxuXG5cdC5jb2RlbWlycm9yLWNvbnRhaW5lciA6Z2xvYmFsKC5Db2RlTWlycm9yKSB7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuXHRcdGZvbnQ6IDQwMCAxNHB4LzEuNyB2YXIoLS1mb250LW1vbm8pO1xuXHRcdGNvbG9yOiB2YXIoLS1iYXNlKTtcblx0fVxuXG5cdC5jb2RlbWlycm9yLWNvbnRhaW5lci5mbGV4IDpnbG9iYWwoLkNvZGVNaXJyb3IpIHtcblx0XHRoZWlnaHQ6IGF1dG87XG5cdH1cblxuXHQuY29kZW1pcnJvci1jb250YWluZXIuZmxleCA6Z2xvYmFsKC5Db2RlTWlycm9yLWxpbmVzKSB7XG5cdFx0cGFkZGluZzogMDtcblx0fVxuXG5cdC5jb2RlbWlycm9yLWNvbnRhaW5lciA6Z2xvYmFsKC5Db2RlTWlycm9yLWd1dHRlcnMpIHtcblx0XHRwYWRkaW5nOiAwIDE2cHggMCA4cHg7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHR9XG5cblx0LmNvZGVtaXJyb3ItY29udGFpbmVyIDpnbG9iYWwoLmVycm9yLWxvYykge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRib3JkZXItYm90dG9tOiAycHggc29saWQgI2RhMTA2ZTtcblx0fVxuXG5cdC5jb2RlbWlycm9yLWNvbnRhaW5lciA6Z2xvYmFsKC5lcnJvci1saW5lKSB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDAsIDAsIDAsIC4wNSk7XG5cdH1cblxuXHR0ZXh0YXJlYSB7XG5cdFx0dmlzaWJpbGl0eTogaGlkZGVuO1xuXHR9XG5cblx0cHJlIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRwYWRkaW5nOiA0cHggNHB4IDRweCA2MHB4O1xuXHRcdHJlc2l6ZTogbm9uZTtcblx0XHRmb250LWZhbWlseTogdmFyKC0tZm9udC1tb25vKTtcblx0XHRmb250LXNpemU6IDEzcHg7XG5cdFx0bGluZS1oZWlnaHQ6IDEuNztcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRjb2xvcjogI2NjYztcblx0XHR0YWItc2l6ZTogMjtcblx0XHQtbW96LXRhYi1zaXplOiAyO1xuXHR9XG5cblx0LmZsZXggcHJlIHtcblx0XHRwYWRkaW5nOiAwIDAgMCA0cHg7XG5cdFx0aGVpZ2h0OiBhdXRvO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPSdjb2RlbWlycm9yLWNvbnRhaW5lcicgY2xhc3M6ZmxleCBiaW5kOm9mZnNldFdpZHRoPXt3fSBiaW5kOm9mZnNldEhlaWdodD17aH0+XG5cdDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5LXBvc2l0aXZlLXRhYmluZGV4IC0tPlxuXHQ8dGV4dGFyZWFcblx0XHR0YWJpbmRleD0nMidcblx0XHRiaW5kOnRoaXM9e3JlZnMuZWRpdG9yfVxuXHRcdHJlYWRvbmx5XG5cdFx0dmFsdWU9e2NvZGV9XG5cdD48L3RleHRhcmVhPlxuXG5cdHsjaWYgIUNvZGVNaXJyb3J9XG5cdFx0PHByZSBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwXCJcblx0XHQ+e2NvZGV9PC9wcmU+XG5cblx0XHQ8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgYm90dG9tOiAwXCI+XG5cdFx0XHQ8TWVzc2FnZSBraW5kPSdpbmZvJz5sb2FkaW5nIGVkaXRvci4uLjwvTWVzc2FnZT5cblx0XHQ8L2Rpdj5cblx0ey9pZn1cbjwvZGl2PiIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IGdldENvbnRleHQsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgQ29kZU1pcnJvciBmcm9tICcuLi9Db2RlTWlycm9yLnN2ZWx0ZSc7XG5cdGltcG9ydCBNZXNzYWdlIGZyb20gJy4uL01lc3NhZ2Uuc3ZlbHRlJztcblxuXHRjb25zdCB7IGJ1bmRsZSwgc2VsZWN0ZWQsIGhhbmRsZV9jaGFuZ2UsIHJlZ2lzdGVyX21vZHVsZV9lZGl0b3IgfSA9IGdldENvbnRleHQoJ1JFUEwnKTtcblxuXHRleHBvcnQgbGV0IGVycm9yTG9jO1xuXG5cdGxldCBlZGl0b3I7XG5cdG9uTW91bnQoKCkgPT4ge1xuXHRcdHJlZ2lzdGVyX21vZHVsZV9lZGl0b3IoZWRpdG9yKTtcblx0fSk7XG5cblx0ZXhwb3J0IGZ1bmN0aW9uIGZvY3VzKCkge1xuXHRcdGVkaXRvci5mb2N1cygpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuZWRpdG9yLXdyYXBwZXIge1xuXHRcdHotaW5kZXg6IDU7XG5cdFx0YmFja2dyb3VuZDogdmFyKC0tYmFjay1saWdodCk7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHR9XG5cblx0LmVkaXRvciB7XG5cdFx0aGVpZ2h0OiAwO1xuXHRcdGZsZXg6IDEgMSBhdXRvO1xuXHR9XG5cblx0LmluZm8ge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXNlY29uZCk7XG5cdFx0bWF4LWhlaWdodDogNTAlO1xuXHRcdG92ZXJmbG93OiBhdXRvO1xuXHR9XG5cblx0Omdsb2JhbCguY29sdW1ucykgLmVkaXRvci13cmFwcGVyIHtcblx0XHQvKiBtYWtlIGl0IGVhc2llciB0byBpbnRlcmFjdCB3aXRoIHNjcm9sbGJhciAqL1xuXHRcdHBhZGRpbmctcmlnaHQ6IDhweDtcblx0XHRoZWlnaHQ6IGF1dG87XG5cdFx0LyogaGVpZ2h0OiAxMDAlOyAqL1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiZWRpdG9yLXdyYXBwZXJcIj5cblx0PGRpdiBjbGFzcz1cImVkaXRvclwiPlxuXHRcdDxDb2RlTWlycm9yXG5cdFx0XHRiaW5kOnRoaXM9e2VkaXRvcn1cblx0XHRcdHtlcnJvckxvY31cblx0XHRcdG9uOmNoYW5nZT17aGFuZGxlX2NoYW5nZX1cblx0XHQvPlxuXHQ8L2Rpdj5cblxuXHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdHsjaWYgJGJ1bmRsZX1cblx0XHRcdHsjaWYgJGJ1bmRsZS5lcnJvcn1cblx0XHRcdFx0PE1lc3NhZ2Uga2luZD1cImVycm9yXCIgZGV0YWlscz17JGJ1bmRsZS5lcnJvcn0gZmlsZW5hbWU9XCJ7JHNlbGVjdGVkLm5hbWV9Lnskc2VsZWN0ZWQudHlwZX1cIi8+XG5cdFx0XHR7OmVsc2UgaWYgJGJ1bmRsZS53YXJuaW5ncy5sZW5ndGggPiAwfVxuXHRcdFx0XHR7I2VhY2ggJGJ1bmRsZS53YXJuaW5ncyBhcyB3YXJuaW5nfVxuXHRcdFx0XHRcdDxNZXNzYWdlIGtpbmQ9XCJ3YXJuaW5nXCIgZGV0YWlscz17d2FybmluZ30gZmlsZW5hbWU9XCJ7JHNlbGVjdGVkLm5hbWV9Lnskc2VsZWN0ZWQudHlwZX1cIi8+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHsvaWZ9XG5cdFx0ey9pZn1cblx0PC9kaXY+XG48L2Rpdj4iLCJ2YXIgY2hhclRvSW50ZWdlciA9IHt9O1xudmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbmZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFyVG9JbnRlZ2VyW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbn1cbmZ1bmN0aW9uIGRlY29kZShtYXBwaW5ncykge1xuICAgIHZhciBnZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDsgLy8gZmlyc3QgZmllbGRcbiAgICB2YXIgc291cmNlRmlsZUluZGV4ID0gMDsgLy8gc2Vjb25kIGZpZWxkXG4gICAgdmFyIHNvdXJjZUNvZGVMaW5lID0gMDsgLy8gdGhpcmQgZmllbGRcbiAgICB2YXIgc291cmNlQ29kZUNvbHVtbiA9IDA7IC8vIGZvdXJ0aCBmaWVsZFxuICAgIHZhciBuYW1lSW5kZXggPSAwOyAvLyBmaWZ0aCBmaWVsZFxuICAgIHZhciBkZWNvZGVkID0gW107XG4gICAgdmFyIGxpbmUgPSBbXTtcbiAgICB2YXIgc2VnbWVudCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMCwgc2hpZnQgPSAwLCB2YWx1ZSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gbWFwcGluZ3MuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPT09IDQ0KSB7IC8vIFwiLFwiXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gNTkpIHsgLy8gXCI7XCJcbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBsaW5lLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGludGVnZXIgPSBjaGFyVG9JbnRlZ2VyW2NdO1xuICAgICAgICAgICAgaWYgKGludGVnZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgKCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYXNDb250aW51YXRpb25CaXQgPSBpbnRlZ2VyICYgMzI7XG4gICAgICAgICAgICBpbnRlZ2VyICY9IDMxO1xuICAgICAgICAgICAgdmFsdWUgKz0gaW50ZWdlciA8PCBzaGlmdDtcbiAgICAgICAgICAgIGlmIChoYXNDb250aW51YXRpb25CaXQpIHtcbiAgICAgICAgICAgICAgICBzaGlmdCArPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZE5lZ2F0ZSA9IHZhbHVlICYgMTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA+Pj49IDE7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE5lZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAtMHg4MDAwMDAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGogPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRDb2RlQ29sdW1uICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnB1c2goZ2VuZXJhdGVkQ29kZUNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRmlsZUluZGV4ICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnB1c2goc291cmNlRmlsZUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb2RlTGluZSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5wdXNoKHNvdXJjZUNvZGVMaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb2RlQ29sdW1uICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnB1c2goc291cmNlQ29kZUNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUluZGV4ICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50LnB1c2gobmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc2hpZnQgPSAwOyAvLyByZXNldFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWdtZW50Lmxlbmd0aClcbiAgICAgICAgbGluZS5wdXNoKHNlZ21lbnQpO1xuICAgIGRlY29kZWQucHVzaChsaW5lKTtcbiAgICByZXR1cm4gZGVjb2RlZDtcbn1cbmZ1bmN0aW9uIGVuY29kZShkZWNvZGVkKSB7XG4gICAgdmFyIHNvdXJjZUZpbGVJbmRleCA9IDA7IC8vIHNlY29uZCBmaWVsZFxuICAgIHZhciBzb3VyY2VDb2RlTGluZSA9IDA7IC8vIHRoaXJkIGZpZWxkXG4gICAgdmFyIHNvdXJjZUNvZGVDb2x1bW4gPSAwOyAvLyBmb3VydGggZmllbGRcbiAgICB2YXIgbmFtZUluZGV4ID0gMDsgLy8gZmlmdGggZmllbGRcbiAgICB2YXIgbWFwcGluZ3MgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICBtYXBwaW5ncyArPSAnOyc7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZ2VuZXJhdGVkQ29kZUNvbHVtbiA9IDA7IC8vIGZpcnN0IGZpZWxkXG4gICAgICAgIHZhciBsaW5lTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBsaW5lXzEgPSBsaW5lOyBfaSA8IGxpbmVfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gbGluZV8xW19pXTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50TWFwcGluZ3MgPSBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbMF0gLSBnZW5lcmF0ZWRDb2RlQ29sdW1uKTtcbiAgICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW4gPSBzZWdtZW50WzBdO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRNYXBwaW5ncyArPVxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbMV0gLSBzb3VyY2VGaWxlSW5kZXgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZUludGVnZXIoc2VnbWVudFsyXSAtIHNvdXJjZUNvZGVMaW5lKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbM10gLSBzb3VyY2VDb2RlQ29sdW1uKTtcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWxlSW5kZXggPSBzZWdtZW50WzFdO1xuICAgICAgICAgICAgICAgIHNvdXJjZUNvZGVMaW5lID0gc2VnbWVudFsyXTtcbiAgICAgICAgICAgICAgICBzb3VyY2VDb2RlQ29sdW1uID0gc2VnbWVudFszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRNYXBwaW5ncyArPSBlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbNF0gLSBuYW1lSW5kZXgpO1xuICAgICAgICAgICAgICAgIG5hbWVJbmRleCA9IHNlZ21lbnRbNF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lTWFwcGluZ3MucHVzaChzZWdtZW50TWFwcGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIG1hcHBpbmdzICs9IGxpbmVNYXBwaW5ncy5qb2luKCcsJyk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwaW5ncztcbn1cbmZ1bmN0aW9uIGVuY29kZUludGVnZXIobnVtKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIG51bSA9IG51bSA8IDAgPyAoLW51bSA8PCAxKSB8IDEgOiBudW0gPDwgMTtcbiAgICBkbyB7XG4gICAgICAgIHZhciBjbGFtcGVkID0gbnVtICYgMzE7XG4gICAgICAgIG51bSA+Pj49IDU7XG4gICAgICAgIGlmIChudW0gPiAwKSB7XG4gICAgICAgICAgICBjbGFtcGVkIHw9IDMyO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBjaGFyc1tjbGFtcGVkXTtcbiAgICB9IHdoaWxlIChudW0gPiAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBkZWNvZGUsIGVuY29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c291cmNlbWFwLWNvZGVjLmVzLmpzLm1hcFxuIiwiaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSAnc291cmNlbWFwLWNvZGVjJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TG9jYXRpb25Gcm9tU3RhY2soc3RhY2ssIG1hcCkge1xuXHRpZiAoIXN0YWNrKSByZXR1cm47XG5cdGNvbnN0IGxhc3QgPSBzdGFjay5zcGxpdCgnXFxuJylbMV07XG5cdGNvbnN0IG1hdGNoID0gLzxhbm9ueW1vdXM+OihcXGQrKTooXFxkKylcXCkkLy5leGVjKGxhc3QpO1xuXG5cdGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG5cdGNvbnN0IGxpbmUgPSArbWF0Y2hbMV07XG5cdGNvbnN0IGNvbHVtbiA9ICttYXRjaFsyXTtcblxuXHRyZXR1cm4gdHJhY2UoeyBsaW5lLCBjb2x1bW4gfSwgbWFwKTtcbn1cblxuZnVuY3Rpb24gdHJhY2UobG9jLCBtYXApIHtcblx0Y29uc3QgbWFwcGluZ3MgPSBkZWNvZGUobWFwLm1hcHBpbmdzKTtcblx0Y29uc3Qgc2VnbWVudHMgPSBtYXBwaW5nc1tsb2MubGluZSAtIDFdO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0aWYgKHNlZ21lbnRbMF0gPT09IGxvYy5jb2x1bW4pIHtcblx0XHRcdGNvbnN0IFssIHNvdXJjZUluZGV4LCBsaW5lLCBjb2x1bW5dID0gc2VnbWVudDtcblx0XHRcdGNvbnN0IHNvdXJjZSA9IG1hcC5zb3VyY2VzW3NvdXJjZUluZGV4XS5zbGljZSgyKTtcblxuXHRcdFx0cmV0dXJuIHsgc291cmNlLCBsaW5lOiBsaW5lICsgMSwgY29sdW1uIH07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJy4uL3N0b3JlJztcbmltcG9ydCB7IG5vdywgbG9vcCwgYXNzaWduIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuaW1wb3J0IHsgbGluZWFyIH0gZnJvbSAnLi4vZWFzaW5nJztcblxuZnVuY3Rpb24gaXNfZGF0ZShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gdGlja19zcHJpbmcoY3R4LCBsYXN0X3ZhbHVlLCBjdXJyZW50X3ZhbHVlLCB0YXJnZXRfdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRfdmFsdWUgPT09ICdudW1iZXInIHx8IGlzX2RhdGUoY3VycmVudF92YWx1ZSkpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRhcmdldF92YWx1ZSAtIGN1cnJlbnRfdmFsdWU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdmVsb2NpdHkgPSAoY3VycmVudF92YWx1ZSAtIGxhc3RfdmFsdWUpIC8gKGN0eC5kdCB8fCAxIC8gNjApOyAvLyBndWFyZCBkaXYgYnkgMFxuICAgICAgICBjb25zdCBzcHJpbmcgPSBjdHgub3B0cy5zdGlmZm5lc3MgKiBkZWx0YTtcbiAgICAgICAgY29uc3QgZGFtcGVyID0gY3R4Lm9wdHMuZGFtcGluZyAqIHZlbG9jaXR5O1xuICAgICAgICBjb25zdCBhY2NlbGVyYXRpb24gPSAoc3ByaW5nIC0gZGFtcGVyKSAqIGN0eC5pbnZfbWFzcztcbiAgICAgICAgY29uc3QgZCA9ICh2ZWxvY2l0eSArIGFjY2VsZXJhdGlvbikgKiBjdHguZHQ7XG4gICAgICAgIGlmIChNYXRoLmFicyhkKSA8IGN0eC5vcHRzLnByZWNpc2lvbiAmJiBNYXRoLmFicyhkZWx0YSkgPCBjdHgub3B0cy5wcmVjaXNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRfdmFsdWU7IC8vIHNldHRsZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zZXR0bGVkID0gZmFsc2U7IC8vIHNpZ25hbCBsb29wIHRvIGtlZXAgdGlja2luZ1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIGlzX2RhdGUoY3VycmVudF92YWx1ZSkgP1xuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGN1cnJlbnRfdmFsdWUuZ2V0VGltZSgpICsgZCkgOiBjdXJyZW50X3ZhbHVlICsgZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRfdmFsdWUpKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRfdmFsdWUubWFwKChfLCBpKSA9PiB0aWNrX3NwcmluZyhjdHgsIGxhc3RfdmFsdWVbaV0sIGN1cnJlbnRfdmFsdWVbaV0sIHRhcmdldF92YWx1ZVtpXSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY3VycmVudF92YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgbmV4dF92YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gY3VycmVudF92YWx1ZSlcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG5leHRfdmFsdWVba10gPSB0aWNrX3NwcmluZyhjdHgsIGxhc3RfdmFsdWVba10sIGN1cnJlbnRfdmFsdWVba10sIHRhcmdldF92YWx1ZVtrXSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG5leHRfdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzcHJpbmcgJHt0eXBlb2YgY3VycmVudF92YWx1ZX0gdmFsdWVzYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3ByaW5nKHZhbHVlLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBzdG9yZSA9IHdyaXRhYmxlKHZhbHVlKTtcbiAgICBjb25zdCB7IHN0aWZmbmVzcyA9IDAuMTUsIGRhbXBpbmcgPSAwLjgsIHByZWNpc2lvbiA9IDAuMDEgfSA9IG9wdHM7XG4gICAgbGV0IGxhc3RfdGltZTtcbiAgICBsZXQgdGFzaztcbiAgICBsZXQgY3VycmVudF90b2tlbjtcbiAgICBsZXQgbGFzdF92YWx1ZSA9IHZhbHVlO1xuICAgIGxldCB0YXJnZXRfdmFsdWUgPSB2YWx1ZTtcbiAgICBsZXQgaW52X21hc3MgPSAxO1xuICAgIGxldCBpbnZfbWFzc19yZWNvdmVyeV9yYXRlID0gMDtcbiAgICBsZXQgY2FuY2VsX3Rhc2sgPSBmYWxzZTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbiAgICBmdW5jdGlvbiBzZXQobmV3X3ZhbHVlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdGFyZ2V0X3ZhbHVlID0gbmV3X3ZhbHVlO1xuICAgICAgICBjb25zdCB0b2tlbiA9IGN1cnJlbnRfdG9rZW4gPSB7fTtcbiAgICAgICAgaWYgKG9wdHMuaGFyZCB8fCAoc3ByaW5nLnN0aWZmbmVzcyA+PSAxICYmIHNwcmluZy5kYW1waW5nID49IDEpKSB7XG4gICAgICAgICAgICBjYW5jZWxfdGFzayA9IHRydWU7IC8vIGNhbmNlbCBhbnkgcnVubmluZyBhbmltYXRpb25cbiAgICAgICAgICAgIGxhc3RfdGltZSA9IG5vdygpO1xuICAgICAgICAgICAgbGFzdF92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgc3RvcmUuc2V0KHZhbHVlID0gdGFyZ2V0X3ZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmID0+IGYoKSk7IC8vIGZ1bGZpbCBpbW1lZGlhdGVseVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuc29mdCkge1xuICAgICAgICAgICAgY29uc3QgcmF0ZSA9IG9wdHMuc29mdCA9PT0gdHJ1ZSA/IC41IDogK29wdHMuc29mdDtcbiAgICAgICAgICAgIGludl9tYXNzX3JlY292ZXJ5X3JhdGUgPSAxIC8gKHJhdGUgKiA2MCk7XG4gICAgICAgICAgICBpbnZfbWFzcyA9IDA7IC8vIGluZmluaXRlIG1hc3MsIHVuYWZmZWN0ZWQgYnkgc3ByaW5nIGZvcmNlc1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgICAgbGFzdF90aW1lID0gbm93KCk7XG4gICAgICAgICAgICBjYW5jZWxfdGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgdGFzayA9IGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsX3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsX3Rhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW52X21hc3MgPSBNYXRoLm1pbihpbnZfbWFzcyArIGludl9tYXNzX3JlY292ZXJ5X3JhdGUsIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW52X21hc3MsXG4gICAgICAgICAgICAgICAgICAgIG9wdHM6IHNwcmluZyxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHQ6IChub3cgLSBsYXN0X3RpbWUpICogNjAgLyAxMDAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0X3ZhbHVlID0gdGlja19zcHJpbmcoY3R4LCBsYXN0X3ZhbHVlLCB2YWx1ZSwgdGFyZ2V0X3ZhbHVlKTtcbiAgICAgICAgICAgICAgICBsYXN0X3RpbWUgPSBub3c7XG4gICAgICAgICAgICAgICAgbGFzdF92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHN0b3JlLnNldCh2YWx1ZSA9IG5leHRfdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjdHguc2V0dGxlZClcbiAgICAgICAgICAgICAgICAgICAgdGFzayA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFjdHguc2V0dGxlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdWxmaWwgPT4ge1xuICAgICAgICAgICAgdGFzay5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gY3VycmVudF90b2tlbilcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4gICAgY29uc3Qgc3ByaW5nID0ge1xuICAgICAgICBzZXQsXG4gICAgICAgIHVwZGF0ZTogKGZuLCBvcHRzKSA9PiBzZXQoZm4odGFyZ2V0X3ZhbHVlLCB2YWx1ZSksIG9wdHMpLFxuICAgICAgICBzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZSxcbiAgICAgICAgc3RpZmZuZXNzLFxuICAgICAgICBkYW1waW5nLFxuICAgICAgICBwcmVjaXNpb25cbiAgICB9O1xuICAgIHJldHVybiBzcHJpbmc7XG59XG5cbmZ1bmN0aW9uIGdldF9pbnRlcnBvbGF0b3IoYSwgYikge1xuICAgIGlmIChhID09PSBiIHx8IGEgIT09IGEpXG4gICAgICAgIHJldHVybiAoKSA9PiBhO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYTtcbiAgICBpZiAodHlwZSAhPT0gdHlwZW9mIGIgfHwgQXJyYXkuaXNBcnJheShhKSAhPT0gQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnRlcnBvbGF0ZSB2YWx1ZXMgb2YgZGlmZmVyZW50IHR5cGUnKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgY29uc3QgYXJyID0gYi5tYXAoKGJpLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X2ludGVycG9sYXRvcihhW2ldLCBiaSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdCA9PiBhcnIubWFwKGZuID0+IGZuKHQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghYSB8fCAhYilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IGNhbm5vdCBiZSBudWxsJyk7XG4gICAgICAgIGlmIChpc19kYXRlKGEpICYmIGlzX2RhdGUoYikpIHtcbiAgICAgICAgICAgIGEgPSBhLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGIgPSBiLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYiAtIGE7XG4gICAgICAgICAgICByZXR1cm4gdCA9PiBuZXcgRGF0ZShhICsgdCAqIGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRvcnMgPSB7fTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0b3JzW2tleV0gPSBnZXRfaW50ZXJwb2xhdG9yKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbnRlcnBvbGF0b3JzW2tleV0odCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGIgLSBhO1xuICAgICAgICByZXR1cm4gdCA9PiBhICsgdCAqIGRlbHRhO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpbnRlcnBvbGF0ZSAke3R5cGV9IHZhbHVlc2ApO1xufVxuZnVuY3Rpb24gdHdlZW5lZCh2YWx1ZSwgZGVmYXVsdHMgPSB7fSkge1xuICAgIGNvbnN0IHN0b3JlID0gd3JpdGFibGUodmFsdWUpO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB0YXJnZXRfdmFsdWUgPSB2YWx1ZTtcbiAgICBmdW5jdGlvbiBzZXQobmV3X3ZhbHVlLCBvcHRzKSB7XG4gICAgICAgIHRhcmdldF92YWx1ZSA9IG5ld192YWx1ZTtcbiAgICAgICAgbGV0IHByZXZpb3VzX3Rhc2sgPSB0YXNrO1xuICAgICAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBsaW5lYXIsIGludGVycG9sYXRlID0gZ2V0X2ludGVycG9sYXRvciB9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBvcHRzKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBsZXQgZm47XG4gICAgICAgIHRhc2sgPSBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAobm93IDwgc3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBmbiA9IGludGVycG9sYXRlKHZhbHVlLCBuZXdfdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24odmFsdWUsIG5ld192YWx1ZSk7XG4gICAgICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldmlvdXNfdGFzaykge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rhc2suYWJvcnQoKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c190YXNrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVsYXBzZWQgPSBub3cgLSBzdGFydDtcbiAgICAgICAgICAgIGlmIChlbGFwc2VkID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXQodmFsdWUgPSBuZXdfdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHN0b3JlLnNldCh2YWx1ZSA9IGZuKGVhc2luZyhlbGFwc2VkIC8gZHVyYXRpb24pKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXNrLnByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNldCxcbiAgICAgICAgdXBkYXRlOiAoZm4sIG9wdHMpID0+IHNldChmbih0YXJnZXRfdmFsdWUsIHZhbHVlKSwgb3B0cyksXG4gICAgICAgIHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgc3ByaW5nLCB0d2VlbmVkIH07XG4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBzcHJpbmcgfSBmcm9tICdzdmVsdGUvbW90aW9uJztcblx0aW1wb3J0IFNwbGl0UGFuZSBmcm9tICcuLi9TcGxpdFBhbmUuc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IHBhbmVsO1xuXHRleHBvcnQgbGV0IHBvcyA9IDUwO1xuXHRsZXQgcHJldmlvdXNfcG9zID0gTWF0aC5taW4ocG9zLCA3MCk7XG5cblx0bGV0IG1heDtcblxuXHQvLyB3ZSBjYW4ndCBiaW5kIHRvIHRoZSBzcHJpbmcgaXRzZWxmLCBidXQgd2Vcblx0Ly8gY2FuIHN0aWxsIHVzZSB0aGUgc3ByaW5nIHRvIGRyaXZlIGBwb3NgXG5cdGNvbnN0IGRyaXZlciA9IHNwcmluZyhwb3MpO1xuXHQkOiBwb3MgPSAkZHJpdmVyO1xuXG5cdGNvbnN0IHRvZ2dsZSA9ICgpID0+IHtcblx0XHRkcml2ZXIuc2V0KHBvcywgeyBoYXJkOiB0cnVlIH0pO1xuXG5cdFx0aWYgKHBvcyA+IDgwKSB7XG5cdFx0XHRkcml2ZXIuc2V0KHByZXZpb3VzX3Bvcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByZXZpb3VzX3BvcyA9IHBvcztcblx0XHRcdGRyaXZlci5zZXQobWF4KTtcblx0XHR9XG5cdH07XG48L3NjcmlwdD5cblxuPFNwbGl0UGFuZSBiaW5kOm1heCB0eXBlPVwidmVydGljYWxcIiBiaW5kOnBvcz17cG9zfT5cblx0PHNlY3Rpb24gc2xvdD1cImFcIj5cblx0XHQ8c2xvdCBuYW1lPVwibWFpblwiPjwvc2xvdD5cblx0PC9zZWN0aW9uPlxuXG5cdDxzZWN0aW9uIHNsb3Q9XCJiXCI+XG5cdFx0PGRpdiBjbGFzcz1cInBhbmVsLWhlYWRlclwiIG9uOmNsaWNrPXt0b2dnbGV9PlxuXHRcdFx0PGgzPntwYW5lbH08L2gzPlxuXHRcdFx0PHNsb3QgbmFtZT1cInBhbmVsLWhlYWRlclwiPjwvc2xvdD5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJwYW5lbC1ib2R5XCI+XG5cdFx0XHQ8c2xvdCBuYW1lPVwicGFuZWwtYm9keVwiPjwvc2xvdD5cblx0XHQ8L2Rpdj5cblx0PC9zZWN0aW9uPlxuPC9TcGxpdFBhbmU+XG5cbjxzdHlsZT5cblx0LnBhbmVsLWhlYWRlciB7XG5cdFx0aGVpZ2h0OiA0MnB4O1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0cGFkZGluZzogMCAwLjVlbTtcblx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdH1cblxuXHQucGFuZWwtYm9keSB7XG5cdFx0bWF4LWhlaWdodDogY2FsYygxMDAlIC0gNDJweCk7XG5cdFx0b3ZlcmZsb3c6IGF1dG87XG5cdH1cblxuXHRoMyB7XG5cdFx0Zm9udDogNzAwIDEycHgvMS41IHZhcigtLWZvbnQpO1xuXHRcdGNvbG9yOiAjMzMzO1xuXHR9XG48L3N0eWxlPiIsImxldCB1aWQgPSAxO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXBsUHJveHkge1xuXHRjb25zdHJ1Y3RvcihpZnJhbWUsIGhhbmRsZXJzKSB7XG5cdFx0dGhpcy5pZnJhbWUgPSBpZnJhbWU7XG5cdFx0dGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuXG5cdFx0dGhpcy5wZW5kaW5nX2NtZHMgPSBuZXcgTWFwKCk7XG5cblx0XHR0aGlzLmhhbmRsZV9ldmVudCA9IGUgPT4gdGhpcy5oYW5kbGVfcmVwbF9tZXNzYWdlKGUpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVfZXZlbnQsIGZhbHNlKTtcblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZV9ldmVudCk7XG5cdH1cblxuXHRpZnJhbWVfY29tbWFuZChhY3Rpb24sIGFyZ3MpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0Y29uc3QgY21kX2lkID0gdWlkKys7XG5cblx0XHRcdHRoaXMucGVuZGluZ19jbWRzLnNldChjbWRfaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuXG5cdFx0XHR0aGlzLmlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKHsgYWN0aW9uLCBjbWRfaWQsIGFyZ3MgfSwgJyonKTtcblx0XHR9KTtcblx0fVxuXG5cdGhhbmRsZV9jb21tYW5kX21lc3NhZ2UoY21kX2RhdGEpIHtcblx0XHRsZXQgYWN0aW9uID0gY21kX2RhdGEuYWN0aW9uO1xuXHRcdGxldCBpZCA9IGNtZF9kYXRhLmNtZF9pZDtcblx0XHRsZXQgaGFuZGxlciA9IHRoaXMucGVuZGluZ19jbWRzLmdldChpZCk7XG5cblx0XHRpZiAoaGFuZGxlcikge1xuXHRcdFx0dGhpcy5wZW5kaW5nX2NtZHMuZGVsZXRlKGlkKTtcblx0XHRcdGlmIChhY3Rpb24gPT09ICdjbWRfZXJyb3InKSB7XG5cdFx0XHRcdGxldCB7IG1lc3NhZ2UsIHN0YWNrIH0gPSBjbWRfZGF0YTtcblx0XHRcdFx0bGV0IGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdFx0XHRcdGUuc3RhY2sgPSBzdGFjaztcblx0XHRcdFx0aGFuZGxlci5yZWplY3QoZSlcblx0XHRcdH1cblxuXHRcdFx0aWYgKGFjdGlvbiA9PT0gJ2NtZF9vaycpIHtcblx0XHRcdFx0aGFuZGxlci5yZXNvbHZlKGNtZF9kYXRhLmFyZ3MpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ2NvbW1hbmQgbm90IGZvdW5kJywgaWQsIGNtZF9kYXRhLCBbLi4udGhpcy5wZW5kaW5nX2NtZHMua2V5cygpXSk7XG5cdFx0fVxuXHR9XG5cblx0aGFuZGxlX3JlcGxfbWVzc2FnZShldmVudCkge1xuXHRcdGlmIChldmVudC5zb3VyY2UgIT09IHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHJldHVybjtcblxuXHRcdGNvbnN0IHsgYWN0aW9uLCBhcmdzIH0gPSBldmVudC5kYXRhO1xuXG5cdFx0c3dpdGNoIChhY3Rpb24pIHtcblx0XHRcdGNhc2UgJ2NtZF9lcnJvcic6XG5cdFx0XHRjYXNlICdjbWRfb2snOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVfY29tbWFuZF9tZXNzYWdlKGV2ZW50LmRhdGEpO1xuXHRcdFx0Y2FzZSAnZmV0Y2hfcHJvZ3Jlc3MnOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVycy5vbl9mZXRjaF9wcm9ncmVzcyhhcmdzLnJlbWFpbmluZylcblx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuaGFuZGxlcnMub25fZXJyb3IoZXZlbnQuZGF0YSk7XG5cdFx0XHRjYXNlICd1bmhhbmRsZWRyZWplY3Rpb24nOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVycy5vbl91bmhhbmRsZWRfcmVqZWN0aW9uKGV2ZW50LmRhdGEpO1xuXHRcdFx0Y2FzZSAnY29uc29sZSc6XG5cdFx0XHRcdHJldHVybiB0aGlzLmhhbmRsZXJzLm9uX2NvbnNvbGUoZXZlbnQuZGF0YSk7XG5cdFx0fVxuXHR9XG5cblx0ZXZhbChzY3JpcHQpIHtcblx0XHRyZXR1cm4gdGhpcy5pZnJhbWVfY29tbWFuZCgnZXZhbCcsIHsgc2NyaXB0IH0pO1xuXHR9XG5cblx0aGFuZGxlX2xpbmtzKCkge1xuXHRcdHJldHVybiB0aGlzLmlmcmFtZV9jb21tYW5kKCdjYXRjaF9jbGlja3MnLCB7fSk7XG5cdH1cbn0iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXHRjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICBkaXNwYXRjaCgnY2xpY2snLCBldmVudCk7XG4gIH1cblxuICBleHBvcnQgbGV0IGV4cGFuZGVkO1xuPC9zY3JpcHQ+XG48c3R5bGU+XG4gIC5jb250YWluZXIge1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB3aWR0aDogdmFyKC0tbGktaWRlbnRhdGlvbik7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIG1hcmdpbi1sZWZ0OiBjYWxjKC03cHggLSB2YXIoLS1saS1pZGVudGF0aW9uKSk7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gIH1cbiAgLmFycm93IHtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiA2NyUgNTAlO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBsaW5lLWhlaWdodDogMS4xZW07XG4gICAgZm9udC1zaXplOiAwLjc1ZW07XG4gICAgbWFyZ2luLWxlZnQ6IDA7XG4gICAgdHJhbnNpdGlvbjogMTUwbXM7XG4gICAgY29sb3I6IHZhcigtLWFycm93LXNpZ24pO1xuICB9XG4gIC5leHBhbmRlZCB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGVaKDkwZGVnKSB0cmFuc2xhdGVYKC0zcHgpO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiY29udGFpbmVyXCIgb246Y2xpY2s9e29uQ2xpY2t9PlxuICA8ZGl2IGNsYXNzPVwiYXJyb3dcIiBjbGFzczpleHBhbmRlZD17ZXhwYW5kZWR9PnsnXFx1MjVCNid9PC9kaXY+XG48L2Rpdj4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvYmpUeXBlKG9iaikge1xuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpO1xuICBpZiAodHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICBpZiAodHlwZW9mIG9ialtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gJ0l0ZXJhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuIG9iai5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgc3dpdGNoKG9ialR5cGUob2JqKSkge1xuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICBjYXNlICdOdWxsJzpcbiAgICBjYXNlICdVbmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGlzUHJpbWl0aXZlIH0gZnJvbSAnLi9vYmpUeXBlJztcbiAgaW1wb3J0IEpTT05Ob2RlIGZyb20gJy4vSlNPTk5vZGUuc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IGtleSwgaXNQYXJlbnRFeHBhbmRlZCwgaXNQYXJlbnRBcnJheSA9IGZhbHNlLCBjb2xvbiA9ICc6JztcblxuICAkOiBzaG93S2V5ID0gKGlzUGFyZW50RXhwYW5kZWQgfHwgIWlzUGFyZW50QXJyYXkgfHwga2V5ICE9ICtrZXkpO1xuPC9zY3JpcHQ+XG48c3R5bGU+XG4gIGxhYmVsIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgY29sb3I6IHZhcigtLWxhYmVsLWNvbG9yKTtcbiAgICBtYXJnaW46IDA7XG4gIH1cbiAgLnNwYWNlZCB7XG4gICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1saS1jb2xvbi1zcGFjZSk7XG4gIH1cbjwvc3R5bGU+XG57I2lmIHNob3dLZXkgJiYga2V5fVxuICA8bGFiZWwgY2xhc3M6c3BhY2VkPXtpc1BhcmVudEV4cGFuZGVkfT5cbiAgICA8c3Bhbj57a2V5fXtjb2xvbn08L3NwYW4+XG4gIDwvbGFiZWw+XG57L2lmfSIsImV4cG9ydCBkZWZhdWx0IHt9OyIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQsIHNldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgY29udGV4dEtleSBmcm9tICcuL2NvbnRleHQnO1xuICBpbXBvcnQgSlNPTkFycm93IGZyb20gJy4vSlNPTkFycm93LnN2ZWx0ZSc7XG4gIGltcG9ydCBKU09OTm9kZSBmcm9tICcuL0pTT05Ob2RlLnN2ZWx0ZSc7XG4gIGltcG9ydCBKU09OS2V5IGZyb20gJy4vSlNPTktleS5zdmVsdGUnO1xuXG4gIGV4cG9ydCBsZXQga2V5LCBrZXlzLCBjb2xvbiA9ICc6JywgbGFiZWwgPSAnJywgaXNQYXJlbnRFeHBhbmRlZCwgaXNQYXJlbnRBcnJheSwgaXNBcnJheSA9IGZhbHNlLCBicmFja2V0T3BlbiwgYnJhY2tldENsb3NlO1xuICBleHBvcnQgbGV0IHByZXZpZXdLZXlzID0ga2V5cztcbiAgZXhwb3J0IGxldCBnZXRLZXkgPSBrZXkgPT4ga2V5O1xuICBleHBvcnQgbGV0IGdldFZhbHVlID0ga2V5ID0+IGtleTtcbiAgZXhwb3J0IGxldCBnZXRQcmV2aWV3VmFsdWUgPSBnZXRWYWx1ZTtcbiAgZXhwb3J0IGxldCBleHBhbmRlZCA9IGZhbHNlLCBleHBhbmRhYmxlID0gdHJ1ZTtcblxuICBjb25zdCBjb250ZXh0ID0gZ2V0Q29udGV4dChjb250ZXh0S2V5KTtcbiAgc2V0Q29udGV4dChjb250ZXh0S2V5LCB7IC4uLmNvbnRleHQsIGNvbG9uIH0pXG5cbiAgJDogc2xpY2VkS2V5cyA9IGV4cGFuZGVkID8ga2V5czogcHJldmlld0tleXMuc2xpY2UoMCwgNSk7XG5cbiAgJDogaWYgKCFpc1BhcmVudEV4cGFuZGVkKSB7XG4gICAgZXhwYW5kZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZUV4cGFuZCgpIHtcbiAgICBleHBhbmRlZCA9ICFleHBhbmRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZCgpIHtcbiAgICBleHBhbmRlZCA9IHRydWU7XG4gIH1cblxuPC9zY3JpcHQ+XG48c3R5bGU+XG4gIC5pbmRlbnQge1xuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1saS1pZGVudGF0aW9uKTtcbiAgfVxuICAuY29sbGFwc2Uge1xuICAgIC0tbGktZGlzcGxheTogaW5saW5lO1xuICAgIGRpc3BsYXk6IGlubGluZTtcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gIH1cbiAgLmNvbW1hIHtcbiAgICBtYXJnaW4tbGVmdDogLTAuNWVtO1xuICAgIG1hcmdpbi1yaWdodDogMC41ZW07XG4gIH1cbjwvc3R5bGU+XG48bGkgY2xhc3M6aW5kZW50PXtpc1BhcmVudEV4cGFuZGVkfT5cbiAgeyNpZiBleHBhbmRhYmxlICYmIGlzUGFyZW50RXhwYW5kZWR9XG4gICAgPEpTT05BcnJvdyBvbjpjbGljaz17dG9nZ2xlRXhwYW5kfSB7ZXhwYW5kZWR9IC8+XG4gIHsvaWZ9XG4gIDxKU09OS2V5IHtrZXl9IGNvbG9uPXtjb250ZXh0LmNvbG9ufSB7aXNQYXJlbnRFeHBhbmRlZH0ge2lzUGFyZW50QXJyYXl9IC8+XG4gIDxzcGFuPjxzcGFuIG9uOmNsaWNrPXt0b2dnbGVFeHBhbmR9PntsYWJlbH08L3NwYW4+e2JyYWNrZXRPcGVufTwvc3Bhbj5cbiAgICB7I2lmIGlzUGFyZW50RXhwYW5kZWR9XG4gICAgICA8dWwgY2xhc3M6Y29sbGFwc2U9eyFleHBhbmRlZH0gb246Y2xpY2s9e2V4cGFuZH0+XG4gICAgICAgIHsjZWFjaCBzbGljZWRLZXlzIGFzIGtleSwgaW5kZXh9XG4gICAgICAgICAgPEpTT05Ob2RlIGtleT17Z2V0S2V5KGtleSl9IGlzUGFyZW50RXhwYW5kZWQ9e2V4cGFuZGVkfSBpc1BhcmVudEFycmF5PXtpc0FycmF5fSB2YWx1ZT17ZXhwYW5kZWQgPyBnZXRWYWx1ZShrZXkpIDogZ2V0UHJldmlld1ZhbHVlKGtleSl9IC8+XG4gICAgICAgICAgeyNpZiAhZXhwYW5kZWQgJiYgaW5kZXggPCBwcmV2aWV3S2V5cy5sZW5ndGggLSAxfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjb21tYVwiPiw8L3NwYW4+XG4gICAgICAgICAgey9pZn1cbiAgICAgICAgey9lYWNofVxuICAgICAgICB7I2lmIHNsaWNlZEtleXMubGVuZ3RoIDwgcHJldmlld0tleXMubGVuZ3RoIH1cbiAgICAgICAgICA8c3Bhbj7igKY8L3NwYW4+XG4gICAgICAgIHsvaWZ9XG4gICAgICA8L3VsPlxuICAgIHs6ZWxzZX1cbiAgICAgIDxzcGFuPuKApjwvc3Bhbj5cbiAgICB7L2lmfVxuICA8c3Bhbj57YnJhY2tldENsb3NlfTwvc3Bhbj5cbjwvbGk+IiwiPHNjcmlwdD5cbiAgaW1wb3J0IEpTT05BcnJvdyBmcm9tICcuL0pTT05BcnJvdy5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTk5vZGUgZnJvbSAnLi9KU09OTm9kZS5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTktleSBmcm9tICcuL0pTT05LZXkuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05OZXN0ZWQgZnJvbSAnLi9KU09OTmVzdGVkLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBrZXksIHZhbHVlLCBpc1BhcmVudEV4cGFuZGVkLCBpc1BhcmVudEFycmF5LCBub2RlVHlwZTtcbiAgZXhwb3J0IGxldCBleHBhbmRlZCA9IGZhbHNlO1xuXG4gICQ6IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlW2tleV07XG4gIH1cbjwvc2NyaXB0PlxuPEpTT05OZXN0ZWRcbiAge2tleX1cbiAge2V4cGFuZGVkfVxuICB7aXNQYXJlbnRFeHBhbmRlZH1cbiAge2lzUGFyZW50QXJyYXl9XG4gIHtrZXlzfVxuICB7Z2V0VmFsdWV9XG4gIGxhYmVsPVwie25vZGVUeXBlfSBcIlxuICBicmFja2V0T3Blbj17J3snfVxuICBicmFja2V0Q2xvc2U9eyd9J31cbi8+IiwiPHNjcmlwdD5cbiAgaW1wb3J0IEpTT05BcnJvdyBmcm9tICcuL0pTT05BcnJvdy5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTk5vZGUgZnJvbSAnLi9KU09OTm9kZS5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTktleSBmcm9tICcuL0pTT05LZXkuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05OZXN0ZWQgZnJvbSAnLi9KU09OTmVzdGVkLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBrZXksIHZhbHVlLCBpc1BhcmVudEV4cGFuZGVkLCBpc1BhcmVudEFycmF5O1xuICBleHBvcnQgbGV0IGV4cGFuZGVkID0gZmFsc2U7XG4gIGNvbnN0IGZpbHRlcmVkS2V5ID0gbmV3IFNldChbJ2xlbmd0aCddKTtcblxuICAkOiBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICAkOiBwcmV2aWV3S2V5cyA9IGtleXMuZmlsdGVyKGtleSA9PiAhZmlsdGVyZWRLZXkuaGFzKGtleSkpO1xuXG4gIGZ1bmN0aW9uIGdldFZhbHVlKGtleSkge1xuICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICB9XG5cbjwvc2NyaXB0PlxuPEpTT05OZXN0ZWRcbiAge2tleX1cbiAge2V4cGFuZGVkfVxuICB7aXNQYXJlbnRFeHBhbmRlZH1cbiAge2lzUGFyZW50QXJyYXl9XG4gIGlzQXJyYXk9e3RydWV9XG4gIHtrZXlzfVxuICB7cHJldmlld0tleXN9XG4gIHtnZXRWYWx1ZX1cbiAgbGFiZWw9XCJBcnJheSh7dmFsdWUubGVuZ3RofSlcIlxuICBicmFja2V0T3Blbj1cIltcIlxuICBicmFja2V0Q2xvc2U9XCJdXCJcbi8+IiwiPHNjcmlwdD5cbiAgaW1wb3J0IEpTT05BcnJvdyBmcm9tICcuL0pTT05BcnJvdy5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTk5vZGUgZnJvbSAnLi9KU09OTm9kZS5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTktleSBmcm9tICcuL0pTT05LZXkuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05OZXN0ZWQgZnJvbSAnLi9KU09OTmVzdGVkLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBrZXksIHZhbHVlLCBpc1BhcmVudEV4cGFuZGVkLCBpc1BhcmVudEFycmF5LCBub2RlVHlwZTtcblxuICBsZXQga2V5cyA9IFtdO1xuXG4gICQ6IHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvcihjb25zdCBlbnRyeSBvZiB2YWx1ZSkge1xuICAgICAgcmVzdWx0LnB1c2goW2krKywgZW50cnldKTtcbiAgICB9XG4gICAga2V5cyA9IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtleShrZXkpIHtcbiAgICByZXR1cm4gU3RyaW5nKGtleVswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIGtleVsxXTtcbiAgfVxuPC9zY3JpcHQ+XG48SlNPTk5lc3RlZFxuICB7a2V5fVxuICB7aXNQYXJlbnRFeHBhbmRlZH1cbiAge2lzUGFyZW50QXJyYXl9XG4gIHtrZXlzfVxuICB7Z2V0S2V5fVxuICB7Z2V0VmFsdWV9XG4gIGlzQXJyYXk9e3RydWV9XG4gIGxhYmVsPVwie25vZGVUeXBlfSh7a2V5cy5sZW5ndGh9KVwiXG4gIGJyYWNrZXRPcGVuPXsneyd9XG4gIGJyYWNrZXRDbG9zZT17J30nfVxuLz4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBKU09OQXJyb3cgZnJvbSAnLi9KU09OQXJyb3cuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05Ob2RlIGZyb20gJy4vSlNPTk5vZGUuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05LZXkgZnJvbSAnLi9KU09OS2V5LnN2ZWx0ZSc7XG4gIGltcG9ydCBKU09OTmVzdGVkIGZyb20gJy4vSlNPTk5lc3RlZC5zdmVsdGUnO1xuICBpbXBvcnQgTWFwRW50cnkgZnJvbSAnLi91dGlscy9NYXBFbnRyeSdcblxuICBleHBvcnQgbGV0IGtleSwgdmFsdWUsIGlzUGFyZW50RXhwYW5kZWQsIGlzUGFyZW50QXJyYXksIG5vZGVUeXBlO1xuXG4gIGxldCBrZXlzID0gW107XG5cbiAgJDoge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yKGNvbnN0IGVudHJ5IG9mIHZhbHVlKSB7XG4gICAgICByZXN1bHQucHVzaChbaSsrLCBuZXcgTWFwRW50cnkoZW50cnlbMF0sIGVudHJ5WzFdKV0pO1xuICAgIH1cbiAgICBrZXlzID0gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGdldEtleShlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeVswXTtcbiAgfVxuICBmdW5jdGlvbiBnZXRWYWx1ZShlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeVsxXTtcbiAgfVxuPC9zY3JpcHQ+XG48SlNPTk5lc3RlZFxuICB7a2V5fVxuICB7aXNQYXJlbnRFeHBhbmRlZH1cbiAge2lzUGFyZW50QXJyYXl9XG4gIHtrZXlzfVxuICB7Z2V0S2V5fVxuICB7Z2V0VmFsdWV9XG4gIGxhYmVsPVwie25vZGVUeXBlfSh7a2V5cy5sZW5ndGh9KVwiXG4gIGNvbG9uPVwiXCJcbiAgYnJhY2tldE9wZW49eyd7J31cbiAgYnJhY2tldENsb3NlPXsnfSd9XG4vPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IEpTT05BcnJvdyBmcm9tICcuL0pTT05BcnJvdy5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTk5vZGUgZnJvbSAnLi9KU09OTm9kZS5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTktleSBmcm9tICcuL0pTT05LZXkuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05OZXN0ZWQgZnJvbSAnLi9KU09OTmVzdGVkLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBrZXksIHZhbHVlLCBpc1BhcmVudEV4cGFuZGVkLCBpc1BhcmVudEFycmF5O1xuICBleHBvcnQgbGV0IGV4cGFuZGVkID0gZmFsc2U7XG5cbiAgY29uc3Qga2V5cyA9IFsna2V5JywgJ3ZhbHVlJ107XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlW2tleV07XG4gIH1cbjwvc2NyaXB0PlxuPEpTT05OZXN0ZWRcbiAge2V4cGFuZGVkfVxuICB7aXNQYXJlbnRFeHBhbmRlZH1cbiAge2lzUGFyZW50QXJyYXl9XG4gIGtleT17aXNQYXJlbnRFeHBhbmRlZCA/IFN0cmluZyhrZXkpIDogdmFsdWUua2V5fVxuICB7a2V5c31cbiAge2dldFZhbHVlfVxuICBsYWJlbD17aXNQYXJlbnRFeHBhbmRlZCA/ICc6IEVudHJ5ICc6ICc9PiAnfVxuICBicmFja2V0T3Blbj17J3snfVxuICBicmFja2V0Q2xvc2U9eyd9J31cbi8+IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCBjb250ZXh0S2V5IGZyb20gJy4vY29udGV4dCc7XG5cbiAgaW1wb3J0IEpTT05LZXkgZnJvbSAnLi9KU09OS2V5LnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBrZXksIHZhbHVlLCB2YWx1ZUdldHRlciA9IG51bGwsIGlzUGFyZW50RXhwYW5kZWQsIGlzUGFyZW50QXJyYXksIG5vZGVUeXBlO1xuXG4gIGNvbnN0IHsgY29sb24gfSA9IGdldENvbnRleHQoY29udGV4dEtleSk7XG48L3NjcmlwdD5cbjxzdHlsZT5cbiAgbGkge1xuICAgIHVzZXItc2VsZWN0OiB0ZXh0O1xuICAgIHdvcmQtd3JhcDogYnJlYWstd29yZDtcbiAgICB3b3JkLWJyZWFrOiBicmVhay1hbGw7XG4gIH1cbiAgLmluZGVudCB7XG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLWxpLWlkZW50YXRpb24pO1xuICB9XG4gIC5TdHJpbmcge1xuICAgIGNvbG9yOiB2YXIoLS1zdHJpbmctY29sb3IpO1xuICB9XG4gIC5EYXRlIHtcbiAgICBjb2xvcjogdmFyKC0tZGF0ZS1jb2xvcik7XG4gIH1cbiAgLk51bWJlciB7XG4gICAgY29sb3I6IHZhcigtLW51bWJlci1jb2xvcik7XG4gIH1cbiAgLkJvb2xlYW4ge1xuICAgIGNvbG9yOiB2YXIoLS1ib29sZWFuLWNvbG9yKTtcbiAgfVxuICAuTnVsbCB7XG4gICAgY29sb3I6IHZhcigtLW51bGwtY29sb3IpO1xuICB9XG4gIC5VbmRlZmluZWQge1xuICAgIGNvbG9yOiB2YXIoLS11bmRlZmluZWQtY29sb3IpO1xuICB9XG4gIC5GdW5jdGlvbiB7XG4gICAgY29sb3I6IHZhcigtLWZ1bmN0aW9uLWNvbG9yKTtcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gIH1cbiAgLlN5bWJvbCB7XG4gICAgY29sb3I6IHZhcigtLXN5bWJvbC1jb2xvcik7XG4gIH1cbjwvc3R5bGU+XG48bGkgY2xhc3M6aW5kZW50PXtpc1BhcmVudEV4cGFuZGVkfT5cbiAgPEpTT05LZXkge2tleX0ge2NvbG9ufSB7aXNQYXJlbnRFeHBhbmRlZH0ge2lzUGFyZW50QXJyYXl9IC8+XG4gIDxzcGFuIGNsYXNzPXtub2RlVHlwZX0+XG4gICAge3ZhbHVlR2V0dGVyID8gdmFsdWVHZXR0ZXIodmFsdWUpIDogdmFsdWV9XG4gIDwvc3Bhbj5cbjwvbGk+IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCwgc2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCBjb250ZXh0S2V5IGZyb20gJy4vY29udGV4dCc7XG4gIGltcG9ydCBKU09OQXJyb3cgZnJvbSAnLi9KU09OQXJyb3cuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05Ob2RlIGZyb20gJy4vSlNPTk5vZGUuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05LZXkgZnJvbSAnLi9KU09OS2V5LnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBrZXksIHZhbHVlLCBpc1BhcmVudEV4cGFuZGVkLCBpc1BhcmVudEFycmF5O1xuICBleHBvcnQgbGV0IGV4cGFuZGVkID0gZmFsc2U7XG5cbiAgJDogc3RhY2sgPSB2YWx1ZS5zdGFjay5zcGxpdCgnXFxuJyk7XG5cbiAgY29uc3QgY29udGV4dCA9IGdldENvbnRleHQoY29udGV4dEtleSk7XG4gIHNldENvbnRleHQoY29udGV4dEtleSwgeyAuLi5jb250ZXh0LCBjb2xvbjogJzonIH0pXG5cbiAgJDogaWYgKCFpc1BhcmVudEV4cGFuZGVkKSB7XG4gICAgZXhwYW5kZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvZ2dsZUV4cGFuZCgpIHtcbiAgICBleHBhbmRlZCA9ICFleHBhbmRlZDtcbiAgfVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4gIGxpIHtcbiAgICB1c2VyLXNlbGVjdDogdGV4dDtcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gICAgd29yZC1icmVhazogYnJlYWstYWxsO1xuICB9XG4gIC5pbmRlbnQge1xuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1saS1pZGVudGF0aW9uKTtcbiAgfVxuICAuY29sbGFwc2Uge1xuICAgIC0tbGktZGlzcGxheTogaW5saW5lO1xuICAgIGRpc3BsYXk6IGlubGluZTtcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gIH1cbjwvc3R5bGU+XG48bGkgY2xhc3M6aW5kZW50PXtpc1BhcmVudEV4cGFuZGVkfT5cbiAgeyNpZiBpc1BhcmVudEV4cGFuZGVkfVxuICAgIDxKU09OQXJyb3cgb246Y2xpY2s9e3RvZ2dsZUV4cGFuZH0ge2V4cGFuZGVkfSAvPlxuICB7L2lmfVxuICA8SlNPTktleSB7a2V5fSBjb2xvbj17Y29udGV4dC5jb2xvbn0ge2lzUGFyZW50RXhwYW5kZWR9IHtpc1BhcmVudEFycmF5fSAvPlxuICA8c3BhbiBvbjpjbGljaz17dG9nZ2xlRXhwYW5kfT5FcnJvcjoge2V4cGFuZGVkPycnOnZhbHVlLm1lc3NhZ2V9PC9zcGFuPlxuICB7I2lmIGlzUGFyZW50RXhwYW5kZWR9XG4gICAgPHVsIGNsYXNzOmNvbGxhcHNlPXshZXhwYW5kZWR9PlxuICAgICAgeyNpZiBleHBhbmRlZH1cbiAgICAgICAgPEpTT05Ob2RlIGtleT1cIm1lc3NhZ2VcIiB2YWx1ZT17dmFsdWUubWVzc2FnZX0gLz5cbiAgICAgICAgPGxpPlxuICAgICAgICAgIDxKU09OS2V5IGtleT1cInN0YWNrXCIgY29sb249XCI6XCIge2lzUGFyZW50RXhwYW5kZWR9IC8+XG4gICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICB7I2VhY2ggc3RhY2sgYXMgbGluZSwgaW5kZXh9XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzOmluZGVudD17aW5kZXggPiAwfT57bGluZX08L3NwYW4+PGJyIC8+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2xpPlxuICAgICAgey9pZn1cbiAgICA8L3VsPlxuICB7L2lmfVxuPC9saT4iLCI8c2NyaXB0PlxuICBpbXBvcnQgSlNPTk9iamVjdE5vZGUgZnJvbSAnLi9KU09OT2JqZWN0Tm9kZS5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTkFycmF5Tm9kZSBmcm9tICcuL0pTT05BcnJheU5vZGUuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05JdGVyYWJsZUFycmF5Tm9kZSBmcm9tICcuL0pTT05JdGVyYWJsZUFycmF5Tm9kZS5zdmVsdGUnO1xuICBpbXBvcnQgSlNPTkl0ZXJhYmxlTWFwTm9kZSBmcm9tICcuL0pTT05JdGVyYWJsZU1hcE5vZGUuc3ZlbHRlJztcbiAgaW1wb3J0IEpTT05NYXBFbnRyeU5vZGUgZnJvbSAnLi9KU09OTWFwRW50cnlOb2RlLnN2ZWx0ZSc7XG4gIGltcG9ydCBKU09OVmFsdWVOb2RlIGZyb20gJy4vSlNPTlZhbHVlTm9kZS5zdmVsdGUnO1xuICBpbXBvcnQgRXJyb3JOb2RlIGZyb20gJy4vRXJyb3JOb2RlLnN2ZWx0ZSc7XG4gIGltcG9ydCBvYmpUeXBlIGZyb20gJy4vb2JqVHlwZSc7XG5cbiAgZXhwb3J0IGxldCBrZXksIHZhbHVlLCBpc1BhcmVudEV4cGFuZGVkLCBpc1BhcmVudEFycmF5O1xuICBjb25zdCBub2RlVHlwZSA9IG9ialR5cGUodmFsdWUpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgbm9kZVR5cGUgPT09ICdPYmplY3QnfVxuICA8SlNPTk9iamVjdE5vZGUge2tleX0ge3ZhbHVlfSB7aXNQYXJlbnRFeHBhbmRlZH0ge2lzUGFyZW50QXJyYXl9IHtub2RlVHlwZX0gLz5cbns6ZWxzZSBpZiBub2RlVHlwZSA9PT0gJ0Vycm9yJ31cbiAgPEVycm9yTm9kZSB7a2V5fSB7dmFsdWV9IHtpc1BhcmVudEV4cGFuZGVkfSB7aXNQYXJlbnRBcnJheX0gLz5cbns6ZWxzZSBpZiBub2RlVHlwZSA9PT0gJ0FycmF5J31cbiAgPEpTT05BcnJheU5vZGUge2tleX0ge3ZhbHVlfSB7aXNQYXJlbnRFeHBhbmRlZH0ge2lzUGFyZW50QXJyYXl9IC8+XG57OmVsc2UgaWYgbm9kZVR5cGUgPT09ICdJdGVyYWJsZScgfHwgbm9kZVR5cGUgPT09ICdNYXAnIHx8IG5vZGVUeXBlID09PSAnU2V0J31cbiAgeyNpZiB0eXBlb2YgdmFsdWUuc2V0ID09PSAnZnVuY3Rpb24nfVxuICAgIDxKU09OSXRlcmFibGVNYXBOb2RlIHtrZXl9IHt2YWx1ZX0ge2lzUGFyZW50RXhwYW5kZWR9IHtpc1BhcmVudEFycmF5fSB7bm9kZVR5cGV9IC8+XG4gIHs6ZWxzZX1cbiAgICA8SlNPTkl0ZXJhYmxlQXJyYXlOb2RlIHtrZXl9IHt2YWx1ZX0ge2lzUGFyZW50RXhwYW5kZWR9IHtpc1BhcmVudEFycmF5fSB7bm9kZVR5cGV9IC8+XG4gIHsvaWZ9XG57OmVsc2UgaWYgbm9kZVR5cGUgPT09ICdNYXBFbnRyeSd9XG4gIDxKU09OTWFwRW50cnlOb2RlIHtrZXl9IHt2YWx1ZX0ge2lzUGFyZW50RXhwYW5kZWR9IHtpc1BhcmVudEFycmF5fSB7bm9kZVR5cGV9IC8+XG57OmVsc2UgaWYgbm9kZVR5cGUgPT09ICdTdHJpbmcnfSAgXG4gIDxKU09OVmFsdWVOb2RlIHtrZXl9IHt2YWx1ZX0ge2lzUGFyZW50RXhwYW5kZWR9IHtpc1BhcmVudEFycmF5fSB7bm9kZVR5cGV9IHZhbHVlR2V0dGVyPXtyYXcgPT4gYFwiJHtyYXd9XCJgfSAvPlxuezplbHNlIGlmIG5vZGVUeXBlID09PSAnTnVtYmVyJ31cbiAgPEpTT05WYWx1ZU5vZGUge2tleX0ge3ZhbHVlfSB7aXNQYXJlbnRFeHBhbmRlZH0ge2lzUGFyZW50QXJyYXl9IHtub2RlVHlwZX0gLz5cbns6ZWxzZSBpZiBub2RlVHlwZSA9PT0gJ0Jvb2xlYW4nfVxuICA8SlNPTlZhbHVlTm9kZSB7a2V5fSB7dmFsdWV9IHtpc1BhcmVudEV4cGFuZGVkfSB7aXNQYXJlbnRBcnJheX0ge25vZGVUeXBlfSB2YWx1ZUdldHRlcj17cmF3ID0+IChyYXcgPyAndHJ1ZScgOiAnZmFsc2UnKX0gLz5cbns6ZWxzZSBpZiBub2RlVHlwZSA9PT0gJ0RhdGUnfVxuICA8SlNPTlZhbHVlTm9kZSB7a2V5fSB7dmFsdWV9IHtpc1BhcmVudEV4cGFuZGVkfSB7aXNQYXJlbnRBcnJheX0ge25vZGVUeXBlfSB2YWx1ZUdldHRlcj17cmF3ID0+IHJhdy50b0lTT1N0cmluZygpfSAvPlxuezplbHNlIGlmIG5vZGVUeXBlID09PSAnTnVsbCd9XG4gIDxKU09OVmFsdWVOb2RlIHtrZXl9IHt2YWx1ZX0ge2lzUGFyZW50RXhwYW5kZWR9IHtpc1BhcmVudEFycmF5fSB7bm9kZVR5cGV9IHZhbHVlR2V0dGVyPXsoKSA9PiAnbnVsbCd9IC8+XG57OmVsc2UgaWYgbm9kZVR5cGUgPT09ICdVbmRlZmluZWQnfVxuICA8SlNPTlZhbHVlTm9kZSB7a2V5fSB7dmFsdWV9IHtpc1BhcmVudEV4cGFuZGVkfSB7aXNQYXJlbnRBcnJheX0ge25vZGVUeXBlfSB2YWx1ZUdldHRlcj17KCkgPT4gJ3VuZGVmaW5lZCd9IC8+XG57OmVsc2UgaWYgbm9kZVR5cGUgPT09ICdGdW5jdGlvbicgfHwgbm9kZVR5cGUgPT09ICdTeW1ib2wnfVxuICA8SlNPTlZhbHVlTm9kZSB7a2V5fSB7dmFsdWV9IHtpc1BhcmVudEV4cGFuZGVkfSB7aXNQYXJlbnRBcnJheX0ge25vZGVUeXBlfSB2YWx1ZUdldHRlcj17cmF3ID0+IHJhdy50b1N0cmluZygpfSAvPlxuezplbHNlfVxuICA8SlNPTlZhbHVlTm9kZSB7a2V5fSB7dmFsdWV9IHtpc1BhcmVudEV4cGFuZGVkfSB7aXNQYXJlbnRBcnJheX0ge25vZGVUeXBlfSB2YWx1ZUdldHRlcj17KCkgPT4gYDwke25vZGVUeXBlfT5gfSAvPlxuey9pZn0iLCI8c2NyaXB0PlxuICBpbXBvcnQgSlNPTk5vZGUgZnJvbSAnLi9KU09OTm9kZS5zdmVsdGUnO1xuICBpbXBvcnQgeyBzZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IGNvbnRleHRLZXkgZnJvbSAnLi9jb250ZXh0JztcblxuICBzZXRDb250ZXh0KGNvbnRleHRLZXksIHt9KTtcblxuICBleHBvcnQgbGV0IGtleSA9ICcnLCB2YWx1ZTtcbjwvc2NyaXB0PlxuPHN0eWxlPlxuICB1bCB7XG4gICAgLS1zdHJpbmctY29sb3I6ICNjYjNmNDE7XG4gICAgLS1zeW1ib2wtY29sb3I6ICNjYjNmNDE7XG4gICAgLS1ib29sZWFuLWNvbG9yOiAjMTEyYWE3O1xuICAgIC0tZnVuY3Rpb24tY29sb3I6ICMxMTJhYTc7XG4gICAgLS1udW1iZXItY29sb3I6ICMzMDI5Y2Y7XG4gICAgLS1sYWJlbC1jb2xvcjogIzg3MWQ4ZjtcbiAgICAtLWFycm93LWNvbG9yOiAjNzI3MjcyO1xuICAgIC0tbnVsbC1jb2xvcjogIzhkOGQ4ZDtcbiAgICAtLXVuZGVmaW5lZC1jb2xvcjogIzhkOGQ4ZDtcbiAgICAtLWRhdGUtY29sb3I6ICM4ZDhkOGQ7XG4gICAgLS1saS1pZGVudGF0aW9uOiAxZW07XG4gICAgLS1saS1jb2xvbi1zcGFjZTogMC4zZW07XG4gICAgZm9udC1zaXplOiB2YXIoLS1qc29uLXRyZWUtZm9udC1zaXplLCAxMnB4KTtcbiAgICBmb250LWZhbWlseTogJ0NvdXJpZXIgTmV3JywgQ291cmllciwgbW9ub3NwYWNlO1xuICB9XG4gIHVsIDpnbG9iYWwobGkpIHtcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tbGktbGluZS1oZWlnaHQsIDEuMyk7XG4gICAgZGlzcGxheTogdmFyKC0tbGktZGlzcGxheSwgbGlzdC1pdGVtKTtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICB9XG4gIHVsLCB1bCA6Z2xvYmFsKHVsKSB7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDA7XG4gIH1cbjwvc3R5bGU+XG48dWw+XG4gIDxKU09OTm9kZSB7a2V5fSB7dmFsdWV9IGlzUGFyZW50RXhwYW5kZWQ9e3RydWV9IGlzUGFyZW50QXJyYXk9e2ZhbHNlfSAvPlxuPC91bD5cbiIsIjxzY3JpcHQ+XG5cdGltcG9ydCBKU09OTm9kZSBmcm9tICdzdmVsdGUtanNvbi10cmVlJztcblxuXHRleHBvcnQgbGV0IGxvZ3M7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuXHR7I2VhY2ggbG9ncyBhcyBsb2d9XG5cdFx0PGRpdiBjbGFzcz1cImxvZyBjb25zb2xlLXtsb2cubGV2ZWx9XCI+XG5cdFx0XHR7I2lmIGxvZy5jb3VudCA+IDF9XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiY291bnRcIj57bG9nLmNvdW50fXg8L3NwYW4+XG5cdFx0XHR7L2lmfVxuXG5cdFx0XHR7I2lmIGxvZy5sZXZlbCA9PT0gJ2NsZWFyJ31cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpbmZvXCI+Q29uc29sZSB3YXMgY2xlYXJlZDwvc3Bhbj5cblx0XHRcdHs6ZWxzZSBpZiBsb2cubGV2ZWwgPT09ICd1bmNsb25hYmxlJ31cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpbmZvIGVycm9yXCI+TWVzc2FnZSBjb3VsZCBub3QgYmUgY2xvbmVkLiBPcGVuIGRldnRvb2xzIHRvIHNlZSBpdDwvc3Bhbj5cblx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0eyNlYWNoIGxvZy5hcmdzIGFzIGFyZ31cblx0XHRcdFx0XHQ8SlNPTk5vZGUgdmFsdWU9e2FyZ30gLz5cblx0XHRcdFx0ey9lYWNofVxuXHRcdFx0ey9pZn1cblx0XHQ8L2Rpdj5cblx0ey9lYWNofVxuPC9kaXY+XG5cbjxzdHlsZT5cblx0LmxvZyB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XG5cdFx0cGFkZGluZzogNXB4IDEwcHg7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0fVxuXG5cdC5sb2cgPiA6Z2xvYmFsKCopIHtcblx0XHRtYXJnaW4tcmlnaHQ6IDEwcHg7XG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWZvbnQtbW9ubyk7XG5cdH1cblxuXHQuY29uc29sZS13YXJuIHtcblx0XHRiYWNrZ3JvdW5kOiAjZmZmYmU2O1xuXHRcdGJvcmRlci1jb2xvcjogI2ZmZjRjNDtcblx0fVxuXG5cdC5jb25zb2xlLWVycm9yIHtcblx0XHRiYWNrZ3JvdW5kOiAjZmZmMGYwO1xuXHRcdGJvcmRlci1jb2xvcjogI2ZlZDZkNztcblx0fVxuXG5cdC5jb3VudCB7XG5cdFx0Y29sb3I6ICM5OTk7XG5cdFx0Zm9udC1zaXplOiAxMnB4O1xuXHRcdGxpbmUtaGVpZ2h0OiAxLjI7XG5cdH1cblxuXHQuaW5mbyB7XG5cdFx0Y29sb3I6ICM2NjY7XG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWZvbnQpICFpbXBvcnRhbnQ7XG5cdFx0Zm9udC1zaXplOiAxMnB4O1xuXHR9XG5cblx0LmVycm9yIHtcblx0XHRjb2xvcjogI2RhMTA2ZTsgLyogdG9kbyBtYWtlIHRoaXMgYSB2YXIgKi9cblx0fVxuPC9zdHlsZT4iLCJleHBvcnQgZGVmYXVsdCBcIjwhZG9jdHlwZSBodG1sPlxcbjxodG1sPlxcblxcdDxoZWFkPlxcblxcdFxcdDxzdHlsZT5cXG5cXHRcXHRcXHRodG1sLCBib2R5IHtcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxuXFx0d2lkdGg6IDEwMCU7XFxuXFx0aGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5ib2R5IHtcXG5cXHRjb2xvcjogIzMzMztcXG5cXHRtYXJnaW46IDA7XFxuXFx0cGFkZGluZzogOHB4O1xcblxcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuXFx0Zm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXFxcIlNlZ29lIFVJXFxcIiwgUm9ib3RvLCBPeHlnZW4tU2FucywgVWJ1bnR1LCBDYW50YXJlbGwsIFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIHNhbnMtc2VyaWY7XFxufVxcblxcbmEge1xcblxcdGNvbG9yOiByZ2IoMCwxMDAsMjAwKTtcXG5cXHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcblxcbmE6aG92ZXIge1xcblxcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG5hOnZpc2l0ZWQge1xcblxcdGNvbG9yOiByZ2IoMCw4MCwxNjApO1xcbn1cXG5cXG5sYWJlbCB7XFxuXFx0ZGlzcGxheTogYmxvY2s7XFxufVxcblxcbmlucHV0LCBidXR0b24sIHNlbGVjdCwgdGV4dGFyZWEge1xcblxcdGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcblxcdGZvbnQtc2l6ZTogaW5oZXJpdDtcXG5cXHRwYWRkaW5nOiAwLjRlbTtcXG5cXHRtYXJnaW46IDAgMCAwLjVlbSAwO1xcblxcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI2NjYztcXG5cXHRib3JkZXItcmFkaXVzOiAycHg7XFxufVxcblxcbmlucHV0OmRpc2FibGVkIHtcXG5cXHRjb2xvcjogI2NjYztcXG59XFxuXFxuaW5wdXRbdHlwZT1cXFwicmFuZ2VcXFwiXSB7XFxuXFx0aGVpZ2h0OiAwO1xcbn1cXG5cXG5idXR0b24ge1xcblxcdGNvbG9yOiAjMzMzO1xcblxcdGJhY2tncm91bmQtY29sb3I6ICNmNGY0ZjQ7XFxuXFx0b3V0bGluZTogbm9uZTtcXG59XFxuXFxuYnV0dG9uOmRpc2FibGVkIHtcXG5cXHRjb2xvcjogIzk5OTtcXG59XFxuXFxuYnV0dG9uOm5vdCg6ZGlzYWJsZWQpOmFjdGl2ZSB7XFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2RkZDtcXG59XFxuXFxuYnV0dG9uOmZvY3VzIHtcXG5cXHRib3JkZXItY29sb3I6ICM2NjY7XFxufVxcblxcblxcdFxcdDwvc3R5bGU+XFxuXFxuXFx0XFx0PHNjcmlwdD5cXG5cXHRcXHRcXHQoZnVuY3Rpb24oKXtcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBoYW5kbGVfbWVzc2FnZShldikge1xcblxcdFxcdFxcdFxcdFxcdGxldCB7IGFjdGlvbiwgY21kX2lkIH0gPSBldi5kYXRhO1xcblxcdFxcdFxcdFxcdFxcdGNvbnN0IHNlbmRfbWVzc2FnZSA9IChwYXlsb2FkKSA9PiBwYXJlbnQucG9zdE1lc3NhZ2UoIHsgLi4ucGF5bG9hZCB9LCBldi5vcmlnaW4pO1xcblxcdFxcdFxcdFxcdFxcdGNvbnN0IHNlbmRfcmVwbHkgPSAocGF5bG9hZCkgPT4gc2VuZF9tZXNzYWdlKHsgLi4ucGF5bG9hZCwgY21kX2lkIH0pO1xcblxcdFxcdFxcdFxcdFxcdGNvbnN0IHNlbmRfb2sgPSAoKSA9PiBzZW5kX3JlcGx5KHsgYWN0aW9uOiAnY21kX29rJyB9KTtcXG5cXHRcXHRcXHRcXHRcXHRjb25zdCBzZW5kX2Vycm9yID0gKG1lc3NhZ2UsIHN0YWNrKSA9PiBzZW5kX3JlcGx5KHsgYWN0aW9uOiAnY21kX2Vycm9yJywgbWVzc2FnZSwgc3RhY2sgfSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGFjdGlvbiA9PT0gJ2V2YWwnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zdCB7IHNjcmlwdCB9ID0gZXYuZGF0YS5hcmdzO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGV2YWwoc2NyaXB0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZW5kX29rKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBjYXRjaCAoZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbmRfZXJyb3IoZS5tZXNzYWdlLCBlLnN0YWNrKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChhY3Rpb24gPT09ICdjYXRjaF9jbGlja3MnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zdCB0b3Bfb3JpZ2luID0gZXYub3JpZ2luO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBldmVudCA9PiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LndoaWNoICE9PSAxKSByZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSkgcmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZW5zdXJlIHRhcmdldCBpcyBhIGxpbmtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRsZXQgZWwgPSBldmVudC50YXJnZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGVsICYmIGVsLm5vZGVOYW1lICE9PSAnQScpIGVsID0gZWwucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWVsIHx8IGVsLm5vZGVOYW1lICE9PSAnQScpIHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZWwuaGFzQXR0cmlidXRlKCdkb3dubG9hZCcpIHx8IGVsLmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdleHRlcm5hbCcgfHwgZWwudGFyZ2V0KSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZWwuaHJlZi5zdGFydHNXaXRoKHRvcF9vcmlnaW4pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc3QgdXJsID0gbmV3IFVSTChlbC5ocmVmKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodXJsLmhhc2hbMF0gPT09ICcjJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gdXJsLmhhc2g7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2luZG93Lm9wZW4oZWwuaHJlZiwgJ19ibGFuaycpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbmRfb2soKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGNhdGNoKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZW5kX2Vycm9yKGUubWVzc2FnZSwgZS5zdGFjayk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVfbWVzc2FnZSwgZmFsc2UpO1xcblxcblxcdFxcdFxcdFxcdHdpbmRvdy5vbmVycm9yID0gZnVuY3Rpb24gKG1zZywgdXJsLCBsaW5lTm8sIGNvbHVtbk5vLCBlcnJvcikge1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudC5wb3N0TWVzc2FnZSh7IGFjdGlvbjogJ2Vycm9yJywgdmFsdWU6IGVycm9yIH0sICcqJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJ1bmhhbmRsZWRyZWplY3Rpb25cXFwiLCBldmVudCA9PiB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyZW50LnBvc3RNZXNzYWdlKHsgYWN0aW9uOiAndW5oYW5kbGVkcmVqZWN0aW9uJywgdmFsdWU6IGV2ZW50LnJlYXNvbiB9LCAnKicpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0pLmNhbGwodGhpcyk7XFxuXFxuXFx0XFx0XFx0Ly8gVE9ETyBoYW5kbGUgZ3JvdXAvZ3JvdXBFbmQsIHRhYmxlLCB0cmFjZSwgZXRjXFxuXFx0XFx0XFx0bGV0IHByZXZpb3VzID0geyBsZXZlbDogbnVsbCwgYXJnczogbnVsbCB9O1xcblxcblxcdFxcdFxcdFsnY2xlYXInLCAnbG9nJywgJ2luZm8nLCAnZGlyJywgJ3dhcm4nLCAnZXJyb3InXS5mb3JFYWNoKChsZXZlbCkgPT4ge1xcblxcdFxcdFxcdFxcdGNvbnN0IG9yaWdpbmFsID0gY29uc29sZVtsZXZlbF07XFxuXFx0XFx0XFx0XFx0Y29uc29sZVtsZXZlbF0gPSAoLi4uYXJncykgPT4ge1xcblxcdFxcdFxcdFxcdFxcdGlmIChcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcmV2aW91cy5sZXZlbCA9PT0gbGV2ZWwgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcmV2aW91cy5hcmdzLmxlbmd0aCA9PT0gYXJncy5sZW5ndGggJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcmV2aW91cy5hcmdzLmV2ZXJ5KChhLCBpKSA9PiBhID09PSBhcmdzW2ldKVxcblxcdFxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudC5wb3N0TWVzc2FnZSh7IGFjdGlvbjogJ2NvbnNvbGUnLCBsZXZlbCwgZHVwbGljYXRlOiB0cnVlIH0sICcqJyk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcmV2aW91cyA9IHsgbGV2ZWwsIGFyZ3MgfTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudC5wb3N0TWVzc2FnZSh7IGFjdGlvbjogJ2NvbnNvbGUnLCBsZXZlbCwgYXJncyB9LCAnKicpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKGVycikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudC5wb3N0TWVzc2FnZSh7IGFjdGlvbjogJ2NvbnNvbGUnLCBsZXZlbDogJ3VuY2xvbmFibGUnIH0sICcqJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRvcmlnaW5hbCguLi5hcmdzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSlcXG5cXHRcXHQ8L3NjcmlwdD5cXG5cXHQ8L2hlYWQ+XFxuXFx0PGJvZHk+PC9ib2R5PlxcbjwvaHRtbD5cIjsiLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBvbk1vdW50LCBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IGdldExvY2F0aW9uRnJvbVN0YWNrIGZyb20gJy4vZ2V0TG9jYXRpb25Gcm9tU3RhY2suanMnO1xuXHRpbXBvcnQgU3BsaXRQYW5lIGZyb20gJy4uL1NwbGl0UGFuZS5zdmVsdGUnO1xuXHRpbXBvcnQgUGFuZVdpdGhQYW5lbCBmcm9tICcuL1BhbmVXaXRoUGFuZWwuc3ZlbHRlJztcblx0aW1wb3J0IFJlcGxQcm94eSBmcm9tICcuL1JlcGxQcm94eS5qcyc7XG5cdGltcG9ydCBDb25zb2xlIGZyb20gJy4vQ29uc29sZS5zdmVsdGUnO1xuXHRpbXBvcnQgTWVzc2FnZSBmcm9tICcuLi9NZXNzYWdlLnN2ZWx0ZSc7XG5cdGltcG9ydCBzcmNkb2MgZnJvbSAnLi9zcmNkb2MvaW5kZXguanMnO1xuXG5cdGNvbnN0IHsgYnVuZGxlIH0gPSBnZXRDb250ZXh0KCdSRVBMJyk7XG5cblx0ZXhwb3J0IGxldCBlcnJvcjsgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBleHBvc2VkIGFzIGEgcHJvcD9cblx0bGV0IGxvZ3MgPSBbXTtcblxuXHRleHBvcnQgZnVuY3Rpb24gc2V0UHJvcChwcm9wLCB2YWx1ZSkge1xuXHRcdGlmICghcHJveHkpIHJldHVybjtcblx0XHRwcm94eS5zZXRQcm9wKHByb3AsIHZhbHVlKTtcblx0fVxuXG5cdGV4cG9ydCBsZXQgc3RhdHVzO1xuXHRleHBvcnQgbGV0IHJlbGF4ZWQgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBpbmplY3RlZEpTID0gJyc7XG5cdGV4cG9ydCBsZXQgaW5qZWN0ZWRDU1MgPSAnJztcblxuXHRsZXQgaWZyYW1lO1xuXHRsZXQgcGVuZGluZ19pbXBvcnRzID0gMDtcblx0bGV0IHBlbmRpbmcgPSBmYWxzZTtcblxuXHRsZXQgcHJveHkgPSBudWxsO1xuXG5cdGxldCByZWFkeSA9IGZhbHNlO1xuXHRsZXQgaW5pdGVkID0gZmFsc2U7XG5cblx0bGV0IGxvZ19oZWlnaHQgPSA5MDtcblx0bGV0IHByZXZfaGVpZ2h0O1xuXG5cdGxldCBsYXN0X2NvbnNvbGVfZXZlbnQ7XG5cblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0cHJveHkgPSBuZXcgUmVwbFByb3h5KGlmcmFtZSwge1xuXHRcdFx0b25fZmV0Y2hfcHJvZ3Jlc3M6IHByb2dyZXNzID0+IHtcblx0XHRcdFx0cGVuZGluZ19pbXBvcnRzID0gcHJvZ3Jlc3M7XG5cdFx0XHR9LFxuXHRcdFx0b25fZXJyb3I6IGV2ZW50ID0+IHtcblx0XHRcdFx0cHVzaF9sb2dzKHsgbGV2ZWw6ICdlcnJvcicsIGFyZ3M6IFtldmVudC52YWx1ZV19KTtcblx0XHRcdH0sXG5cdFx0XHRvbl91bmhhbmRsZWRfcmVqZWN0aW9uOiBldmVudCA9PiB7XG5cdFx0XHRcdGxldCBlcnJvciA9IGV2ZW50LnZhbHVlO1xuXHRcdFx0XHRpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykgZXJyb3IgPSB7IG1lc3NhZ2U6IGVycm9yIH07XG5cdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnVW5jYXVnaHQgKGluIHByb21pc2UpOiAnICsgZXJyb3IubWVzc2FnZTtcblx0XHRcdFx0cHVzaF9sb2dzKHsgbGV2ZWw6ICdlcnJvcicsIGFyZ3M6IFtlcnJvcl19KTtcblx0XHRcdH0sXG5cdFx0XHRvbl9jb25zb2xlOiBsb2cgPT4ge1xuXHRcdFx0XHRpZiAobG9nLmxldmVsID09PSAnY2xlYXInKSB7XG5cdFx0XHRcdFx0bG9ncyA9IFtsb2ddO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxvZy5kdXBsaWNhdGUpIHtcblx0XHRcdFx0XHRjb25zdCBsYXN0X2xvZyA9IGxvZ3NbbG9ncy5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdGlmIChsYXN0X2xvZykge1xuXHRcdFx0XHRcdFx0bGFzdF9sb2cuY291bnQgPSAobGFzdF9sb2cuY291bnQgfHwgMSkgKyAxO1xuXHRcdFx0XHRcdFx0bG9ncyA9IGxvZ3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxhc3RfY29uc29sZV9ldmVudC5jb3VudCA9IDE7XG5cdFx0XHRcdFx0XHRsb2dzID0gW2xhc3RfY29uc29sZV9ldmVudF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHB1c2hfbG9ncyhsb2cpO1xuXHRcdFx0XHRcdGxhc3RfY29uc29sZV9ldmVudCA9IGxvZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG5cdFx0XHRwcm94eS5oYW5kbGVfbGlua3MoKTtcblx0XHRcdHJlYWR5ID0gdHJ1ZTtcblx0XHR9KTtcblxuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHByb3h5LmRlc3Ryb3koKTtcblx0XHR9XG5cdH0pO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGFwcGx5X2J1bmRsZSgkYnVuZGxlKSB7XG5cdFx0aWYgKCEkYnVuZGxlIHx8ICRidW5kbGUuZXJyb3IpIHJldHVybjtcblxuXHRcdHRyeSB7XG5cdFx0XHRjbGVhcl9sb2dzKCk7XG5cblx0XHRcdGF3YWl0IHByb3h5LmV2YWwoYFxuXHRcdFx0XHQke2luamVjdGVkSlN9XG5cblx0XHRcdFx0JHtzdHlsZXN9XG5cblx0XHRcdFx0Y29uc3Qgc3R5bGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbaWRePXN2ZWx0ZS1dJyk7XG5cblx0XHRcdFx0JHskYnVuZGxlLmRvbS5jb2RlfVxuXG5cdFx0XHRcdGxldCBpID0gc3R5bGVzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKGktLSkgc3R5bGVzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVzW2ldKTtcblxuXHRcdFx0XHRpZiAod2luZG93LmNvbXBvbmVudCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHR3aW5kb3cuY29tcG9uZW50LiRkZXN0cm95KCk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0d2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcblx0XHRcdFx0d2luZG93Ll9zdmVsdGVUcmFuc2l0aW9uTWFuYWdlciA9IG51bGw7XG5cblx0XHRcdFx0d2luZG93LmNvbXBvbmVudCA9IG5ldyBTdmVsdGVDb21wb25lbnQuZGVmYXVsdCh7XG5cdFx0XHRcdFx0dGFyZ2V0OiBkb2N1bWVudC5ib2R5XG5cdFx0XHRcdH0pO1xuXHRcdFx0YCk7XG5cblx0XHRcdGVycm9yID0gbnVsbDtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRzaG93X2Vycm9yKGUpO1xuXHRcdH1cblxuXHRcdGluaXRlZCA9IHRydWU7XG5cdH1cblxuXHQkOiBpZiAocmVhZHkpIGFwcGx5X2J1bmRsZSgkYnVuZGxlKTtcblxuXHQkOiBzdHlsZXMgPSBpbmplY3RlZENTUyAmJiBge1xuXHRcdGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0XHRzdHlsZS50ZXh0Q29udGVudCA9ICR7SlNPTi5zdHJpbmdpZnkoaW5qZWN0ZWRDU1MpfTtcblx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fWA7XG5cblx0ZnVuY3Rpb24gc2hvd19lcnJvcihlKSB7XG5cdFx0Y29uc3QgbG9jID0gZ2V0TG9jYXRpb25Gcm9tU3RhY2soZS5zdGFjaywgJGJ1bmRsZS5kb20ubWFwKTtcblx0XHRpZiAobG9jKSB7XG5cdFx0XHRlLmZpbGVuYW1lID0gbG9jLnNvdXJjZTtcblx0XHRcdGUubG9jID0geyBsaW5lOiBsb2MubGluZSwgY29sdW1uOiBsb2MuY29sdW1uIH07XG5cdFx0fVxuXG5cdFx0ZXJyb3IgPSBlO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHVzaF9sb2dzKGxvZykge1xuXHRcdGxvZ3MgPSBbLi4ubG9ncywgbG9nXTtcblx0fVxuXG5cdGZ1bmN0aW9uIG9uX3RvZ2dsZV9jb25zb2xlKCkge1xuXHRcdGlmIChsb2dfaGVpZ2h0IDwgOTApIHtcblx0XHRcdHByZXZfaGVpZ2h0ID0gbG9nX2hlaWdodDtcblx0XHRcdGxvZ19oZWlnaHQgPSA5MDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nX2hlaWdodCA9IHByZXZfaGVpZ2h0IHx8IDQ1O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNsZWFyX2xvZ3MoKSB7XG5cdFx0bG9ncyA9IFtdO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuaWZyYW1lLWNvbnRhaW5lciB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cblxuXHRpZnJhbWUge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHQvKiBoZWlnaHQ6IGNhbGMoMTAwdmggLSB2YXIoLS1uYXYtaCkpOyAqL1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0fVxuXG5cdC5ncmV5ZWQtb3V0IHtcblx0XHRmaWx0ZXI6IGdyYXlzY2FsZSg1MCUpIGJsdXIoMXB4KTtcblx0XHRvcGFjaXR5OiAuMjU7XG5cdH1cblxuXHRidXR0b24ge1xuXHRcdGNvbG9yOiAjOTk5O1xuXHRcdGZvbnQtc2l6ZTogMTJweDtcblx0XHR0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHR9XG5cblx0YnV0dG9uOmhvdmVyIHtcblx0XHRjb2xvcjogIzMzMztcblx0fVxuXG5cdC5vdmVybGF5IHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiaWZyYW1lLWNvbnRhaW5lclwiPlxuXHQ8UGFuZVdpdGhQYW5lbCBwb3M9ezEwMH0gcGFuZWw9XCJDb25zb2xlXCI+XG5cdFx0PGRpdiBzbG90PVwibWFpblwiPlxuXHRcdFx0PGlmcmFtZVxuXHRcdFx0XHR0aXRsZT1cIlJlc3VsdFwiXG5cdFx0XHRcdGNsYXNzOmluaXRlZFxuXHRcdFx0XHRiaW5kOnRoaXM9e2lmcmFtZX1cblx0XHRcdFx0c2FuZGJveD1cImFsbG93LXBvcHVwcy10by1lc2NhcGUtc2FuZGJveCBhbGxvdy1zY3JpcHRzIGFsbG93LXBvcHVwcyBhbGxvdy1mb3JtcyBhbGxvdy1wb2ludGVyLWxvY2sgYWxsb3ctdG9wLW5hdmlnYXRpb24gYWxsb3ctbW9kYWxzIHtyZWxheGVkID8gJ2FsbG93LXNhbWUtb3JpZ2luJyA6ICcnfVwiXG5cdFx0XHRcdGNsYXNzPVwie2Vycm9yIHx8IHBlbmRpbmcgfHwgcGVuZGluZ19pbXBvcnRzID8gJ2dyZXllZC1vdXQnIDogJyd9XCJcblx0XHRcdFx0e3NyY2RvY31cblx0XHRcdD48L2lmcmFtZT5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgc2xvdD1cInBhbmVsLWhlYWRlclwiPlxuXHRcdFx0PGJ1dHRvbiBvbjpjbGlja3xzdG9wUHJvcGFnYXRpb249e2NsZWFyX2xvZ3N9PlxuXHRcdFx0XHR7I2lmIChsb2dzLmxlbmd0aCA+IDApfSh7bG9ncy5sZW5ndGh9KXsvaWZ9XG5cdFx0XHRcdENsZWFyXG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQ8L2Rpdj5cblxuXHRcdDxzZWN0aW9uIHNsb3Q9XCJwYW5lbC1ib2R5XCI+XG5cdFx0XHQ8Q29uc29sZSB7bG9nc30gb246Y2xlYXI9e2NsZWFyX2xvZ3N9Lz5cblx0XHQ8L3NlY3Rpb24+XG5cdDwvUGFuZVdpdGhQYW5lbD5cblxuXHQ8ZGl2IGNsYXNzPVwib3ZlcmxheVwiPlxuXHRcdHsjaWYgZXJyb3J9XG5cdFx0XHQ8TWVzc2FnZSBraW5kPVwiZXJyb3JcIiBkZXRhaWxzPXtlcnJvcn0vPlxuXHRcdHs6ZWxzZSBpZiBzdGF0dXMgfHwgISRidW5kbGV9XG5cdFx0XHQ8TWVzc2FnZSBraW5kPVwiaW5mb1wiIHRydW5jYXRlPntzdGF0dXMgfHwgJ2xvYWRpbmcgU3ZlbHRlIGNvbXBpbGVyLi4uJ308L01lc3NhZ2U+XG5cdFx0ey9pZn1cblx0PC9kaXY+XG48L2Rpdj4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuXHRjb25zdCB7IGNvbXBpbGVfb3B0aW9ucyB9ID0gZ2V0Q29udGV4dCgnUkVQTCcpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0Lm9wdGlvbnMge1xuXHRcdHBhZGRpbmc6IDAgMTBweDtcblx0XHRmb250LWZhbWlseTogdmFyKC0tZm9udC1tb25vKTtcblx0XHRmb250LXNpemU6IDEzcHg7XG5cdFx0Y29sb3I6ICM5OTk7XG5cdFx0bGluZS1oZWlnaHQ6IDEuODtcblx0fVxuXG5cdC5vcHRpb24ge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHBhZGRpbmc6IDAgMCAwIDEuMjVlbTtcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdGNvbG9yOiAjMzMzO1xuXHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHR9XG5cblx0LmtleSB7XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRcdHdpZHRoOiA5ZW07XG5cdH1cblxuXHQuc3RyaW5nIHtcblx0XHRjb2xvcjogaHNsKDQxLCAzNyUsIDQ1JSk7XG5cdH1cblxuXHQuYm9vbGVhbiB7XG5cdFx0Y29sb3I6IGhzbCg0NSwgNyUsIDQ1JSk7XG5cdH1cblxuXHRsYWJlbCB7XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHR9XG5cblx0bGFiZWxbZm9yXSB7XG5cdFx0Y29sb3I6IHZhcigtLXN0cmluZyk7XG5cdH1cblxuXHRpbnB1dFt0eXBlPWNoZWNrYm94XSB7XG5cdFx0dG9wOiAtMXB4O1xuXHR9XG5cblx0aW5wdXRbdHlwZT1yYWRpb10ge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IGF1dG87XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRjbGlwOiByZWN0KDFweCwgMXB4LCAxcHgsIDFweCk7XG5cdFx0d2lkdGg6IDFweDtcblx0XHRoZWlnaHQ6IDFweDtcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHR9XG5cblx0aW5wdXRbdHlwZT1yYWRpb10gKyBsYWJlbCB7XG5cdFx0cGFkZGluZzogMCAwIDAgMS42ZW07XG5cdFx0bWFyZ2luOiAwIDAuNmVtIDAgMDtcblx0XHRvcGFjaXR5OiAwLjc7XG5cdH1cblxuXHRpbnB1dFt0eXBlPXJhZGlvXTpjaGVja2VkICsgbGFiZWwge1xuXHRcdG9wYWNpdHk6IDE7XG5cdH1cblxuXHQvKiBpbnB1dFt0eXBlPXJhZGlvXTpmb2N1cyArIGxhYmVsIHtcblx0XHRjb2xvcjogIzAwZjtcblx0XHRvdXRsaW5lOiAxcHggZG90dGVkICMwMGY7XG5cdH0gKi9cblxuXHRpbnB1dFt0eXBlPXJhZGlvXSArIGxhYmVsOmJlZm9yZSB7XG5cdFx0Y29udGVudDogJyc7XG5cdFx0YmFja2dyb3VuZDogI2VlZTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGZsb2F0OiBsZWZ0O1xuXHRcdHdpZHRoOiAxNXB4O1xuXHRcdGhlaWdodDogMTVweDtcblx0XHRtYXJnaW4tbGVmdDogLTIxcHg7XG5cdFx0bWFyZ2luLXRvcDogNHB4O1xuXHRcdHZlcnRpY2FsLWFsaWduOiB0b3A7XG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHR0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuMXMgZWFzZS1vdXQ7XG5cdH1cblxuXHRpbnB1dFt0eXBlPXJhZGlvXSArIGxhYmVsOmJlZm9yZSB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcblx0XHRib3JkZXItcmFkaXVzOiAxMDAlO1xuXHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDAuNWVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgLjk1KTtcblx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1zZWNvbmQpO1xuXHR9XG5cblx0aW5wdXRbdHlwZT1yYWRpb106Y2hlY2tlZCArIGxhYmVsOmJlZm9yZSB7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcHJpbWUpO1xuXHRcdGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIC4xNWVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgLjk1KTtcblx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1zZWNvbmQpO1xuXHRcdHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4ycyBlYXNlLW91dDtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cIm9wdGlvbnNcIj5cblx0cmVzdWx0ID0gc3ZlbHRlLmNvbXBpbGUoc291cmNlLCAmIzEyMztcblx0PGRpdiBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+Z2VuZXJhdGU6PC9zcGFuPlxuXG5cdFx0PGlucHV0IGlkPVwiZG9tLWlucHV0XCIgdHlwZT1cInJhZGlvXCIgYmluZDpncm91cD17JGNvbXBpbGVfb3B0aW9ucy5nZW5lcmF0ZX0gdmFsdWU9XCJkb21cIj5cblx0XHQ8bGFiZWwgZm9yPVwiZG9tLWlucHV0XCI+PHNwYW4gY2xhc3M9XCJzdHJpbmdcIj5cImRvbVwiPC9zcGFuPjwvbGFiZWw+XG5cblx0XHQ8aW5wdXQgaWQ9XCJzc3ItaW5wdXRcIiB0eXBlPVwicmFkaW9cIiBiaW5kOmdyb3VwPXskY29tcGlsZV9vcHRpb25zLmdlbmVyYXRlfSB2YWx1ZT1cInNzclwiPlxuXHRcdDxsYWJlbCBmb3I9XCJzc3ItaW5wdXRcIj48c3BhbiBjbGFzcz1cInN0cmluZ1wiPlwic3NyXCI8L3NwYW4+LDwvbGFiZWw+XG5cdDwvZGl2PlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+ZGV2Ojwvc3Bhbj5cblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXskY29tcGlsZV9vcHRpb25zLmRldn0+IDxzcGFuIGNsYXNzPVwiYm9vbGVhblwiPnskY29tcGlsZV9vcHRpb25zLmRldn08L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+Y3NzOjwvc3Bhbj5cblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXskY29tcGlsZV9vcHRpb25zLmNzc30+IDxzcGFuIGNsYXNzPVwiYm9vbGVhblwiPnskY29tcGlsZV9vcHRpb25zLmNzc308L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+aHlkcmF0YWJsZTo8L3NwYW4+XG5cdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGJpbmQ6Y2hlY2tlZD17JGNvbXBpbGVfb3B0aW9ucy5oeWRyYXRhYmxlfT4gPHNwYW4gY2xhc3M9XCJib29sZWFuXCI+eyRjb21waWxlX29wdGlvbnMuaHlkcmF0YWJsZX08L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+Y3VzdG9tRWxlbWVudDo8L3NwYW4+XG5cdFx0PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGJpbmQ6Y2hlY2tlZD17JGNvbXBpbGVfb3B0aW9ucy5jdXN0b21FbGVtZW50fT4gPHNwYW4gY2xhc3M9XCJib29sZWFuXCI+eyRjb21waWxlX29wdGlvbnMuY3VzdG9tRWxlbWVudH08L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+aW1tdXRhYmxlOjwvc3Bhbj5cblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXskY29tcGlsZV9vcHRpb25zLmltbXV0YWJsZX0+IDxzcGFuIGNsYXNzPVwiYm9vbGVhblwiPnskY29tcGlsZV9vcHRpb25zLmltbXV0YWJsZX08L3NwYW4+LFxuXHQ8L2xhYmVsPlxuXG5cdDxsYWJlbCBjbGFzcz1cIm9wdGlvblwiPlxuXHRcdDxzcGFuIGNsYXNzPVwia2V5XCI+bGVnYWN5Ojwvc3Bhbj5cblx0XHQ8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkPXskY29tcGlsZV9vcHRpb25zLmxlZ2FjeX0+IDxzcGFuIGNsYXNzPVwiYm9vbGVhblwiPnskY29tcGlsZV9vcHRpb25zLmxlZ2FjeX08L3NwYW4+XG5cdDwvbGFiZWw+XG5cdH0pO1xuPC9kaXY+IiwiY29uc3Qgd29ya2VycyA9IG5ldyBNYXAoKTtcblxubGV0IHVpZCA9IDE7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVyIHtcblx0Y29uc3RydWN0b3Iod29ya2Vyc1VybCwgc3ZlbHRlVXJsKSB7XG5cdFx0aWYgKCF3b3JrZXJzLmhhcyhzdmVsdGVVcmwpKSB7XG5cdFx0XHRjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKGAke3dvcmtlcnNVcmx9L2NvbXBpbGVyLmpzYCk7XG5cdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eXBlOiAnaW5pdCcsIHN2ZWx0ZVVybCB9KTtcblx0XHRcdHdvcmtlcnMuc2V0KHN2ZWx0ZVVybCwgd29ya2VyKTtcblx0XHR9XG5cblx0XHR0aGlzLndvcmtlciA9IHdvcmtlcnMuZ2V0KHN2ZWx0ZVVybCk7XG5cblx0XHR0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuXG5cdFx0dGhpcy53b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzLmdldChldmVudC5kYXRhLmlkKTtcblxuXHRcdFx0aWYgKGhhbmRsZXIpIHsgLy8gaWYgbm8gaGFuZGxlciwgd2FzIG1lYW50IGZvciBhIGRpZmZlcmVudCBSRVBMXG5cdFx0XHRcdGhhbmRsZXIoZXZlbnQuZGF0YS5yZXN1bHQpO1xuXHRcdFx0XHR0aGlzLmhhbmRsZXJzLmRlbGV0ZShldmVudC5kYXRhLmlkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGNvbXBpbGUoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bGZpbCA9PiB7XG5cdFx0XHRjb25zdCBpZCA9IHVpZCsrO1xuXG5cdFx0XHR0aGlzLmhhbmRsZXJzLnNldChpZCwgZnVsZmlsKTtcblxuXHRcdFx0dGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHRpZCxcblx0XHRcdFx0dHlwZTogJ2NvbXBpbGUnLFxuXHRcdFx0XHRzb3VyY2U6IGNvbXBvbmVudC5zb3VyY2UsXG5cdFx0XHRcdG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0XHRcdG5hbWU6IGNvbXBvbmVudC5uYW1lLFxuXHRcdFx0XHRcdGZpbGVuYW1lOiBgJHtjb21wb25lbnQubmFtZX0uc3ZlbHRlYFxuXHRcdFx0XHR9LCBvcHRpb25zKSxcblx0XHRcdFx0ZW50cnk6IGNvbXBvbmVudC5uYW1lID09PSAnQXBwJ1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuXHR9XG59IiwiPHNjcmlwdD5cblx0aW1wb3J0IHsgZ2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBTcGxpdFBhbmUgZnJvbSAnLi4vU3BsaXRQYW5lLnN2ZWx0ZSc7XG5cdGltcG9ydCBWaWV3ZXIgZnJvbSAnLi9WaWV3ZXIuc3ZlbHRlJztcblx0aW1wb3J0IFBhbmVXaXRoUGFuZWwgZnJvbSAnLi9QYW5lV2l0aFBhbmVsLnN2ZWx0ZSc7XG5cdGltcG9ydCBDb21waWxlck9wdGlvbnMgZnJvbSAnLi9Db21waWxlck9wdGlvbnMuc3ZlbHRlJztcblx0aW1wb3J0IENvbXBpbGVyIGZyb20gJy4vQ29tcGlsZXIuanMnO1xuXHRpbXBvcnQgQ29kZU1pcnJvciBmcm9tICcuLi9Db2RlTWlycm9yLnN2ZWx0ZSc7XG5cdGltcG9ydCB7IGlzX2Jyb3dzZXIgfSBmcm9tICcuLi9lbnYuanMnO1xuXG5cdGNvbnN0IHsgcmVnaXN0ZXJfb3V0cHV0IH0gPSBnZXRDb250ZXh0KCdSRVBMJyk7XG5cblx0ZXhwb3J0IGxldCBzdmVsdGVVcmw7XG5cdGV4cG9ydCBsZXQgd29ya2Vyc1VybDtcblx0ZXhwb3J0IGxldCBzdGF0dXM7XG5cdGV4cG9ydCBsZXQgc291cmNlRXJyb3JMb2MgPSBudWxsO1xuXHRleHBvcnQgbGV0IHJ1bnRpbWVFcnJvciA9IG51bGw7XG5cdGV4cG9ydCBsZXQgZW1iZWRkZWQgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCByZWxheGVkID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgaW5qZWN0ZWRKUztcblx0ZXhwb3J0IGxldCBpbmplY3RlZENTUztcblxuXHRsZXQgZm9vOyAvLyBUT0RPIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzIxMjJcblxuXHRyZWdpc3Rlcl9vdXRwdXQoe1xuXHRcdHNldDogYXN5bmMgKHNlbGVjdGVkLCBvcHRpb25zKSA9PiB7XG5cdFx0XHRpZiAoc2VsZWN0ZWQudHlwZSA9PT0gJ2pzJykge1xuXHRcdFx0XHRqc19lZGl0b3Iuc2V0KGAvKiBTZWxlY3QgYSBjb21wb25lbnQgdG8gc2VlIGl0cyBjb21waWxlZCBjb2RlICovYCk7XG5cdFx0XHRcdGNzc19lZGl0b3Iuc2V0KGAvKiBTZWxlY3QgYSBjb21wb25lbnQgdG8gc2VlIGl0cyBjb21waWxlZCBjb2RlICovYCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY29tcGlsZWQgPSBhd2FpdCBjb21waWxlci5jb21waWxlKHNlbGVjdGVkLCBvcHRpb25zKTtcblx0XHRcdGlmICghanNfZWRpdG9yKSByZXR1cm47IC8vIHVubW91bnRlZFxuXG5cdFx0XHRqc19lZGl0b3Iuc2V0KGNvbXBpbGVkLmpzLCAnanMnKTtcblx0XHRcdGNzc19lZGl0b3Iuc2V0KGNvbXBpbGVkLmNzcywgJ2NzcycpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGU6IGFzeW5jIChzZWxlY3RlZCwgb3B0aW9ucykgPT4ge1xuXHRcdFx0aWYgKHNlbGVjdGVkLnR5cGUgPT09ICdqcycpIHJldHVybjtcblxuXHRcdFx0Y29uc3QgY29tcGlsZWQgPSBhd2FpdCBjb21waWxlci5jb21waWxlKHNlbGVjdGVkLCBvcHRpb25zKTtcblx0XHRcdGlmICghanNfZWRpdG9yKSByZXR1cm47IC8vIHVubW91bnRlZFxuXG5cdFx0XHRqc19lZGl0b3IudXBkYXRlKGNvbXBpbGVkLmpzKTtcblx0XHRcdGNzc19lZGl0b3IudXBkYXRlKGNvbXBpbGVkLmNzcyk7XG5cdFx0fVxuXHR9KTtcblxuXHRjb25zdCBjb21waWxlciA9IGlzX2Jyb3dzZXIgJiYgbmV3IENvbXBpbGVyKHdvcmtlcnNVcmwsIHN2ZWx0ZVVybCk7XG5cblx0Ly8gcmVmc1xuXHRsZXQgdmlld2VyO1xuXHRsZXQganNfZWRpdG9yO1xuXHRsZXQgY3NzX2VkaXRvcjtcblx0Y29uc3Qgc2V0dGVycyA9IHt9O1xuXG5cdGxldCB2aWV3ID0gJ3Jlc3VsdCc7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQudmlldy10b2dnbGUge1xuXHRcdGhlaWdodDogdmFyKC0tcGFuZS1jb250cm9scy1oKTtcblx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdH1cblxuXHRidXR0b24ge1xuXHRcdC8qIHdpZHRoOiA1MCU7XG5cdFx0aGVpZ2h0OiAxMDAlOyAqL1xuXHRcdGJhY2tncm91bmQ6IHdoaXRlO1xuXHRcdHRleHQtYWxpZ246IGxlZnQ7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdGZvbnQ6IDQwMCAxMnB4LzEuNSB2YXIoLS1mb250KTtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym9yZGVyLWJvdHRvbTogM3B4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRcdHBhZGRpbmc6IDEycHggMTJweCA4cHggMTJweDtcblx0XHRjb2xvcjogIzk5OTtcblx0XHRib3JkZXItcmFkaXVzOiAwO1xuXHR9XG5cblx0YnV0dG9uLmFjdGl2ZSB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogM3B4IHNvbGlkIHZhcigtLXByaW1lKTtcblx0XHRjb2xvcjogIzMzMztcblx0fVxuXG5cdGRpdltzbG90XSB7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG5cblx0LnRhYi1jb250ZW50IHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiBjYWxjKDEwMCUgLSA0MnB4KSAhaW1wb3J0YW50O1xuXHRcdG9wYWNpdHk6IDA7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdH1cblxuXHQudGFiLWNvbnRlbnQudmlzaWJsZSB7XG5cdFx0LyogY2FuJ3QgdXNlIHZpc2liaWxpdHkgZHVlIHRvIGEgd2VpcmQgcGFpbnRpbmcgYnVnIGluIENocm9tZSAqL1xuXHRcdG9wYWNpdHk6IDE7XG5cdFx0cG9pbnRlci1ldmVudHM6IGFsbDtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInZpZXctdG9nZ2xlXCI+XG5cdDxidXR0b25cblx0XHRjbGFzczphY3RpdmU9XCJ7dmlldyA9PT0gJ3Jlc3VsdCd9XCJcblx0XHRvbjpjbGljaz1cInsoKSA9PiB2aWV3ID0gJ3Jlc3VsdCd9XCJcblx0PlJlc3VsdDwvYnV0dG9uPlxuXG5cdDxidXR0b25cblx0XHRjbGFzczphY3RpdmU9XCJ7dmlldyA9PT0gJ2pzJ31cIlxuXHRcdG9uOmNsaWNrPVwieygpID0+IHZpZXcgPSAnanMnfVwiXG5cdD5KUyBvdXRwdXQ8L2J1dHRvbj5cblxuXHQ8YnV0dG9uXG5cdFx0Y2xhc3M6YWN0aXZlPVwie3ZpZXcgPT09ICdjc3MnfVwiXG5cdFx0b246Y2xpY2s9XCJ7KCkgPT4gdmlldyA9ICdjc3MnfVwiXG5cdD5DU1Mgb3V0cHV0PC9idXR0b24+XG48L2Rpdj5cblxuPCEtLSBjb21wb25lbnQgdmlld2VyIC0tPlxuPGRpdiBjbGFzcz1cInRhYi1jb250ZW50XCIgY2xhc3M6dmlzaWJsZT1cInt2aWV3ID09PSAncmVzdWx0J31cIj5cblx0PFZpZXdlclxuXHRcdGJpbmQ6dGhpcz17dmlld2VyfVxuXHRcdGJpbmQ6ZXJyb3I9e3J1bnRpbWVFcnJvcn1cblx0XHR7c3RhdHVzfVxuXHRcdHtyZWxheGVkfVxuXHRcdHtpbmplY3RlZEpTfVxuXHRcdHtpbmplY3RlZENTU31cblx0Lz5cbjwvZGl2PlxuXG48IS0tIGpzIG91dHB1dCAtLT5cbjxkaXYgY2xhc3M9XCJ0YWItY29udGVudFwiIGNsYXNzOnZpc2libGU9XCJ7dmlldyA9PT0gJ2pzJ31cIj5cblx0eyNpZiBlbWJlZGRlZH1cblx0XHQ8Q29kZU1pcnJvclxuXHRcdFx0YmluZDp0aGlzPXtqc19lZGl0b3J9XG5cdFx0XHRtb2RlPVwianNcIlxuXHRcdFx0ZXJyb3JMb2M9e3NvdXJjZUVycm9yTG9jfVxuXHRcdFx0cmVhZG9ubHlcblx0XHQvPlxuXHR7OmVsc2V9XG5cdFx0PFBhbmVXaXRoUGFuZWwgcG9zPXs2N30gcGFuZWw9XCJDb21waWxlciBvcHRpb25zXCI+XG5cdFx0XHQ8ZGl2IHNsb3Q9XCJtYWluXCI+XG5cdFx0XHRcdDxDb2RlTWlycm9yXG5cdFx0XHRcdFx0YmluZDp0aGlzPXtqc19lZGl0b3J9XG5cdFx0XHRcdFx0bW9kZT1cImpzXCJcblx0XHRcdFx0XHRlcnJvckxvYz17c291cmNlRXJyb3JMb2N9XG5cdFx0XHRcdFx0cmVhZG9ubHlcblx0XHRcdFx0Lz5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IHNsb3Q9XCJwYW5lbC1ib2R5XCI+XG5cdFx0XHRcdDxDb21waWxlck9wdGlvbnMvPlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9QYW5lV2l0aFBhbmVsPlxuXHR7L2lmfVxuPC9kaXY+XG5cbjwhLS0gY3NzIG91dHB1dCAtLT5cbjxkaXYgY2xhc3M9XCJ0YWItY29udGVudFwiIGNsYXNzOnZpc2libGU9XCJ7dmlldyA9PT0gJ2Nzcyd9XCI+XG5cdDxDb2RlTWlycm9yXG5cdFx0YmluZDp0aGlzPXtjc3NfZWRpdG9yfVxuXHRcdG1vZGU9XCJjc3NcIlxuXHRcdGVycm9yTG9jPXtzb3VyY2VFcnJvckxvY31cblx0XHRyZWFkb25seVxuXHQvPlxuPC9kaXY+XG4iLCJjb25zdCB3b3JrZXJzID0gbmV3IE1hcCgpO1xuXG5sZXQgdWlkID0gMTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVuZGxlciB7XG5cdGNvbnN0cnVjdG9yKHsgd29ya2Vyc1VybCwgcGFja2FnZXNVcmwsIHN2ZWx0ZVVybCwgb25zdGF0dXMgfSkge1xuXHRcdGNvbnN0IGhhc2ggPSBgJHtwYWNrYWdlc1VybH06JHtzdmVsdGVVcmx9YDtcblxuXHRcdGlmICghd29ya2Vycy5oYXMoaGFzaCkpIHtcblx0XHRcdGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoYCR7d29ya2Vyc1VybH0vYnVuZGxlci5qc2ApO1xuXHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogJ2luaXQnLCBwYWNrYWdlc1VybCwgc3ZlbHRlVXJsIH0pO1xuXHRcdFx0d29ya2Vycy5zZXQoaGFzaCwgd29ya2VyKTtcblx0XHR9XG5cblx0XHR0aGlzLndvcmtlciA9IHdvcmtlcnMuZ2V0KGhhc2gpO1xuXG5cdFx0dGhpcy5oYW5kbGVycyA9IG5ldyBNYXAoKTtcblxuXHRcdHRoaXMud29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudCA9PiB7XG5cdFx0XHRjb25zdCBoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5nZXQoZXZlbnQuZGF0YS51aWQpO1xuXG5cdFx0XHRpZiAoaGFuZGxlcikgeyAvLyBpZiBubyBoYW5kbGVyLCB3YXMgbWVhbnQgZm9yIGEgZGlmZmVyZW50IFJFUExcblx0XHRcdFx0aWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ3N0YXR1cycpIHtcblx0XHRcdFx0XHRvbnN0YXR1cyhldmVudC5kYXRhLm1lc3NhZ2UpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9uc3RhdHVzKG51bGwpO1xuXHRcdFx0XHRoYW5kbGVyKGV2ZW50LmRhdGEpO1xuXHRcdFx0XHR0aGlzLmhhbmRsZXJzLmRlbGV0ZShldmVudC5kYXRhLnVpZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRidW5kbGUoY29tcG9uZW50cykge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdWxmaWwgPT4ge1xuXHRcdFx0dGhpcy5oYW5kbGVycy5zZXQodWlkLCBmdWxmaWwpO1xuXG5cdFx0XHR0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdHVpZCxcblx0XHRcdFx0dHlwZTogJ2J1bmRsZScsXG5cdFx0XHRcdGNvbXBvbmVudHNcblx0XHRcdH0pO1xuXG5cdFx0XHR1aWQgKz0gMTtcblx0XHR9KTtcblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy53b3JrZXIudGVybWluYXRlKCk7XG5cdH1cbn0iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBzZXRDb250ZXh0LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG5cdGltcG9ydCBTcGxpdFBhbmUgZnJvbSAnLi9TcGxpdFBhbmUuc3ZlbHRlJztcblx0aW1wb3J0IENvbXBvbmVudFNlbGVjdG9yIGZyb20gJy4vSW5wdXQvQ29tcG9uZW50U2VsZWN0b3Iuc3ZlbHRlJztcblx0aW1wb3J0IE1vZHVsZUVkaXRvciBmcm9tICcuL0lucHV0L01vZHVsZUVkaXRvci5zdmVsdGUnO1xuXHRpbXBvcnQgT3V0cHV0IGZyb20gJy4vT3V0cHV0L2luZGV4LnN2ZWx0ZSc7XG5cdGltcG9ydCBCdW5kbGVyIGZyb20gJy4vQnVuZGxlci5qcyc7XG5cdGltcG9ydCB7IGlzX2Jyb3dzZXIgfSBmcm9tICcuL2Vudi5qcyc7XG5cblx0ZXhwb3J0IGxldCB3b3JrZXJzVXJsO1xuXHRleHBvcnQgbGV0IHBhY2thZ2VzVXJsID0gJ2h0dHBzOi8vdW5wa2cuY29tJztcblx0ZXhwb3J0IGxldCBzdmVsdGVVcmwgPSBgJHtwYWNrYWdlc1VybH0vc3ZlbHRlYDtcblx0ZXhwb3J0IGxldCBlbWJlZGRlZCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IG9yaWVudGF0aW9uID0gJ2NvbHVtbnMnO1xuXHRleHBvcnQgbGV0IHJlbGF4ZWQgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBmaXhlZCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGZpeGVkUG9zID0gNTA7XG5cdGV4cG9ydCBsZXQgaW5qZWN0ZWRKUyA9ICcnO1xuXHRleHBvcnQgbGV0IGluamVjdGVkQ1NTID0gJyc7XG5cblx0ZXhwb3J0IGZ1bmN0aW9uIHRvSlNPTigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aW1wb3J0czogJGJ1bmRsZS5pbXBvcnRzLFxuXHRcdFx0Y29tcG9uZW50czogJGNvbXBvbmVudHNcblx0XHR9O1xuXHR9XG5cblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldChkYXRhKSB7XG5cdFx0Y29tcG9uZW50cy5zZXQoZGF0YS5jb21wb25lbnRzKTtcblx0XHRzZWxlY3RlZC5zZXQoZGF0YS5jb21wb25lbnRzWzBdKTtcblxuXHRcdHJlYnVuZGxlKCk7XG5cblx0XHRhd2FpdCBtb2R1bGVfZWRpdG9yX3JlYWR5O1xuXHRcdGF3YWl0IG91dHB1dF9yZWFkeTtcblxuXHRcdGluamVjdGVkQ1NTID0gZGF0YS5jc3MgfHwgJyc7XG5cdFx0bW9kdWxlX2VkaXRvci5zZXQoJHNlbGVjdGVkLnNvdXJjZSwgJHNlbGVjdGVkLnR5cGUpO1xuXHRcdG91dHB1dC5zZXQoJHNlbGVjdGVkLCAkY29tcGlsZV9vcHRpb25zKTtcblx0fVxuXG5cdGV4cG9ydCBmdW5jdGlvbiB1cGRhdGUoZGF0YSkge1xuXHRcdGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gJHNlbGVjdGVkIHx8IHt9O1xuXG5cdFx0Y29tcG9uZW50cy5zZXQoZGF0YS5jb21wb25lbnRzKTtcblxuXHRcdGNvbnN0IG1hdGNoZWRfY29tcG9uZW50ID0gZGF0YS5jb21wb25lbnRzLmZpbmQoZmlsZSA9PiBmaWxlLm5hbWUgPT09IG5hbWUgJiYgZmlsZS50eXBlID09PSB0eXBlKTtcblx0XHRzZWxlY3RlZC5zZXQobWF0Y2hlZF9jb21wb25lbnQgfHwgZGF0YS5jb21wb25lbnRzWzBdKTtcblxuXHRcdGluamVjdGVkQ1NTID0gZGF0YS5jc3MgfHwgJyc7XG5cblx0XHRpZiAobWF0Y2hlZF9jb21wb25lbnQpIHtcblx0XHRcdG1vZHVsZV9lZGl0b3IudXBkYXRlKG1hdGNoZWRfY29tcG9uZW50LnNvdXJjZSk7XG5cdFx0XHRvdXRwdXQudXBkYXRlKG1hdGNoZWRfY29tcG9uZW50LCAkY29tcGlsZV9vcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bW9kdWxlX2VkaXRvci5zZXQobWF0Y2hlZF9jb21wb25lbnQuc291cmNlLCBtYXRjaGVkX2NvbXBvbmVudC50eXBlKTtcblx0XHRcdG91dHB1dC5zZXQobWF0Y2hlZF9jb21wb25lbnQsICRjb21waWxlX29wdGlvbnMpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghd29ya2Vyc1VybCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgWW91IG11c3Qgc3VwcGx5IHdvcmtlcnNVcmwgcHJvcCB0byA8UmVwbD5gKTtcblx0fVxuXG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cblx0Y29uc3QgY29tcG9uZW50cyA9IHdyaXRhYmxlKFtdKTtcblx0Y29uc3Qgc2VsZWN0ZWQgPSB3cml0YWJsZShudWxsKTtcblx0Y29uc3QgYnVuZGxlID0gd3JpdGFibGUobnVsbCk7XG5cblx0Y29uc3QgY29tcGlsZV9vcHRpb25zID0gd3JpdGFibGUoe1xuXHRcdGdlbmVyYXRlOiAnZG9tJyxcblx0XHRkZXY6IGZhbHNlLFxuXHRcdGNzczogZmFsc2UsXG5cdFx0aHlkcmF0YWJsZTogZmFsc2UsXG5cdFx0Y3VzdG9tRWxlbWVudDogZmFsc2UsXG5cdFx0aW1tdXRhYmxlOiBmYWxzZSxcblx0XHRsZWdhY3k6IGZhbHNlXG5cdH0pO1xuXG5cdGxldCBtb2R1bGVfZWRpdG9yO1xuXHRsZXQgb3V0cHV0O1xuXG5cdGxldCBjdXJyZW50X3Rva2VuO1xuXHRhc3luYyBmdW5jdGlvbiByZWJ1bmRsZSgpIHtcblx0XHRjb25zdCB0b2tlbiA9IGN1cnJlbnRfdG9rZW4gPSB7fTtcblx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBidW5kbGVyLmJ1bmRsZSgkY29tcG9uZW50cyk7XG5cdFx0aWYgKHJlc3VsdCAmJiB0b2tlbiA9PT0gY3VycmVudF90b2tlbikgYnVuZGxlLnNldChyZXN1bHQpO1xuXHR9XG5cblx0Ly8gVE9ETyB0aGlzIGlzIGEgaG9ycmlibGUga2x1ZGdlLCB3cml0dGVuIGluIGEgcGFuaWMuIGZpeCBpdFxuXHRsZXQgZnVsZmlsX21vZHVsZV9lZGl0b3JfcmVhZHk7XG5cdGxldCBtb2R1bGVfZWRpdG9yX3JlYWR5ID0gbmV3IFByb21pc2UoZiA9PiBmdWxmaWxfbW9kdWxlX2VkaXRvcl9yZWFkeSA9IGYpO1xuXG5cdGxldCBmdWxmaWxfb3V0cHV0X3JlYWR5O1xuXHRsZXQgb3V0cHV0X3JlYWR5ID0gbmV3IFByb21pc2UoZiA9PiBmdWxmaWxfb3V0cHV0X3JlYWR5ID0gZik7XG5cblxuXHRzZXRDb250ZXh0KCdSRVBMJywge1xuXHRcdGNvbXBvbmVudHMsXG5cdFx0c2VsZWN0ZWQsXG5cdFx0YnVuZGxlLFxuXHRcdGNvbXBpbGVfb3B0aW9ucyxcblxuXHRcdHJlYnVuZGxlLFxuXG5cdFx0bmF2aWdhdGU6IGl0ZW0gPT4ge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSAvXiguKylcXC4oXFx3KykkLy5leGVjKGl0ZW0uZmlsZW5hbWUpO1xuXHRcdFx0aWYgKCFtYXRjaCkgcmV0dXJuOyAvLyA/Pz9cblxuXHRcdFx0Y29uc3QgWywgbmFtZSwgdHlwZV0gPSBtYXRjaDtcblx0XHRcdGNvbnN0IGNvbXBvbmVudCA9ICRjb21wb25lbnRzLmZpbmQoYyA9PiBjLm5hbWUgPT09IG5hbWUgJiYgYy50eXBlID09PSB0eXBlKTtcblx0XHRcdGhhbmRsZV9zZWxlY3QoY29tcG9uZW50KTtcblxuXHRcdFx0Ly8gVE9ETyBzZWxlY3QgdGhlIGxpbmUvY29sdW1uIGluIHF1ZXN0aW9uXG5cdFx0fSxcblxuXHRcdGhhbmRsZV9jaGFuZ2U6IGV2ZW50ID0+IHtcblx0XHRcdHNlbGVjdGVkLnVwZGF0ZShjb21wb25lbnQgPT4ge1xuXHRcdFx0XHQvLyBUT0RPIHRoaXMgaXMgYSBiaXQgaGFja3kg4oCUIHdlJ3JlIHJlbHlpbmcgb24gbXV0YWJpbGl0eVxuXHRcdFx0XHQvLyBzbyB0aGF0IHVwZGF0aW5nIGNvbXBvbmVudHMgd29ya3MuLi4gbWlnaHQgYmUgYmV0dGVyXG5cdFx0XHRcdC8vIGlmIGEpIGNvbXBvbmVudHMgaGFkIHVuaXF1ZSBJRHMsIGIpIHdlIHRyYWNrZWQgc2VsZWN0ZWRcblx0XHRcdFx0Ly8gKmluZGV4KiByYXRoZXIgdGhhbiBjb21wb25lbnQsIGFuZCBjKSBgc2VsZWN0ZWRgIHdhc1xuXHRcdFx0XHQvLyBkZXJpdmVkIGZyb20gYGNvbXBvbmVudHNgIGFuZCBgaW5kZXhgXG5cdFx0XHRcdGNvbXBvbmVudC5zb3VyY2UgPSBldmVudC5kZXRhaWwudmFsdWU7XG5cdFx0XHRcdHJldHVybiBjb21wb25lbnQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0Y29tcG9uZW50cy51cGRhdGUoYyA9PiBjKTtcblxuXHRcdFx0Ly8gcmVjb21waWxlIHNlbGVjdGVkIGNvbXBvbmVudFxuXHRcdFx0b3V0cHV0LnVwZGF0ZSgkc2VsZWN0ZWQsICRjb21waWxlX29wdGlvbnMpO1xuXG5cdFx0XHRyZWJ1bmRsZSgpO1xuXG5cdFx0XHRkaXNwYXRjaCgnY2hhbmdlJywge1xuXHRcdFx0XHRjb21wb25lbnRzOiAkY29tcG9uZW50c1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHJlZ2lzdGVyX21vZHVsZV9lZGl0b3IoZWRpdG9yKSB7XG5cdFx0XHRtb2R1bGVfZWRpdG9yID0gZWRpdG9yO1xuXHRcdFx0ZnVsZmlsX21vZHVsZV9lZGl0b3JfcmVhZHkoKTtcblx0XHR9LFxuXG5cdFx0cmVnaXN0ZXJfb3V0cHV0KGhhbmRsZXJzKSB7XG5cdFx0XHRvdXRwdXQgPSBoYW5kbGVycztcblx0XHRcdGZ1bGZpbF9vdXRwdXRfcmVhZHkoKTtcblx0XHR9LFxuXG5cdFx0cmVxdWVzdF9mb2N1cygpIHtcblx0XHRcdG1vZHVsZV9lZGl0b3IuZm9jdXMoKTtcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGhhbmRsZV9zZWxlY3QoY29tcG9uZW50KSB7XG5cdFx0c2VsZWN0ZWQuc2V0KGNvbXBvbmVudCk7XG5cdFx0bW9kdWxlX2VkaXRvci5zZXQoY29tcG9uZW50LnNvdXJjZSwgY29tcG9uZW50LnR5cGUpO1xuXHRcdG91dHB1dC5zZXQoJHNlbGVjdGVkLCAkY29tcGlsZV9vcHRpb25zKTtcblx0fVxuXG5cdGxldCBpbnB1dDtcblx0bGV0IHNvdXJjZUVycm9yTG9jO1xuXHRsZXQgcnVudGltZUVycm9yTG9jOyAvLyBUT0RPIHJlZmFjdG9yIHRoaXMgc3R1ZmYg4oCUIHJ1bnRpbWVFcnJvckxvYyBpcyB1bnVzZWRcblx0bGV0IHN0YXR1cyA9IG51bGw7XG5cblx0Y29uc3QgYnVuZGxlciA9IGlzX2Jyb3dzZXIgJiYgbmV3IEJ1bmRsZXIoe1xuXHRcdHdvcmtlcnNVcmwsXG5cdFx0cGFja2FnZXNVcmwsXG5cdFx0c3ZlbHRlVXJsLFxuXHRcdG9uc3RhdHVzOiBtZXNzYWdlID0+IHtcblx0XHRcdHN0YXR1cyA9IG1lc3NhZ2U7XG5cdFx0fVxuXHR9KTtcblxuXHQkOiBpZiAob3V0cHV0ICYmICRzZWxlY3RlZCkge1xuXHRcdG91dHB1dC51cGRhdGUoJHNlbGVjdGVkLCAkY29tcGlsZV9vcHRpb25zKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LmNvbnRhaW5lciB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0fVxuXG5cdC5jb250YWluZXIgOmdsb2JhbChzZWN0aW9uKSB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdHBhZGRpbmc6IDQycHggMCAwIDA7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdH1cblxuXHQuY29udGFpbmVyIDpnbG9iYWwoc2VjdGlvbikgPiA6Z2xvYmFsKCopOmZpcnN0LWNoaWxkIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiA0MnB4O1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdH1cblxuXHQuY29udGFpbmVyIDpnbG9iYWwoc2VjdGlvbikgPiA6Z2xvYmFsKCopOmxhc3QtY2hpbGQge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiIGNsYXNzOm9yaWVudGF0aW9uPlxuXHQ8U3BsaXRQYW5lXG5cdFx0dHlwZT1cIntvcmllbnRhdGlvbiA9PT0gJ3Jvd3MnID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJ31cIlxuXHRcdHBvcz1cIntmaXhlZCA/IGZpeGVkUG9zIDogb3JpZW50YXRpb24gPT09ICdyb3dzJyA/IDUwIDogNjB9XCJcblx0XHR7Zml4ZWR9XG5cdD5cblx0XHQ8c2VjdGlvbiBzbG90PWE+XG5cdFx0XHQ8Q29tcG9uZW50U2VsZWN0b3Ige2hhbmRsZV9zZWxlY3R9Lz5cblx0XHRcdDxNb2R1bGVFZGl0b3IgYmluZDp0aGlzPXtpbnB1dH0gZXJyb3JMb2M9XCJ7c291cmNlRXJyb3JMb2MgfHwgcnVudGltZUVycm9yTG9jfVwiLz5cblx0XHQ8L3NlY3Rpb24+XG5cblx0XHQ8c2VjdGlvbiBzbG90PWIgc3R5bGU9J2hlaWdodDogMTAwJTsnPlxuXHRcdFx0PE91dHB1dCB7c3ZlbHRlVXJsfSB7d29ya2Vyc1VybH0ge3N0YXR1c30ge2VtYmVkZGVkfSB7cmVsYXhlZH0ge2luamVjdGVkSlN9IHtpbmplY3RlZENTU30vPlxuXHRcdDwvc2VjdGlvbj5cblx0PC9TcGxpdFBhbmU+XG48L2Rpdj5cbiJdLCJuYW1lcyI6WyJ5b290aWxzLmNsYW1wIiwiZ2V0S2V5IiwiZ2V0VmFsdWUiLCJ1aWQiLCJ3b3JrZXJzIl0sIm1hcHBpbmdzIjoiOzs7QUE0R0EsU0FBUyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUU7SUFDMUIsT0FBTyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7Q0FDbEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cURDbURjLElBQUk7cURBQW1CLElBQUksbUJBQVMsR0FBRzs7Ozs7OzhDQUFxQixNQUFNOzs7O3lFQUFsRSxJQUFJOzs7O3dGQUFtQixJQUFJLG1CQUFTLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkFEaEQsS0FBQyxLQUFLOztzQkFLUCxRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1REFiYyxTQUFTLGNBQUksR0FBRzs7Ozt1REFJaEIsU0FBUyxXQUFJLEdBQUcsUUFBSSxHQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkdBSnhCLFNBQVMsY0FBSSxHQUFHOzs7Ozs7Ozs7OzsyR0FJaEIsU0FBUyxXQUFJLEdBQUcsUUFBSSxHQUFHLENBQUM7Ozs7T0FJN0MsS0FBQyxLQUFLOzs7Ozs7Ozs7Ozs7O1dBS1AsUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURyQixNQUFNQyxTQUFPLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7QUFFMUIsSUFBSUQsS0FBRyxHQUFHLENBQUMsQ0FBQzs7QUFFWixBQUFlLE1BQU0sT0FBTyxDQUFDO0NBQzVCLFdBQVcsQ0FBQyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxFQUFFO0VBQzdELE1BQU0sSUFBSSxHQUFHLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7O0VBRTNDLElBQUksQ0FBQ0MsU0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtHQUN2QixNQUFNLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7R0FDdEQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7R0FDN0RBLFNBQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0dBQzFCOztFQUVELElBQUksQ0FBQyxNQUFNLEdBQUdBLFNBQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7O0VBRWhDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7RUFFMUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsS0FBSyxJQUFJO0dBQ2hELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FB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
