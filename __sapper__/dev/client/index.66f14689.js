import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, e as element, c as claim_element, a as children, b as detach_dev, f as attr_dev, h as add_location, j as insert_dev, R as destroy_each, l as space, E as text, p as claim_space, F as claim_text, Q as toggle_class, g as set_style, T as listen_dev, k as append_dev, w as mount_component, H as set_data_dev, x as transition_in, y as transition_out, z as destroy_component, a1 as prop_dev, W as add_render_callback, L as getContext, V as binding_callbacks, a4 as bind, P as HtmlTag, B as check_outros, G as globals, A as group_outros, a5 as add_flush_callback } from './index.b2dd6920.js';
import './index.ea650d67.js';
import { g as goto } from './app.ddcf5d08.js';
import { b as Icon } from './index.7b3daa08.js';
import { R as Repl } from './Repl.8a307c73.js';
import { s as svelteUrl, r as rollupUrl, m as mapbox_setup, S as ScreenToggle } from './config.4a005f21.js';

/* src\routes\tutorial\[slug]\_TableOfContents.svelte generated by Svelte v3.12.0 */

const file = "src\\routes\\tutorial\\[slug]\\_TableOfContents.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.chapter = list[i];
	child_ctx.i = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.section = list[i];
	child_ctx.i = i;
	return child_ctx;
}

// (83:5) {#each section.chapters as chapter, i}
function create_each_block_1(ctx) {
	var option, t0_value = String.fromCharCode(ctx.i + 97) + "", t0, t1, t2_value = ctx.chapter.title + "", t2, option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t0 = text(t0_value);
			t1 = text(". ");
			t2 = text(t2_value);
			this.h();
		},

		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { value: true }, false);
			var option_nodes = children(option);

			t0 = claim_text(option_nodes, t0_value);
			t1 = claim_text(option_nodes, ". ");
			t2 = claim_text(option_nodes, t2_value);
			option_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			option.__value = option_value_value = ctx.chapter.slug;
			option.value = option.__value;
			add_location(option, file, 83, 6, 1506);
		},

		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t0);
			append_dev(option, t1);
			append_dev(option, t2);
		},

		p: function update(changed, ctx) {
			if ((changed.sections) && t2_value !== (t2_value = ctx.chapter.title + "")) {
				set_data_dev(t2, t2_value);
			}

			if ((changed.sections) && option_value_value !== (option_value_value = ctx.chapter.slug)) {
				prop_dev(option, "__value", option_value_value);
			}

			option.value = option.__value;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(option);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block_1.name, type: "each", source: "(83:5) {#each section.chapters as chapter, i}", ctx });
	return block;
}

// (81:3) {#each sections as section, i}
function create_each_block(ctx) {
	var optgroup, optgroup_label_value;

	let each_value_1 = ctx.section.chapters;

	let each_blocks = [];

	for (let i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
		each_blocks[i_1] = create_each_block_1(get_each_context_1(ctx, each_value_1, i_1));
	}

	const block = {
		c: function create() {
			optgroup = element("optgroup");

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			optgroup = claim_element(nodes, "OPTGROUP", { label: true }, false);
			var optgroup_nodes = children(optgroup);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].l(optgroup_nodes);
			}

			optgroup_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(optgroup, "label", optgroup_label_value = "" + (ctx.i + 1) + ". " + ctx.section.title);
			add_location(optgroup, file, 81, 4, 1412);
		},

		m: function mount(target, anchor) {
			insert_dev(target, optgroup, anchor);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].m(optgroup, null);
			}
		},

		p: function update(changed, ctx) {
			if (changed.sections) {
				each_value_1 = ctx.section.chapters;

				let i_1;
				for (i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i_1);

					if (each_blocks[i_1]) {
						each_blocks[i_1].p(changed, child_ctx);
					} else {
						each_blocks[i_1] = create_each_block_1(child_ctx);
						each_blocks[i_1].c();
						each_blocks[i_1].m(optgroup, null);
					}
				}

				for (; i_1 < each_blocks.length; i_1 += 1) {
					each_blocks[i_1].d(1);
				}
				each_blocks.length = each_value_1.length;
			}

			if ((changed.sections) && optgroup_label_value !== (optgroup_label_value = "" + (ctx.i + 1) + ". " + ctx.section.title)) {
				attr_dev(optgroup, "label", optgroup_label_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(optgroup);
			}

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(81:3) {#each sections as section, i}", ctx });
	return block;
}

function create_fragment(ctx) {
	var nav, a0, a0_href_value, t0, div, span1, strong, span0, t1, t2_value = ctx.selected.section.title + "", t2, t3, t4, t5_value = ctx.selected.chapter.title + "", t5, t6, select, select_value_value, t7, a1, a1_href_value, current, dispose;

	var icon0 = new Icon({
		props: { name: "arrow-left" },
		$$inline: true
	});

	var icon1 = new Icon({ props: { name: "menu" }, $$inline: true });

	let each_value = ctx.sections;

	let each_blocks = [];

	for (let i_1 = 0; i_1 < each_value.length; i_1 += 1) {
		each_blocks[i_1] = create_each_block(get_each_context(ctx, each_value, i_1));
	}

	var icon2 = new Icon({
		props: { name: "arrow-right" },
		$$inline: true
	});

	const block = {
		c: function create() {
			nav = element("nav");
			a0 = element("a");
			icon0.$$.fragment.c();
			t0 = space();
			div = element("div");
			span1 = element("span");
			strong = element("strong");
			span0 = element("span");
			icon1.$$.fragment.c();
			t1 = space();
			t2 = text(t2_value);
			t3 = text(" /");
			t4 = space();
			t5 = text(t5_value);
			t6 = space();
			select = element("select");

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].c();
			}

			t7 = space();
			a1 = element("a");
			icon2.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true }, false);
			var nav_nodes = children(nav);

			a0 = claim_element(nav_nodes, "A", { rel: true, class: true, href: true }, false);
			var a0_nodes = children(a0);

			icon0.$$.fragment.l(a0_nodes);
			a0_nodes.forEach(detach_dev);
			t0 = claim_space(nav_nodes);

			div = claim_element(nav_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			span1 = claim_element(div_nodes, "SPAN", { class: true }, false);
			var span1_nodes = children(span1);

			strong = claim_element(span1_nodes, "STRONG", { class: true }, false);
			var strong_nodes = children(strong);

			span0 = claim_element(strong_nodes, "SPAN", { style: true, class: true }, false);
			var span0_nodes = children(span0);

			icon1.$$.fragment.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(strong_nodes);
			t2 = claim_text(strong_nodes, t2_value);
			t3 = claim_text(strong_nodes, " /");
			strong_nodes.forEach(detach_dev);
			t4 = claim_space(span1_nodes);
			t5 = claim_text(span1_nodes, t5_value);
			span1_nodes.forEach(detach_dev);
			t6 = claim_space(div_nodes);

			select = claim_element(div_nodes, "SELECT", { value: true, class: true }, false);
			var select_nodes = children(select);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);

			a1 = claim_element(nav_nodes, "A", { rel: true, class: true, href: true }, false);
			var a1_nodes = children(a1);

			icon2.$$.fragment.l(a1_nodes);
			a1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a0, "rel", "prefetch");
			attr_dev(a0, "class", "no-underline svelte-faku86");
			attr_dev(a0, "href", a0_href_value = "tutorial/" + (ctx.selected.prev || ctx.selected).slug);
			toggle_class(a0, "disabled", !ctx.selected.prev);
			add_location(a0, file, 66, 1, 961);
			set_style(span0, "position", "relative");
			set_style(span0, "top", "-0.1em");
			set_style(span0, "margin", "0 0.5em 0 0");
			attr_dev(span0, "class", "svelte-faku86");
			add_location(span0, file, 73, 4, 1152);
			attr_dev(strong, "class", "svelte-faku86");
			add_location(strong, file, 72, 3, 1139);
			attr_dev(span1, "class", "svelte-faku86");
			add_location(span1, file, 71, 2, 1129);
			attr_dev(select, "class", "svelte-faku86");
			add_location(select, file, 79, 2, 1331);
			attr_dev(div, "class", "svelte-faku86");
			add_location(div, file, 70, 1, 1121);
			attr_dev(a1, "rel", "prefetch");
			attr_dev(a1, "class", "no-underline svelte-faku86");
			attr_dev(a1, "href", a1_href_value = "tutorial/" + (ctx.selected.next || ctx.selected).slug);
			toggle_class(a1, "disabled", !ctx.selected.next);
			add_location(a1, file, 90, 1, 1653);
			attr_dev(nav, "class", "svelte-faku86");
			add_location(nav, file, 65, 0, 954);
			dispose = listen_dev(select, "change", navigate);
		},

		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, a0);
			mount_component(icon0, a0, null);
			append_dev(nav, t0);
			append_dev(nav, div);
			append_dev(div, span1);
			append_dev(span1, strong);
			append_dev(strong, span0);
			mount_component(icon1, span0, null);
			append_dev(strong, t1);
			append_dev(strong, t2);
			append_dev(strong, t3);
			append_dev(span1, t4);
			append_dev(span1, t5);
			append_dev(div, t6);
			append_dev(div, select);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].m(select, null);
			}

			select_value_value = ctx.slug;
			for (var i = 0; i < select.options.length; i += 1) {
				var option = select.options[i];

				if (option.__value === select_value_value) {
					option.selected = true;
					break;
				}
			}

			append_dev(nav, t7);
			append_dev(nav, a1);
			mount_component(icon2, a1, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.selected) && a0_href_value !== (a0_href_value = "tutorial/" + (ctx.selected.prev || ctx.selected).slug)) {
				attr_dev(a0, "href", a0_href_value);
			}

			if (changed.selected) {
				toggle_class(a0, "disabled", !ctx.selected.prev);
			}

			if ((!current || changed.selected) && t2_value !== (t2_value = ctx.selected.section.title + "")) {
				set_data_dev(t2, t2_value);
			}

			if ((!current || changed.selected) && t5_value !== (t5_value = ctx.selected.chapter.title + "")) {
				set_data_dev(t5, t5_value);
			}

			if (changed.sections) {
				each_value = ctx.sections;

				let i_1;
				for (i_1 = 0; i_1 < each_value.length; i_1 += 1) {
					const child_ctx = get_each_context(ctx, each_value, i_1);

					if (each_blocks[i_1]) {
						each_blocks[i_1].p(changed, child_ctx);
					} else {
						each_blocks[i_1] = create_each_block(child_ctx);
						each_blocks[i_1].c();
						each_blocks[i_1].m(select, null);
					}
				}

				for (; i_1 < each_blocks.length; i_1 += 1) {
					each_blocks[i_1].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if ((!current || changed.slug) && select_value_value !== (select_value_value = ctx.slug)) {
				for (var i = 0; i < select.options.length; i += 1) {
					var option = select.options[i];

					if (option.__value === select_value_value) {
						option.selected = true;
						break;
					}
				}
			}

			if ((!current || changed.selected) && a1_href_value !== (a1_href_value = "tutorial/" + (ctx.selected.next || ctx.selected).slug)) {
				attr_dev(a1, "href", a1_href_value);
			}

			if (changed.selected) {
				toggle_class(a1, "disabled", !ctx.selected.next);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);

			transition_in(icon1.$$.fragment, local);

			transition_in(icon2.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			transition_out(icon2.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(nav);
			}

			destroy_component(icon0);

			destroy_component(icon1);

			destroy_each(each_blocks, detaching);

			destroy_component(icon2);

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function navigate(e) {
	goto(`tutorial/${e.target.value}`);
}

function instance($$self, $$props, $$invalidate) {
	

	let { sections, slug, selected } = $$props;

	const writable_props = ['sections', 'slug', 'selected'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<TableOfContents> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
	};

	$$self.$capture_state = () => {
		return { sections, slug, selected };
	};

	$$self.$inject_state = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
	};

	return { sections, slug, selected };
}

class TableOfContents extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["sections", "slug", "selected"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "TableOfContents", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.sections === undefined && !('sections' in props)) {
			console.warn("<TableOfContents> was created without expected prop 'sections'");
		}
		if (ctx.slug === undefined && !('slug' in props)) {
			console.warn("<TableOfContents> was created without expected prop 'slug'");
		}
		if (ctx.selected === undefined && !('selected' in props)) {
			console.warn("<TableOfContents> was created without expected prop 'selected'");
		}
	}

	get sections() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get slug() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slug(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\tutorial\[slug]\index.svelte generated by Svelte v3.12.0 */
const { window: window_1 } = globals;

const file$1 = "src\\routes\\tutorial\\[slug]\\index.svelte";

// (282:5) {#if chapter.app_b}
function create_if_block_2(ctx) {
	var button, t_value = ctx.completed ? 'Reset' : 'Show me' + "", t, dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			t = claim_text(button_nodes, t_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(button, "class", "show svelte-163pr1f");
			add_location(button, file$1, 284, 6, 6052);
			dispose = listen_dev(button, "click", ctx.click_handler);
		},

		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
		},

		p: function update(changed, ctx) {
			if ((changed.completed) && t_value !== (t_value = ctx.completed ? 'Reset' : 'Show me' + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2.name, type: "if", source: "(282:5) {#if chapter.app_b}", ctx });
	return block;
}

// (290:5) {#if selected.next}
function create_if_block_1(ctx) {
	var a, t, a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			t = text("Next");
			this.h();
		},

		l: function claim(nodes) {
			a = claim_element(nodes, "A", { class: true, href: true }, false);
			var a_nodes = children(a);

			t = claim_text(a_nodes, "Next");
			a_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a, "class", "next svelte-163pr1f");
			attr_dev(a, "href", a_href_value = "tutorial/" + ctx.selected.next.slug);
			add_location(a, file$1, 290, 6, 6226);
		},

		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t);
		},

		p: function update(changed, ctx) {
			if ((changed.selected) && a_href_value !== (a_href_value = "tutorial/" + ctx.selected.next.slug)) {
				attr_dev(a, "href", a_href_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(290:5) {#if selected.next}", ctx });
	return block;
}

// (316:1) {#if mobile}
function create_if_block(ctx) {
	var updating_offset, current;

	function screentoggle_offset_binding(value) {
		ctx.screentoggle_offset_binding.call(null, value);
		updating_offset = true;
		add_flush_callback(() => updating_offset = false);
	}

	let screentoggle_props = { labels: ['tutorial', 'input', 'output'] };
	if (ctx.offset !== void 0) {
		screentoggle_props.offset = ctx.offset;
	}
	var screentoggle = new ScreenToggle({
		props: screentoggle_props,
		$$inline: true
	});

	binding_callbacks.push(() => bind(screentoggle, 'offset', screentoggle_offset_binding));

	const block = {
		c: function create() {
			screentoggle.$$.fragment.c();
		},

		l: function claim(nodes) {
			screentoggle.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(screentoggle, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var screentoggle_changes = {};
			if (!updating_offset && changed.offset) {
				screentoggle_changes.offset = ctx.offset;
			}
			screentoggle.$set(screentoggle_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(screentoggle.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(screentoggle.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(screentoggle, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(316:1) {#if mobile}", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var title_value, meta0, meta1, meta1_content_value, meta2, meta2_content_value, t0, div7, div6, div4, div0, t1, div3, html_tag, raw_value = ctx.chapter.html + "", t2, div1, t3, t4, div2, a, t5, t6, div5, div6_class_value, t7, current, dispose;

	add_render_callback(ctx.onwindowresize);

	document.title = title_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title + " • Svelte Tutorial";

	var tableofcontents = new TableOfContents({
		props: {
		sections: ctx.sections,
		slug: ctx.slug,
		selected: ctx.selected
	},
		$$inline: true
	});

	var if_block0 = (ctx.chapter.app_b) && create_if_block_2(ctx);

	var if_block1 = (ctx.selected.next) && create_if_block_1(ctx);

	let repl_1_props = {
		workersUrl: "workers",
		svelteUrl: svelteUrl,
		rollupUrl: rollupUrl,
		orientation: ctx.mobile ? 'columns' : 'rows',
		fixed: ctx.mobile,
		injectedJS: mapbox_setup,
		relaxed: true
	};
	var repl_1 = new Repl({ props: repl_1_props, $$inline: true });

	ctx.repl_1_binding(repl_1);
	repl_1.$on("change", ctx.handle_change);

	var if_block2 = (ctx.mobile) && create_if_block(ctx);

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t0 = space();
			div7 = element("div");
			div6 = element("div");
			div4 = element("div");
			div0 = element("div");
			tableofcontents.$$.fragment.c();
			t1 = space();
			div3 = element("div");
			t2 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			div2 = element("div");
			a = element("a");
			t5 = text("Edit this chapter");
			t6 = space();
			div5 = element("div");
			repl_1.$$.fragment.c();
			t7 = space();
			if (if_block2) if_block2.c();
			this.h();
		},

		l: function claim(nodes) {
			meta0 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta0_nodes = children(meta0);

			meta0_nodes.forEach(detach_dev);

			meta1 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta1_nodes = children(meta1);

			meta1_nodes.forEach(detach_dev);

			meta2 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta2_nodes = children(meta2);

			meta2_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);

			div7 = claim_element(nodes, "DIV", { class: true }, false);
			var div7_nodes = children(div7);

			div6 = claim_element(div7_nodes, "DIV", { class: true }, false);
			var div6_nodes = children(div6);

			div4 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div4_nodes = children(div4);

			div0 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			tableofcontents.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);

			div3 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			t2 = claim_space(div3_nodes);

			div1 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (if_block0) if_block0.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t4 = claim_space(div3_nodes);

			div2 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			a = claim_element(div2_nodes, "A", { class: true, href: true }, false);
			var a_nodes = children(a);

			t5 = claim_text(a_nodes, "Edit this chapter");
			a_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t6 = claim_space(div6_nodes);

			div5 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div5_nodes = children(div5);

			repl_1.$$.fragment.l(div5_nodes);
			div5_nodes.forEach(detach_dev);
			div6_nodes.forEach(detach_dev);
			t7 = claim_space(div7_nodes);
			if (if_block2) if_block2.l(div7_nodes);
			div7_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(meta0, "name", "twitter:title");
			attr_dev(meta0, "content", "Svelte tutorial");
			add_location(meta0, file$1, 263, 1, 5309);
			attr_dev(meta1, "name", "twitter:description");
			attr_dev(meta1, "content", meta1_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title);
			add_location(meta1, file$1, 264, 1, 5364);
			attr_dev(meta2, "name", "Description");
			attr_dev(meta2, "content", meta2_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title);
			add_location(meta2, file$1, 265, 1, 5461);
			attr_dev(div0, "class", "table-of-contents");
			add_location(div0, file$1, 273, 3, 5709);
			html_tag = new HtmlTag(raw_value, t2);
			attr_dev(div1, "class", "controls svelte-163pr1f");
			add_location(div1, file$1, 280, 4, 5889);
			attr_dev(a, "class", "no-underline svelte-163pr1f");
			attr_dev(a, "href", ctx.improve_link);
			add_location(a, file$1, 295, 5, 6350);
			attr_dev(div2, "class", "improve-chapter svelte-163pr1f");
			add_location(div2, file$1, 294, 4, 6315);
			attr_dev(div3, "class", "chapter-markup svelte-163pr1f");
			add_location(div3, file$1, 277, 3, 5807);
			attr_dev(div4, "class", "tutorial-text svelte-163pr1f");
			add_location(div4, file$1, 272, 2, 5678);
			attr_dev(div5, "class", "tutorial-repl");
			add_location(div5, file$1, 300, 2, 6449);
			attr_dev(div6, "class", div6_class_value = "viewport offset-" + ctx.offset + " svelte-163pr1f");
			add_location(div6, file$1, 271, 1, 5637);
			attr_dev(div7, "class", "tutorial-outer svelte-163pr1f");
			add_location(div7, file$1, 270, 0, 5607);
			dispose = listen_dev(window_1, "resize", ctx.onwindowresize);
		},

		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t0, anchor);
			insert_dev(target, div7, anchor);
			append_dev(div7, div6);
			append_dev(div6, div4);
			append_dev(div4, div0);
			mount_component(tableofcontents, div0, null);
			append_dev(div4, t1);
			append_dev(div4, div3);
			html_tag.m(div3);
			append_dev(div3, t2);
			append_dev(div3, div1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t3);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div2, a);
			append_dev(a, t5);
			ctx.div3_binding(div3);
			append_dev(div6, t6);
			append_dev(div6, div5);
			mount_component(repl_1, div5, null);
			append_dev(div7, t7);
			if (if_block2) if_block2.m(div7, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.selected) && title_value !== (title_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title + " • Svelte Tutorial")) {
				document.title = title_value;
			}

			if ((!current || changed.selected) && meta1_content_value !== (meta1_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title)) {
				attr_dev(meta1, "content", meta1_content_value);
			}

			if ((!current || changed.selected) && meta2_content_value !== (meta2_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title)) {
				attr_dev(meta2, "content", meta2_content_value);
			}

			var tableofcontents_changes = {};
			if (changed.slug) tableofcontents_changes.slug = ctx.slug;
			if (changed.selected) tableofcontents_changes.selected = ctx.selected;
			tableofcontents.$set(tableofcontents_changes);

			if ((!current || changed.chapter) && raw_value !== (raw_value = ctx.chapter.html + "")) {
				html_tag.p(raw_value);
			}

			if (ctx.chapter.app_b) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div1, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.selected.next) {
				if (if_block1) {
					if_block1.p(changed, ctx);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || changed.improve_link) {
				attr_dev(a, "href", ctx.improve_link);
			}

			var repl_1_changes = {};
			if (changed.mobile) repl_1_changes.orientation = ctx.mobile ? 'columns' : 'rows';
			if (changed.mobile) repl_1_changes.fixed = ctx.mobile;
			repl_1.$set(repl_1_changes);

			if ((!current || changed.offset) && div6_class_value !== (div6_class_value = "viewport offset-" + ctx.offset + " svelte-163pr1f")) {
				attr_dev(div6, "class", div6_class_value);
			}

			if (ctx.mobile) {
				if (if_block2) {
					if_block2.p(changed, ctx);
					transition_in(if_block2, 1);
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div7, null);
				}
			} else if (if_block2) {
				group_outros();
				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tableofcontents.$$.fragment, local);

			transition_in(repl_1.$$.fragment, local);

			transition_in(if_block2);
			current = true;
		},

		o: function outro(local) {
			transition_out(tableofcontents.$$.fragment, local);
			transition_out(repl_1.$$.fragment, local);
			transition_out(if_block2);
			current = false;
		},

		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);

			if (detaching) {
				detach_dev(t0);
				detach_dev(div7);
			}

			destroy_component(tableofcontents);

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			ctx.div3_binding(null);
			ctx.repl_1_binding(null);

			destroy_component(repl_1);

			if (if_block2) if_block2.d();
			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

async function preload({ params }) {
	const res = await this.fetch(`tutorial/${params.slug}.json`);

	if (!res.ok) {
		return this.redirect(301, `tutorial/basics`);
	}

	return {
		slug: params.slug,
		chapter: await res.json()
	};
}

const tutorial_repo_link = 'https://github.com/sveltejs/svelte/tree/master/site/content/tutorial';

function instance$1($$self, $$props, $$invalidate) {
	

	let { slug, chapter } = $$props;

	const { sections } = getContext('tutorial');

	let repl;
	let prev;
	let scrollable;
	const lookup = new Map();

	let width =  window.innerWidth ;
	let offset = 0;

	sections.forEach(section => {
		section.chapters.forEach(chapter => {
			const obj = {
				slug: chapter.slug,
				section,
				chapter,
				prev
			};

			lookup.set(chapter.slug, obj);

			{ // pending https://github.com/sveltejs/svelte/issues/2135
				if (prev) prev.next = obj;
				prev = obj;
			}
		});
	});

	const clone = file => ({
		name: file.name,
		type: file.type,
		source: file.source
	});

	function reset() {
		repl.update({
			components: chapter.app_a.map(clone)
		});
	}

	function complete() {
		repl.update({
			components: chapter.app_b.map(clone)
		});
	}

	let completed = false;

	function handle_change(event) {
		$$invalidate('completed', completed = event.detail.components.every((file, i) => {
			const expected = chapter.app_b[i];
			return expected && (
				file.name === expected.name &&
				file.type === expected.type &&
				file.source.trim().replace(/\s+$/gm, '') === expected.source.trim().replace(/\s+$/gm, '')
			);
		}));
	}

	const writable_props = ['slug', 'chapter'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	function onwindowresize() {
		width = window_1.innerWidth; $$invalidate('width', width);
	}

	const click_handler = () => completed ? reset() : complete();

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('scrollable', scrollable = $$value);
		});
	}

	function repl_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('repl', repl = $$value);
		});
	}

	function screentoggle_offset_binding(value) {
		offset = value;
		$$invalidate('offset', offset);
	}

	$$self.$set = $$props => {
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('chapter' in $$props) $$invalidate('chapter', chapter = $$props.chapter);
	};

	$$self.$capture_state = () => {
		return { slug, chapter, repl, prev, scrollable, width, offset, completed, selected, improve_link, mobile };
	};

	$$self.$inject_state = $$props => {
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('chapter' in $$props) $$invalidate('chapter', chapter = $$props.chapter);
		if ('repl' in $$props) $$invalidate('repl', repl = $$props.repl);
		if ('prev' in $$props) prev = $$props.prev;
		if ('scrollable' in $$props) $$invalidate('scrollable', scrollable = $$props.scrollable);
		if ('width' in $$props) $$invalidate('width', width = $$props.width);
		if ('offset' in $$props) $$invalidate('offset', offset = $$props.offset);
		if ('completed' in $$props) $$invalidate('completed', completed = $$props.completed);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('improve_link' in $$props) $$invalidate('improve_link', improve_link = $$props.improve_link);
		if ('mobile' in $$props) $$invalidate('mobile', mobile = $$props.mobile);
	};

	let selected, improve_link, mobile;

	$$self.$$.update = ($$dirty = { scrollable: 1, chapter: 1, slug: 1, selected: 1, repl: 1, width: 1 }) => {
		if ($$dirty.scrollable || $$dirty.chapter) { if (scrollable) scrollable.scrollTo(0, 0); }
		if ($$dirty.slug) { $$invalidate('selected', selected = lookup.get(slug)); }
		if ($$dirty.selected) { $$invalidate('improve_link', improve_link = `${tutorial_repo_link}/${selected.chapter.section_dir}/${selected.chapter.chapter_dir}`); }
		if ($$dirty.repl || $$dirty.chapter) { if (repl) {
				$$invalidate('completed', completed = false);
				repl.set({
					components: chapter.app_a.map(clone)
				});
			} }
		if ($$dirty.width) { $$invalidate('mobile', mobile = width < 768); }
	};

	return {
		slug,
		chapter,
		sections,
		repl,
		scrollable,
		width,
		offset,
		reset,
		complete,
		completed,
		handle_change,
		selected,
		improve_link,
		mobile,
		onwindowresize,
		click_handler,
		div3_binding,
		repl_1_binding,
		screentoggle_offset_binding
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["slug", "chapter"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.slug === undefined && !('slug' in props)) {
			console.warn("<Index> was created without expected prop 'slug'");
		}
		if (ctx.chapter === undefined && !('chapter' in props)) {
			console.warn("<Index> was created without expected prop 'chapter'");
		}
	}

	get slug() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slug(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get chapter() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set chapter(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Index;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNjZmMTQ2ODkuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvdHV0b3JpYWwvW3NsdWddL19UYWJsZU9mQ29udGVudHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy90dXRvcmlhbC9bc2x1Z10vaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG5cdGltcG9ydCB7IGdvdG8gfSBmcm9tICdAc2FwcGVyL2FwcCc7XG5cdGltcG9ydCB7IEljb24gfSBmcm9tICdAc3ZlbHRlanMvc2l0ZS1raXQnO1xuXG5cdGV4cG9ydCBsZXQgc2VjdGlvbnM7XG5cdGV4cG9ydCBsZXQgc2x1Zztcblx0ZXhwb3J0IGxldCBzZWxlY3RlZDtcblxuXHRmdW5jdGlvbiBuYXZpZ2F0ZShlKSB7XG5cdFx0Z290byhgdHV0b3JpYWwvJHtlLnRhcmdldC52YWx1ZX1gKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0bmF2IHtcblx0XHRkaXNwbGF5OiBncmlkO1xuXHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogMi41ZW0gMWZyIDIuNWVtO1xuXHRcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMSk7XG5cdH1cblxuXHRkaXYge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRwYWRkaW5nOiAxZW0gMC41ZW07XG5cdFx0Zm9udC13ZWlnaHQ6IDMwMDtcblx0XHRmb250LXNpemU6IHZhcigtLWg2KTtcblx0XHRjb2xvcjogd2hpdGU7XG5cdH1cblxuXHRhIHtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRwYWRkaW5nOiAwLjdlbSAwO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRvcGFjaXR5OiAwLjc1O1xuXHRcdGNvbG9yOiB3aGl0ZTtcblx0fVxuXG5cdGE6aG92ZXIge1xuXHRcdG9wYWNpdHk6IDE7XG5cdH1cblxuXHRhLmRpc2FibGVkLCBhLmRpc2FibGVkOmhvdmVyLCBhLmRpc2FibGVkOmFjdGl2ZSB7XG5cdFx0Y29sb3I6IHdoaXRlO1xuXHRcdG9wYWNpdHk6IDAuMztcblx0fVxuXG5cdHNwYW4ge1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuICAgIFx0dG9wOiAwLjNlbTtcblx0fVxuXG5cdHN0cm9uZyB7IG9wYWNpdHk6IDAuNyB9XG5cblx0c2VsZWN0IHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0bGVmdDogMDtcblx0XHR0b3A6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdG9wYWNpdHk6IDAuMDAwMTtcblx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0LXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuXHR9XG48L3N0eWxlPlxuXG48bmF2PlxuXHQ8YSByZWw9XCJwcmVmZXRjaFwiIGNsYXNzPVwibm8tdW5kZXJsaW5lXCIgaHJlZj1cInR1dG9yaWFsL3soc2VsZWN0ZWQucHJldiB8fCBzZWxlY3RlZCkuc2x1Z31cIiBjbGFzczpkaXNhYmxlZD17IXNlbGVjdGVkLnByZXZ9PlxuXHRcdDxJY29uIG5hbWU9XCJhcnJvdy1sZWZ0XCIgLz5cblx0PC9hPlxuXG5cdDxkaXY+XG5cdFx0PHNwYW4+XG5cdFx0XHQ8c3Ryb25nPlxuXHRcdFx0XHQ8c3BhbiBzdHlsZT1cInBvc2l0aW9uOiByZWxhdGl2ZTsgdG9wOiAtMC4xZW07IG1hcmdpbjogMCAwLjVlbSAwIDBcIj48SWNvbiBuYW1lPVwibWVudVwiLz48L3NwYW4+XG5cdFx0XHRcdHtzZWxlY3RlZC5zZWN0aW9uLnRpdGxlfSAvXG5cdFx0XHQ8L3N0cm9uZz5cblx0XHRcdHtzZWxlY3RlZC5jaGFwdGVyLnRpdGxlfVxuXHRcdDwvc3Bhbj5cblxuXHRcdDxzZWxlY3QgdmFsdWU9e3NsdWd9IG9uOmNoYW5nZT17bmF2aWdhdGV9PlxuXHRcdFx0eyNlYWNoIHNlY3Rpb25zIGFzIHNlY3Rpb24sIGl9XG5cdFx0XHRcdDxvcHRncm91cCBsYWJlbD1cIntpICsgMX0uIHtzZWN0aW9uLnRpdGxlfVwiPlxuXHRcdFx0XHRcdHsjZWFjaCBzZWN0aW9uLmNoYXB0ZXJzIGFzIGNoYXB0ZXIsIGl9XG5cdFx0XHRcdFx0XHQ8b3B0aW9uIHZhbHVlPXtjaGFwdGVyLnNsdWd9PntTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyA5Nyl9LiB7Y2hhcHRlci50aXRsZX08L29wdGlvbj5cblx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdDwvb3B0Z3JvdXA+XG5cdFx0XHR7L2VhY2h9XG5cdFx0PC9zZWxlY3Q+XG5cdDwvZGl2PlxuXG5cdDxhIHJlbD1cInByZWZldGNoXCIgY2xhc3M9XCJuby11bmRlcmxpbmVcIiBocmVmPVwidHV0b3JpYWwveyhzZWxlY3RlZC5uZXh0IHx8IHNlbGVjdGVkKS5zbHVnfVwiIGNsYXNzOmRpc2FibGVkPXshc2VsZWN0ZWQubmV4dH0+XG5cdFx0PEljb24gbmFtZT1cImFycm93LXJpZ2h0XCIgLz5cblx0PC9hPlxuPC9uYXY+XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQoeyBwYXJhbXMgfSkge1xuXHRcdGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2goYHR1dG9yaWFsLyR7cGFyYW1zLnNsdWd9Lmpzb25gKTtcblxuXHRcdGlmICghcmVzLm9rKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWRpcmVjdCgzMDEsIGB0dXRvcmlhbC9iYXNpY3NgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2x1ZzogcGFyYW1zLnNsdWcsXG5cdFx0XHRjaGFwdGVyOiBhd2FpdCByZXMuanNvbigpXG5cdFx0fTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCBSZXBsIGZyb20gJ0BzdmVsdGVqcy9zdmVsdGUtcmVwbCc7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCBTY3JlZW5Ub2dnbGUgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9TY3JlZW5Ub2dnbGUuc3ZlbHRlJztcblx0aW1wb3J0IFRhYmxlT2ZDb250ZW50cyBmcm9tICcuL19UYWJsZU9mQ29udGVudHMuc3ZlbHRlJztcblxuXHRpbXBvcnQge1xuXHRcdG1hcGJveF9zZXR1cCwgLy8gbmVlZGVkIGZvciBjb250ZXh0IEFQSSB0dXRvcmlhbFxuXHRcdHJvbGx1cFVybCxcblx0XHRzdmVsdGVVcmxcblx0fSBmcm9tICcuLi8uLi8uLi9jb25maWcnO1xuXG5cdGV4cG9ydCBsZXQgc2x1Zztcblx0ZXhwb3J0IGxldCBjaGFwdGVyO1xuXG5cdGNvbnN0IHsgc2VjdGlvbnMgfSA9IGdldENvbnRleHQoJ3R1dG9yaWFsJyk7XG5cblx0bGV0IHJlcGw7XG5cdGxldCBwcmV2O1xuXHRsZXQgc2Nyb2xsYWJsZTtcblx0Y29uc3QgbG9va3VwID0gbmV3IE1hcCgpO1xuXG5cdGxldCB3aWR0aCA9IHByb2Nlc3MuYnJvd3NlciA/IHdpbmRvdy5pbm5lcldpZHRoIDogMTAwMDtcblx0bGV0IG9mZnNldCA9IDA7XG5cblx0c2VjdGlvbnMuZm9yRWFjaChzZWN0aW9uID0+IHtcblx0XHRzZWN0aW9uLmNoYXB0ZXJzLmZvckVhY2goY2hhcHRlciA9PiB7XG5cdFx0XHRjb25zdCBvYmogPSB7XG5cdFx0XHRcdHNsdWc6IGNoYXB0ZXIuc2x1Zyxcblx0XHRcdFx0c2VjdGlvbixcblx0XHRcdFx0Y2hhcHRlcixcblx0XHRcdFx0cHJldlxuXHRcdFx0fTtcblxuXHRcdFx0bG9va3VwLnNldChjaGFwdGVyLnNsdWcsIG9iaik7XG5cblx0XHRcdGlmIChwcm9jZXNzLmJyb3dzZXIpIHsgLy8gcGVuZGluZyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8yMTM1XG5cdFx0XHRcdGlmIChwcmV2KSBwcmV2Lm5leHQgPSBvYmo7XG5cdFx0XHRcdHByZXYgPSBvYmo7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdC8vIFRPRE8gaXMgdGhlcmUgYSBub24taGFja3kgd2F5IHRvIHRyaWdnZXIgc2Nyb2xsIHdoZW4gY2hhcHRlciBjaGFuZ2VzP1xuXHQkOiBpZiAoc2Nyb2xsYWJsZSkgY2hhcHRlciwgc2Nyb2xsYWJsZS5zY3JvbGxUbygwLCAwKTtcblxuXHQvLyBUT0RPOiB0aGlzIHdpbGwgbmVlZCB0byBiZSBjaGFuZ2VkIHRvIHRoZSBtYXN0ZXIgYnJhbmNoLCBhbmQgcHJvYmFibHkgc2hvdWxkIGJlIGR5bmFtaWMgaW5zdGVhZCBvZiBpbmNsdWRlZFxuXHQvLyAgIGhlcmUgc3RhdGljYWxseVxuXHRjb25zdCB0dXRvcmlhbF9yZXBvX2xpbmsgPSAnaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS90cmVlL21hc3Rlci9zaXRlL2NvbnRlbnQvdHV0b3JpYWwnO1xuXG5cdCQ6IHNlbGVjdGVkID0gbG9va3VwLmdldChzbHVnKTtcblx0JDogaW1wcm92ZV9saW5rID0gYCR7dHV0b3JpYWxfcmVwb19saW5rfS8ke3NlbGVjdGVkLmNoYXB0ZXIuc2VjdGlvbl9kaXJ9LyR7c2VsZWN0ZWQuY2hhcHRlci5jaGFwdGVyX2Rpcn1gO1xuXG5cdGNvbnN0IGNsb25lID0gZmlsZSA9PiAoe1xuXHRcdG5hbWU6IGZpbGUubmFtZSxcblx0XHR0eXBlOiBmaWxlLnR5cGUsXG5cdFx0c291cmNlOiBmaWxlLnNvdXJjZVxuXHR9KTtcblxuXHQkOiBpZiAocmVwbCkge1xuXHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdHJlcGwuc2V0KHtcblx0XHRcdGNvbXBvbmVudHM6IGNoYXB0ZXIuYXBwX2EubWFwKGNsb25lKVxuXHRcdH0pO1xuXHR9XG5cblx0JDogbW9iaWxlID0gd2lkdGggPCA3Njg7XG5cblx0ZnVuY3Rpb24gcmVzZXQoKSB7XG5cdFx0cmVwbC51cGRhdGUoe1xuXHRcdFx0Y29tcG9uZW50czogY2hhcHRlci5hcHBfYS5tYXAoY2xvbmUpXG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wbGV0ZSgpIHtcblx0XHRyZXBsLnVwZGF0ZSh7XG5cdFx0XHRjb21wb25lbnRzOiBjaGFwdGVyLmFwcF9iLm1hcChjbG9uZSlcblx0XHR9KTtcblx0fVxuXG5cdGxldCBjb21wbGV0ZWQgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBoYW5kbGVfY2hhbmdlKGV2ZW50KSB7XG5cdFx0Y29tcGxldGVkID0gZXZlbnQuZGV0YWlsLmNvbXBvbmVudHMuZXZlcnkoKGZpbGUsIGkpID0+IHtcblx0XHRcdGNvbnN0IGV4cGVjdGVkID0gY2hhcHRlci5hcHBfYltpXTtcblx0XHRcdHJldHVybiBleHBlY3RlZCAmJiAoXG5cdFx0XHRcdGZpbGUubmFtZSA9PT0gZXhwZWN0ZWQubmFtZSAmJlxuXHRcdFx0XHRmaWxlLnR5cGUgPT09IGV4cGVjdGVkLnR5cGUgJiZcblx0XHRcdFx0ZmlsZS5zb3VyY2UudHJpbSgpLnJlcGxhY2UoL1xccyskL2dtLCAnJykgPT09IGV4cGVjdGVkLnNvdXJjZS50cmltKCkucmVwbGFjZSgvXFxzKyQvZ20sICcnKVxuXHRcdFx0KTtcblx0XHR9KTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LnR1dG9yaWFsLW91dGVyIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0aGVpZ2h0OiBjYWxjKDEwMHZoIC0gdmFyKC0tbmF2LWgpKTtcblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdHBhZGRpbmc6IDAgMCA0MnB4IDA7XG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0fVxuXG5cdC52aWV3cG9ydCB7XG5cdFx0ZGlzcGxheTogZ3JpZDtcblx0XHR3aWR0aDogMzAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAzMy4zMzMlIDY2LjY2NiU7XG5cdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIC4zcztcblx0XHRncmlkLWF1dG8tcm93czogMTAwJTtcblx0fVxuXG5cdC5vZmZzZXQtMSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0zMy4zMzMlLCAwKTsgfVxuXHQub2Zmc2V0LTIgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNjYuNjY2JSwgMCk7IH1cblxuXHRAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcblx0XHQudHV0b3JpYWwtb3V0ZXIgeyBwYWRkaW5nOiAwIH1cblxuXHRcdC52aWV3cG9ydCB7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdGhlaWdodDogMTAwJTtcblx0XHRcdGRpc3BsYXk6IGdyaWQ7XG5cdFx0XHRncmlkLXRlbXBsYXRlLWNvbHVtbnM6IG1pbm1heCgzMy4zMzMlLCB2YXIoLS1zaWRlYmFyLWxhcmdlLXcpKSBhdXRvO1xuXHRcdFx0Z3JpZC1hdXRvLXJvd3M6IDEwMCU7XG5cdFx0XHR0cmFuc2l0aW9uOiBub25lO1xuXHRcdH1cblxuXHRcdC5vZmZzZXQtMSwgLm9mZnNldC0yIHsgdHJhbnNmb3JtOiBub25lOyB9XG5cdH1cblxuXHQudHV0b3JpYWwtdGV4dCB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRib3JkZXItcmlnaHQ6IDFweCBzb2xpZCB2YXIoLS1zZWNvbmQpO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXNlY29uZCk7XG5cdFx0Y29sb3I6IHZhcigtLXNpZGViYXItdGV4dCk7XG5cdH1cblxuXHQuY2hhcHRlci1tYXJrdXAge1xuXHRcdHBhZGRpbmc6IDMuMnJlbSA0cmVtO1xuXHRcdG92ZXJmbG93OiBhdXRvO1xuXHRcdGZsZXg6IDE7XG5cdFx0aGVpZ2h0OiAwO1xuXHR9XG5cblx0LmNoYXB0ZXItbWFya3VwIDpnbG9iYWwoaDIpIHtcblx0XHRtYXJnaW46IDRyZW0gMCAxLjZyZW0gMDtcblx0XHRmb250LXNpemU6IHZhcigtLWgzKTtcblx0XHRsaW5lLWhlaWdodDogMTtcblx0XHRmb250LXdlaWdodDogNDAwO1xuXHRcdGNvbG9yOiB3aGl0ZTtcblx0fVxuXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKGgyOmZpcnN0LWNoaWxkKSB7XG5cdFx0bWFyZ2luLXRvcDogLjRyZW07XG5cdH1cblxuXHQuY2hhcHRlci1tYXJrdXAgOmdsb2JhbChhKSB7XG5cdFx0Y29sb3I6IHZhcigtLXNpZGViYXItdGV4dCk7XG5cdH1cblxuXHQuY2hhcHRlci1tYXJrdXAgOmdsb2JhbChhOmhvdmVyKSB7XG5cdFx0Y29sb3I6IHdoaXRlO1xuXHR9XG5cblxuXHQuY2hhcHRlci1tYXJrdXAgOmdsb2JhbCh1bCkge1xuXHRcdHBhZGRpbmc6IDAgMCAwIDJlbTtcblx0fVxuXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKGJsb2NrcXVvdGUpIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsMCwwLC4xNyk7XG5cdFx0Y29sb3I6IHZhcigtLXNpZGViYXItdGV4dCk7XG5cdH1cblxuXHQuY2hhcHRlci1tYXJrdXA6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zZWNvbmQpO1xuXHRcdHdpZHRoOiA4cHg7XG5cdH1cblxuXHQuY2hhcHRlci1tYXJrdXA6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwyNTUsMjU1LC43KTtcblx0XHRib3JkZXItcmFkaXVzOiAxZW07XG5cdFx0b3V0bGluZTogMXB4IHNvbGlkIGdyZWVuO1xuXHR9XG5cblx0LmNoYXB0ZXItbWFya3VwIDpnbG9iYWwocCkgPiA6Z2xvYmFsKGNvZGUpLFxuXHQuY2hhcHRlci1tYXJrdXAgOmdsb2JhbCh1bCkgOmdsb2JhbChjb2RlKSB7XG5cdFx0Y29sb3I6IHZhcigtLXNpZGViYXItdGV4dCk7XG5cdFx0YmFja2dyb3VuZDogcmdiYSgwLDAsMCwuMTIpO1xuXHRcdHBhZGRpbmc6IC4yZW0gLjRlbSAuM2VtO1xuXHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdHRvcDogLTAuMWVtO1xuXHR9XG5cblx0LmNvbnRyb2xzIHtcblx0XHRib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwuMTUpO1xuXHRcdHBhZGRpbmc6IDFlbSAwIDAgMDtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHR9XG5cblx0LnNob3cge1xuXHRcdGJhY2tncm91bmQ6IHZhcigtLXByaW1lKTtcblx0XHRwYWRkaW5nOiAuM2VtIC43ZW07XG5cdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXIpO1xuXHRcdHRvcDogLjFlbTtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0Zm9udC1zaXplOiB2YXIoLS1oNSk7XG5cdFx0Zm9udC13ZWlnaHQ6IDMwMDtcblx0XHRjb2xvcjogcmdiYSgyNTUsMjU1LDI1NSwwLjcpO1xuXHR9XG5cblx0LnNob3c6aG92ZXIge1xuXHRcdGNvbG9yOiB3aGl0ZTtcblx0fVxuXG5cdGEubmV4dCB7XG5cdFx0cGFkZGluZy1yaWdodDogMS4yZW07XG5cdFx0YmFja2dyb3VuZDogbm8tcmVwZWF0IDEwMCUgNTAlIHVybCgvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnKTtcblx0XHRiYWNrZ3JvdW5kLXNpemU6IDFlbSAxZW07XG5cdFx0bWFyZ2luLWxlZnQ6IGF1dG87XG5cdH1cblxuXHQuaW1wcm92ZS1jaGFwdGVyIHtcblx0XHRwYWRkaW5nOiAxZW0gMCAuNWVtIDA7XG5cdH1cblxuXHQuaW1wcm92ZS1jaGFwdGVyIGEge1xuXHRcdHBhZGRpbmc6IDAgLjFlbTtcblx0XHRmb250LXNpemU6IDE0cHg7XG5cdFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xuXHRcdG9wYWNpdHk6IC4zO1xuXHRcdHBhZGRpbmctbGVmdDogMS4yZW07XG5cdFx0YmFja2dyb3VuZDogbm8tcmVwZWF0IDAgNTAlIHVybCgvaWNvbnMvZWRpdC5zdmcpO1xuXHRcdGJhY2tncm91bmQtc2l6ZTogMWVtIDFlbTtcblx0fVxuXG5cdC5pbXByb3ZlLWNoYXB0ZXIgYTpob3ZlciB7XG5cdFx0b3BhY2l0eTogMTtcblx0fVxuPC9zdHlsZT5cblxuPHN2ZWx0ZTpoZWFkPlxuXHQ8dGl0bGU+e3NlbGVjdGVkLnNlY3Rpb24udGl0bGV9IC8ge3NlbGVjdGVkLmNoYXB0ZXIudGl0bGV9IOKAoiBTdmVsdGUgVHV0b3JpYWw8L3RpdGxlPlxuXG5cdDxtZXRhIG5hbWU9XCJ0d2l0dGVyOnRpdGxlXCIgY29udGVudD1cIlN2ZWx0ZSB0dXRvcmlhbFwiPlxuXHQ8bWV0YSBuYW1lPVwidHdpdHRlcjpkZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJ7c2VsZWN0ZWQuc2VjdGlvbi50aXRsZX0gLyB7c2VsZWN0ZWQuY2hhcHRlci50aXRsZX1cIj5cblx0PG1ldGEgbmFtZT1cIkRlc2NyaXB0aW9uXCIgY29udGVudD1cIntzZWxlY3RlZC5zZWN0aW9uLnRpdGxlfSAvIHtzZWxlY3RlZC5jaGFwdGVyLnRpdGxlfVwiPlxuPC9zdmVsdGU6aGVhZD5cblxuPHN2ZWx0ZTp3aW5kb3cgYmluZDppbm5lcldpZHRoPXt3aWR0aH0vPlxuXG48ZGl2IGNsYXNzPVwidHV0b3JpYWwtb3V0ZXJcIj5cblx0PGRpdiBjbGFzcz1cInZpZXdwb3J0IG9mZnNldC17b2Zmc2V0fVwiPlxuXHRcdDxkaXYgY2xhc3M9XCJ0dXRvcmlhbC10ZXh0XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidGFibGUtb2YtY29udGVudHNcIj5cblx0XHRcdFx0PFRhYmxlT2ZDb250ZW50cyB7c2VjdGlvbnN9IHtzbHVnfSB7c2VsZWN0ZWR9Lz5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IGNsYXNzPVwiY2hhcHRlci1tYXJrdXBcIiBiaW5kOnRoaXM9e3Njcm9sbGFibGV9PlxuXHRcdFx0XHR7QGh0bWwgY2hhcHRlci5odG1sfVxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJjb250cm9sc1wiPlxuXHRcdFx0XHRcdHsjaWYgY2hhcHRlci5hcHBfYn1cblx0XHRcdFx0XHRcdDwhLS0gVE9ETyBkaXNhYmxlIHRoaXMgYnV0dG9uIHdoZW4gdGhlIGNvbnRlbnRzIG9mIHRoZSBSRVBMXG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMgdGhlIGV4cGVjdGVkIGVuZCByZXN1bHQgLS0+XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwic2hvd1wiIG9uOmNsaWNrPVwieygpID0+IGNvbXBsZXRlZCA/IHJlc2V0KCkgOiBjb21wbGV0ZSgpfVwiPlxuXHRcdFx0XHRcdFx0XHR7Y29tcGxldGVkID8gJ1Jlc2V0JyA6ICdTaG93IG1lJ31cblx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdHsvaWZ9XG5cblx0XHRcdFx0XHR7I2lmIHNlbGVjdGVkLm5leHR9XG5cdFx0XHRcdFx0XHQ8YSBjbGFzcz1cIm5leHRcIiBocmVmPVwidHV0b3JpYWwve3NlbGVjdGVkLm5leHQuc2x1Z31cIj5OZXh0PC9hPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbXByb3ZlLWNoYXB0ZXJcIj5cblx0XHRcdFx0XHQ8YSBjbGFzcz1cIm5vLXVuZGVybGluZVwiIGhyZWY9e2ltcHJvdmVfbGlua30+RWRpdCB0aGlzIGNoYXB0ZXI8L2E+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwidHV0b3JpYWwtcmVwbFwiPlxuXHRcdFx0PFJlcGxcblx0XHRcdFx0YmluZDp0aGlzPXtyZXBsfVxuXHRcdFx0XHR3b3JrZXJzVXJsPVwid29ya2Vyc1wiXG5cdFx0XHRcdHtzdmVsdGVVcmx9XG5cdFx0XHRcdHtyb2xsdXBVcmx9XG5cdFx0XHRcdG9yaWVudGF0aW9uPXttb2JpbGUgPyAnY29sdW1ucycgOiAncm93cyd9XG5cdFx0XHRcdGZpeGVkPXttb2JpbGV9XG5cdFx0XHRcdG9uOmNoYW5nZT17aGFuZGxlX2NoYW5nZX1cblx0XHRcdFx0aW5qZWN0ZWRKUz17bWFwYm94X3NldHVwfVxuXHRcdFx0XHRyZWxheGVkXG5cdFx0XHQvPlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cblxuXHR7I2lmIG1vYmlsZX1cblx0XHQ8U2NyZWVuVG9nZ2xlIGJpbmQ6b2Zmc2V0IGxhYmVscz17Wyd0dXRvcmlhbCcsICdpbnB1dCcsICdvdXRwdXQnXX0vPlxuXHR7L2lmfVxuPC9kaXY+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQW1Gb0MsTUFBTSxDQUFDLFlBQVksS0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLDhCQUFJLE9BQU8sQ0FBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2Q0FBM0QsT0FBTyxDQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7MERBQWtDLE9BQU8sQ0FBQyxLQUFLOzs7OzhFQUEzRCxPQUFPLENBQUMsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQURyQixPQUFPLENBQUMsUUFBUTs7OztzQ0FBckI7Ozs7Ozs7O3VDQUFBOzs7Ozs7Ozs7O3VDQUFBOzs7Ozs7Ozs7Z0VBRGUsQ0FBQyxHQUFHLENBQUMsZUFBSSxPQUFPLENBQUMsS0FBSzs7Ozs7Ozt1Q0FDckM7Ozs7Ozs7dUJBQUssT0FBTyxDQUFDLFFBQVE7OztxQ0FBckI7Ozs7Ozs7Ozs7Ozs2QkFBQTs7O2dCQUFBLHNCQUFBOzs7d0ZBRGUsQ0FBQyxHQUFHLENBQUMsZUFBSSxPQUFPLENBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7OytFQVB2QyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssa0NBRXZCLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSzs7Ozs7Ozs7O3NCQUloQixRQUFROzs7O29DQUFiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0RBZG1ELEtBQUMsUUFBUSxDQUFDLElBQUksUUFBSSxRQUFRLEVBQUUsSUFBSTtnQ0FBbUIsS0FBQyxRQUFRLENBQUMsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7c0RBd0JqRSxLQUFDLFFBQVEs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
