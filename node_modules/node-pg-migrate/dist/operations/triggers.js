"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const _require = require("lodash"),
      isArray = _require.isArray;

const _require2 = require("../utils"),
      escapeValue = _require2.escapeValue,
      template = _require2.template;

const _require3 = require("./functions"),
      createFunction = _require3.createFunction,
      dropFunction = _require3.dropFunction;

function dropTrigger(tableName, triggerName, {
  ifExists,
  cascade
} = {}) {
  const ifExistsStr = ifExists ? " IF EXISTS" : "";
  const cascadeStr = cascade ? " CASCADE" : "";
  return template`DROP TRIGGER${ifExistsStr} "${triggerName}" ON "${tableName}"${cascadeStr};`;
}

function createTrigger(typeShorthands) {
  const _create = (tableName, triggerName, triggerOptions = {}, definition) => {
    const constraint = triggerOptions.constraint,
          condition = triggerOptions.condition,
          operation = triggerOptions.operation,
          deferrable = triggerOptions.deferrable,
          deferred = triggerOptions.deferred,
          _triggerOptions$funct = triggerOptions.functionArgs,
          functionArgs = _triggerOptions$funct === void 0 ? [] : _triggerOptions$funct;
    let when = triggerOptions.when,
        _triggerOptions$level = triggerOptions.level,
        level = _triggerOptions$level === void 0 ? "STATEMENT" : _triggerOptions$level,
        functionName = triggerOptions.function;
    const operations = isArray(operation) ? operation.join(" OR ") : operation;

    if (constraint) {
      when = "AFTER";
    }

    const isInsteadOf = /instead\s+of/i.test(when);

    if (isInsteadOf) {
      level = "ROW";
    }

    if (definition) {
      functionName = functionName || triggerName;
    }

    if (!when) {
      throw new Error('"when" (BEFORE/AFTER/INSTEAD OF) have to be specified');
    } else if (isInsteadOf && condition) {
      throw new Error("INSTEAD OF trigger can't have condition specified");
    }

    if (!operations) {
      throw new Error('"operation" (INSERT/UPDATE[ OF ...]/DELETE/TRUNCATE) have to be specified');
    }

    const defferStr = constraint ? `${deferrable ? `DEFERRABLE INITIALLY ${deferred ? "DEFERRED" : "IMMEDIATE"}` : "NOT DEFERRABLE"}\n  ` : "";
    const conditionClause = condition ? `WHEN (${condition})\n  ` : "";
    const constraintStr = constraint ? " CONSTRAINT" : "";
    const paramsStr = functionArgs.map(escapeValue).join(", ");
    const triggerSQL = template`CREATE${constraintStr} TRIGGER "${triggerName}"
  ${when} ${operations} ON "${tableName}"
  ${defferStr}FOR EACH ${level}
  ${conditionClause}EXECUTE PROCEDURE "${functionName}"(${paramsStr});`;
    const fnSQL = definition ? `${createFunction(typeShorthands)(functionName, [], _objectSpread({}, triggerOptions, {
      returns: "trigger"
    }), definition)}\n` : "";
    return `${fnSQL}${triggerSQL}`;
  };

  _create.reverse = (tableName, triggerName, triggerOptions = {}, definition) => {
    const triggerSQL = dropTrigger(tableName, triggerName, triggerOptions);
    const fnSQL = definition ? `\n${dropFunction(typeShorthands)(triggerOptions.function || triggerName, [], triggerOptions)}` : "";
    return `${triggerSQL}${fnSQL}`;
  };

  return _create;
}

function renameTrigger(tableName, oldTriggerName, newTriggerName) {
  return template`ALTER TRIGGER "${oldTriggerName}" ON "${tableName}" RENAME TO "${newTriggerName}";`;
}

const undoRename = (tableName, oldTriggerName, newTriggerName) => renameTrigger(tableName, newTriggerName, oldTriggerName);

renameTrigger.reverse = undoRename;
module.exports = {
  createTrigger,
  dropTrigger,
  renameTrigger
};