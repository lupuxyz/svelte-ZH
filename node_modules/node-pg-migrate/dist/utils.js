"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// This is used to create unescaped strings
// exposed in the migrations via pgm.func
class PgLiteral {
  static create(str) {
    return new PgLiteral(str);
  }

  constructor(str) {
    this._str = str;
  }

  toString() {
    return this._str;
  }

}

const schemalize = v => {
  if (typeof v === "object") {
    const schema = v.schema,
          name = v.name;
    return (schema ? `${schema}"."` : "") + name;
  }

  return v;
};

const opSchemalize = v => {
  if (typeof v === "object") {
    const schema = v.schema,
          name = v.name;
    return schema ? `OPERATOR(${schema}.${name})` : name;
  }

  return v;
};

const t = (s, d) => Object.keys(d || {}).reduce((str, p) => str.replace(new RegExp(`{${p}}`, "g"), schemalize(d[p])), // eslint-disable-line security/detect-non-literal-regexp
s);

const escapeValue = val => {
  if (val === null) {
    return "NULL";
  }

  if (typeof val === "boolean") {
    return val.toString();
  }

  if (typeof val === "string") {
    let dollars;
    let index = 0;

    do {
      index += 1;
      dollars = `$pg${index}$`;
    } while (val.indexOf(dollars) >= 0);

    return `${dollars}${val}${dollars}`;
  }

  if (typeof val === "number") {
    return val;
  }

  if (Array.isArray(val)) {
    const arrayStr = val.map(escapeValue).join(",").replace(/ARRAY/g, "");
    return `ARRAY[${arrayStr}]`;
  }

  if (val instanceof PgLiteral) {
    return val.toString();
  }

  return "";
};

const template = (strings, ...keys) => {
  const result = [strings[0]];
  keys.forEach((key, i) => {
    result.push(schemalize(key), strings[i + 1]);
  });
  return result.join("");
};

const opTemplate = (strings, ...keys) => {
  const result = [strings[0]];
  keys.forEach((key, i) => {
    result.push(opSchemalize(key), strings[i + 1]);
  });
  return result.join("");
};

const getSchemas = schema => {
  const schemas = (Array.isArray(schema) ? schema : [schema]).filter(s => typeof s === "string" && s.length > 0);
  return schemas.length > 0 ? schemas : ["public"];
};

const getMigrationTableSchema = options => options.migrationsSchema !== undefined ? options.migrationsSchema : getSchemas(options.schema)[0];

const quote = array => array.map(item => template`"${item}"`);

const typeAdapters = {
  int: "integer",
  string: "text",
  float: "real",
  double: "double precision",
  datetime: "timestamp",
  bool: "boolean"
};
const defaultTypeShorthands = {
  id: {
    type: "serial",
    primaryKey: true // convenience type for serial primary keys

  }
}; // some convenience adapters -- see above

const applyTypeAdapters = type => typeAdapters[type] ? typeAdapters[type] : type;

const applyType = (type, extendingTypeShorthands = {}) => {
  const typeShorthands = _objectSpread({}, defaultTypeShorthands, {}, extendingTypeShorthands);

  const options = typeof type === "string" ? {
    type
  } : type;
  let ext = null;
  const types = [options.type];

  while (typeShorthands[types[types.length - 1]]) {
    if (ext) {
      delete ext.type;
    }

    ext = _objectSpread({}, typeShorthands[types[types.length - 1]], {}, ext);

    if (types.includes(ext.type)) {
      throw new Error(`Shorthands contain cyclic dependency: ${types.join(", ")}, ${ext.type}`);
    } else {
      types.push(ext.type);
    }
  }

  if (!ext) {
    ext = {
      type: options.type
    };
  }

  return _objectSpread({}, ext, {}, options, {
    type: applyTypeAdapters(ext.type)
  });
};

const formatParam = typeShorthands => param => {
  const _applyType = applyType(param, typeShorthands),
        mode = _applyType.mode,
        name = _applyType.name,
        type = _applyType.type,
        defaultValue = _applyType.default;

  const options = [];

  if (mode) {
    options.push(mode);
  }

  if (name) {
    options.push(schemalize(name));
  }

  if (type) {
    options.push(type);
  }

  if (defaultValue) {
    options.push(`DEFAULT ${escapeValue(defaultValue)}`);
  }

  return options.join(" ");
};

const formatParams = (params = [], typeShorthands) => `(${params.map(formatParam(typeShorthands)).join(", ")})`;

const comment = (object, name, text) => {
  const cmt = escapeValue(text || null);
  return template`COMMENT ON ${object} "${name}" IS ${cmt};`;
};

const formatLines = (lines, replace = "  ", separator = ",") => lines.map(line => line.replace(/(?:\r\n|\r|\n)+/g, " ")).join(`${separator}\n`).replace(/^/gm, replace);

const promisify = fn => (...args) => new Promise((resolve, reject) => fn.call(void 0, ...args, (err, ...result) => err ? reject(err) : resolve(...result)));

module.exports = {
  schemalize,
  opSchemalize,
  PgLiteral,
  t,
  escapeValue,
  template,
  opTemplate,
  getSchemas,
  getMigrationTableSchema,
  quote,
  applyTypeAdapters,
  applyType,
  formatParams,
  comment,
  formatLines,
  promisify
};